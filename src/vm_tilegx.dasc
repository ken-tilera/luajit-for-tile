|// Low-level VM code for Tilera CPU, Contributed by Jiong Wang.
|// Bytecode interpreter, fast functions and helper functions.
|// Copyright (C) 2005-2013 Mike Pall. See Copyright Notice in luajit.h
|// Copyright (C) 2013-2013 Tilera Corporation. See Copyright Notice in luajit.h
|
|.arch tilegx
|.section code_sub, code_op
|
|.actionlist build_actionlist
|.globals GLOB_
|.globalnames globnames
|.externnames extnames
|
|// Note: currently, at most one relocation is allowed in one bundle.
|
|//-----------------------------------------------------------------------
|
|// Fixed register assignments for the interpreter.
|// Don't use: r51 = gp, r53 = tp, r54 = sp, r55 = lr.
|
|// The following must be C callee-save (but BASE is often refetched).
|.define BASE,		r30	// Base of current Lua stack frame.
|.define KBASE,		r31	// Constants of current Lua function.
|.define PC,		r32	// Next PC.
|.define DISPATCH,	r33	// Opcode dispatch table.
|.define LREG,		r34	// Register holding lua_State (also in SAVE_L).
|.define MULTRES,	r35	// Size of multi-result: (nresults+1)*8.
|//                     r36     // not used.
|.define RA,		r37	// RA need to be callee-save.
|.define CROSSTMP1,	r38	// TMP used to hold variable which need to be alive across C call.
|.define TOBIT,		r39
|.define ASMENTRY,	r45
|
|.define JGL,		r52	// On-trace: global_State + 32768.
|
|// Constants for type-comparisons, stores and conversions. C callee-save.
|.define TISNUM,	r51
|.define TISNIL,	r52
|
|// The following temporaries are not saved across C calls, except for RA.
|.define RB,		r14
|.define RC,		r15
|.define RD,		r16
|.define INS,		r17
|
|.define TMP0,		r18
|.define TMP1,		r19
|.define TMP2,		r20
|.define TMP3,		r21
|
|.define AT,		r22
|.define AT1,		r23
|.define AT2,		r24 // For softfloat
|.define AT3,		r25 // For softfloat
|.define AT4,		r26 // For softfloat
|.define AT5,		r27 // For softfloat
|.define AT6,		r28 // For softfloat

|// Calling conventions.
|// TileGX PIC don't require function address pre-loaded into a specific
|// reg, because we have instruction (lnk) which could get the current pc,
|// so here we just specify one caller-saved reg r29 to hold the func addr.
|.define CFUNCADDR,	r29
|.define CARG1,		r0
|.define CARG2,		r1
|.define CARG3,		r2
|.define CARG4,		r3
|.define CARG5,		r4
|.define ARG5,		r4 // alias for CARG5
|
|// TileGX ABI use r0 ~ r9 as both arg passing and value returning.
|.define CRET1,		r0
|.define CRET2,		r1
|
|// Stack layout while in interpreter. Must match with lj_frame.h.
|.define CFRAME_SPACE,	144	// Delta for sp.
|
|.define SAVE_ERRF,	168	// 64 bit C frame info.
|.define SAVE_NRES,	160
|.define SAVE_CFRAME,	152
|.define SAVE_L,	144
|//----- 8 byte aligned, ^^^^ 32 byte register save area, owned by interpreter.
|.define TILE_ABI_RESERV,	32	// .. 32+13*8: 64 bit GPR saves.
|.define SAVE_MULTRES,		24	
|.define SAVE_PC,		16	
|//----- 8 byte aligned, ^^^^ 32 byte register save area, owned by callee.
|
|.macro mulx, a, b, c
|  B_X
|    B_mulx_x0 a, b, c
|    B_fnop_x1
|.endmacro
|
|.macro v4int_l, a, b, c
|  B_X
|    B_fnop_x0
|    B_v4int_l_x1 a, b, c
|.endmacro
|
|.macro rotl, a, b, c
|  B_X
|    B_fnop_x0
|    B_rotl_x1 a, b, c
|.endmacro
|
|.macro add, a, b, c
|  B_X
|    B_fnop_x0
|    B_add_x1 a, b, c
|.endmacro
|
|.macro sub, a, b, c
|  B_X
|    B_fnop_x0
|    B_sub_x1 a, b, c
|.endmacro
|
|.macro subx, a, b, c
|  B_X
|    B_fnop_x0
|    B_subx_x1 a, b, c
|.endmacro
|
|.macro addx, a, b, c
|  B_X
|    B_fnop_x0
|    B_addx_x1 a, b, c
|.endmacro
|
|.macro move, a, b
|  B_X
|    B_fnop_x0
|    B_move_x1 a, b
|.endmacro
|
|.macro movei, a, b
|  B_X
|    B_fnop_x0
|    B_movei_x1 a, b
|.endmacro
|
|.macro moveli, a, b
|  B_X
|    B_fnop_x0
|    B_moveli_x1 a, b
|.endmacro
|
|.macro addli, a, b, c
|  B_X
|    B_fnop_x0
|    B_addli_x1 a, b, c
|.endmacro
|
|.macro addlo, a, b
|  B_X
|    B_fnop_x0
|    B_addlo_x1 a, b
|.endmacro
|
|.macro shl16insli, a, b, c
|  B_X
|    B_fnop_x0
|    B_shl16insli_x1 a, b, c
|.endmacro
|
|.macro addi, a, b, c
|  B_X
|    B_fnop_x0
|    B_addi_x1 a, b, c
|.endmacro
|
|.macro addxi, a, b, c
|  B_X
|    B_fnop_x0
|    B_addxi_x1 a, b, c
|.endmacro
|
|.macro and, a, b, c
|  B_X
|    B_fnop_x0
|    B_and_x1 a, b, c
|.endmacro
|
|.macro or, a, b, c
|  B_X
|    B_fnop_x0
|    B_or_x1 a, b, c
|.endmacro
|
|.macro nor, a, b, c
|  B_X
|    B_fnop_x0
|    B_nor_x1 a, b, c
|.endmacro
|
|.macro xor, a, b, c
|  B_X
|    B_fnop_x0
|    B_xor_x1 a, b, c
|.endmacro
|
|.macro xori, a, b, c
|  B_X
|    B_fnop_x0
|    B_xori_x1 a, b, c
|.endmacro
|
|.macro andi, a, b, c
|  B_X
|    B_fnop_x0
|    B_andi_x1 a, b, c
|.endmacro
|
|.macro ori, a, b, c
|  B_X
|    B_fnop_x0
|    B_ori_x1 a, b, c
|.endmacro
|
|.macro shl, a, b, c
|  B_X
|    B_fnop_x0
|    B_shl_x1 a, b, c
|.endmacro
|
|.macro shlx, a, b, c
|  B_X
|    B_fnop_x0
|    B_shlx_x1 a, b, c
|.endmacro
|
|.macro shli, a, b, c
|  B_X
|    B_fnop_x0
|    B_shli_x1 a, b, c
|.endmacro
|
|.macro shru, a, b, c
|  B_X
|    B_fnop_x0
|    B_shru_x1 a, b, c
|.endmacro
|
|.macro shrui, a, b, c
|  B_X
|    B_fnop_x0
|    B_shrui_x1 a, b, c
|.endmacro
|
|.macro shruxi, a, b, c
|  B_X
|    B_fnop_x0
|    B_shruxi_x1 a, b, c
|.endmacro
|
|.macro shrs, a, b, c
|  B_X
|    B_fnop_x0
|    B_shrs_x1 a, b, c
|.endmacro
|
|.macro shrsi, a, b, c
|  B_X
|    B_fnop_x0
|    B_shrsi_x1 a, b, c
|.endmacro
|
|.macro bfextu, a, b, c, d
|  B_X
|    B_bfextu_x0 a, b, c, d
|    B_fnop_x1
|.endmacro
|
|.macro bfexts, a, b, c, d
|  B_X
|    B_bfexts_x0 a, b, c, d
|    B_fnop_x1
|.endmacro
|
|.macro bfins, a, b, c, d
|  B_X
|    B_bfins_x0 a, b, c, d
|    B_fnop_x1
|.endmacro
|
|.macro cmovnez, a, b, c
|  B_X
|    B_cmovnez_x0 a, b, c
|    B_fnop_x1
|.endmacro
|
|.macro cmoveqz, a, b, c
|  B_X
|    B_cmoveqz_x0 a, b, c
|    B_fnop_x1
|.endmacro
|
|.macro revbytes, a, b
|  B_X
|    B_revbytes_x0 a, b
|    B_fnop_x1
|.endmacro
|
|.macro st, a, b
|  B_X
|    B_fnop_x0
|    B_st_x1 a, b
|.endmacro
|
|.macro st_add, a, b, c
|  B_X
|    B_fnop_x0
|    B_st_add_x1 a, b, c
|.endmacro
|
|.macro st4, a, b
|  B_X
|    B_fnop_x0
|    B_st4_x1 a, b
|.endmacro
|
|.macro st2, a, b
|  B_X
|    B_fnop_x0
|    B_st2_x1 a, b
|.endmacro
|
|.macro st1, a, b
|  B_X
|    B_fnop_x0
|    B_st1_x1 a, b
|.endmacro
|
|.macro ld, a, b
|  B_X
|    B_fnop_x0
|    B_ld_x1 a, b
|.endmacro
|
|.macro ld_add, a, b, c
|  B_X
|    B_fnop_x0
|    B_ld_add_x1 a, b, c
|.endmacro
|
|.macro ld4u_add, a, b, c
|  B_X
|    B_fnop_x0
|    B_ld4u_add_x1 a, b, c
|.endmacro
|
|.macro ld4s_add, a, b, c
|  B_X
|    B_fnop_x0
|    B_ld4s_add_x1 a, b, c
|.endmacro
|
|.macro ld4u, a, b
|  B_X
|    B_fnop_x0
|    B_ld4u_x1 a, b
|.endmacro
|
|.macro ld2u, a, b
|  B_X
|    B_fnop_x0
|    B_ld2u_x1 a, b
|.endmacro
|
|.macro ld1u, a, b
|  B_X
|    B_fnop_x0
|    B_ld1u_x1 a, b
|.endmacro
|
|.macro ld1s, a, b
|  B_X
|    B_fnop_x0
|    B_ld1s_x1 a, b
|.endmacro
|
|.macro ld2s, a, b
|  B_X
|    B_fnop_x0
|    B_ld2s_x1 a, b
|.endmacro
|
|.macro ld4s, a, b
|  B_X
|    B_fnop_x0
|    B_ld4s_x1 a, b
|.endmacro
|
|.macro jr, a
|  B_X
|    B_fnop_x0
|    B_jr_x1 a
|.endmacro
|
|.macro jrp, a
|  B_X
|    B_fnop_x0
|    B_jrp_x1 a
|.endmacro
|
|.macro jal, a
|  B_X
|    B_fnop_x0
|    B_jal_x1 a
|.endmacro
|
|.macro j, a
|  B_X
|    B_fnop_x0
|    B_j_x1 a
|.endmacro
|
|.macro jalr, a
|  B_X
|    B_fnop_x0
|    B_jalr_x1 a
|.endmacro
|
|.macro beqz, a, b
|  B_X
|    B_fnop_x0
|    B_beqz_x1 a, b
|.endmacro
|
|.macro beqzt, a, b
|  B_X
|    B_fnop_x0
|    B_beqzt_x1 a, b
|.endmacro
|
|.macro bnez, a, b
|  B_X
|    B_fnop_x0
|    B_bnez_x1 a, b
|.endmacro
|
|.macro bnezt, a, b
|  B_X
|    B_fnop_x0
|    B_bnezt_x1 a, b
|.endmacro
|
|.macro bltz, a, b
|  B_X
|    B_fnop_x0
|    B_bltz_x1 a, b
|.endmacro
|
|.macro blez, a, b
|  B_X
|    B_fnop_x0
|    B_blez_x1 a, b
|.endmacro
|
|.macro bgtz, a, b
|  B_X
|    B_fnop_x0
|    B_bgtz_x1 a, b
|.endmacro
|
|.macro bgez, a, b
|  B_X
|    B_fnop_x0
|    B_bgez_x1 a, b
|.endmacro
|
|.macro b, a
|  B_X
|    B_fnop_x0
|    B_b_x1 a
|.endmacro
|
|.macro lnk, a
|  B_X
|    B_fnop_x0
|    B_lnk_x1 a
|.endmacro
|
|.macro cmpeq, a, b, c
|  B_X
|    B_fnop_x0
|    B_cmpeq_x1 a, b, c
|.endmacro
|
|.macro cmpne, a, b, c
|  B_X
|    B_fnop_x0
|    B_cmpne_x1 a, b, c
|.endmacro
|
|.macro cmples, a, b, c
|  B_X
|    B_fnop_x0
|    B_cmples_x1 a, b, c
|.endmacro
|
|.macro cmplts, a, b, c
|  B_X
|    B_fnop_x0
|    B_cmplts_x1 a, b, c
|.endmacro
|
|.macro cmpltu, a, b, c
|  B_X
|    B_fnop_x0
|    B_cmpltu_x1 a, b, c
|.endmacro
|
|.macro cmpleu, a, b, c
|  B_X
|    B_fnop_x0
|    B_cmpleu_x1 a, b, c
|.endmacro
|
|.macro cmpeqi, a, b, c
|  B_X
|    B_fnop_x0
|    B_cmpeqi_x1 a, b, c
|.endmacro
|
|.macro cmpltsi, a, b, c
|  B_X
|    B_fnop_x0
|    B_cmpltsi_x1 a, b, c
|.endmacro
|
|.macro cmpltui, a, b, c
|  B_X
|    B_fnop_x0
|    B_cmpltui_x1 a, b, c
|.endmacro
|
|.macro mul_hu_lu, a, b, c
|  B_X
|    B_mul_hu_lu_x0 a, b, c
|    B_fnop_x1
|.endmacro
|
|.macro mul_lu_lu, a, b, c
|  B_X
|    B_mul_lu_lu_x0 a, b, c
|    B_fnop_x1
|.endmacro
|
|.macro mul_hu_hu, a, b, c
|  B_X
|    B_mul_hu_hu_x0 a, b, c
|    B_fnop_x1
|.endmacro
|
|.macro mula_hu_lu, a, b, c
|  B_X
|    B_mula_hu_lu_x0 a, b, c
|    B_fnop_x1
|.endmacro
|
|.macro fdouble_pack1, a, b, c
|  B_X
|    B_fdouble_pack1_x0 a, b, c
|    B_fnop_x1
|.endmacro
|
|.macro fdouble_pack2, a, b, c
|  B_X
|    B_fdouble_pack2_x0 a, b, c
|    B_fnop_x1
|.endmacro
|
|.macro fdouble_add_flags, a, b, c
|  B_X
|    B_fdouble_add_flags_x0 a, b, c
|    B_fnop_x1
|.endmacro
|
|.macro fdouble_sub_flags, a, b, c
|  B_X
|    B_fdouble_sub_flags_x0 a, b, c
|    B_fnop_x1
|.endmacro
|
|.macro fdouble_mul_flags, a, b, c
|  B_X
|    B_fdouble_mul_flags_x0 a, b, c
|    B_fnop_x1
|.endmacro
|
|.macro fdouble_addsub, a, b, c
|  B_X
|    B_fdouble_addsub_x0 a, b, c
|    B_fnop_x1
|.endmacro
|
|.macro fdouble_unpack_min, a, b, c
|  B_X
|    B_fdouble_unpack_min_x0 a, b, c
|    B_fnop_x1
|.endmacro
|
|.macro fdouble_unpack_max, a, b, c
|  B_X
|    B_fdouble_unpack_max_x0 a, b, c
|    B_fnop_x1
|.endmacro
|
|.macro saveregs
|  addi sp, sp, -40 // 8 + 32
|  st_add sp, r30, -8
|  st_add sp, r31, -8
|  st_add sp, r32, -8
|  st_add sp, r33, -8
|  st_add sp, r34, -8
|  st_add sp, r35, -8
|  st_add sp, r36, -8
|  st_add sp, r37, -8
|  st_add sp, r38, -8
|  st_add sp, r39, -8
|  st_add sp, r45, -8
|  st_add sp, r51, -8
|  st_add sp, r52, -8
|  st_add sp, lr, -TILE_ABI_RESERV
|.endmacro
|
|.macro restoreregs_ret
|  addi sp, sp, TILE_ABI_RESERV
|  ld_add lr, sp, 8
|  ld_add r52, sp, 8
|  ld_add r51, sp, 8
|  ld_add r45, sp, 8
|  ld_add r39, sp, 8
|  ld_add r38, sp, 8
|  ld_add r37, sp, 8
|  ld_add r36, sp, 8
|  ld_add r35, sp, 8
|  ld_add r34, sp, 8
|  ld_add r33, sp, 8
|  ld_add r32, sp, 8
|  ld_add r31, sp, 8
|  ld_add r30, sp, 40
|  jr lr
|.endmacro
|
|// Type definitions. Some of these are only used for documentation.
|.type L,		lua_State,	LREG
|.type GL,		global_State
|.type TVALUE,		TValue
|.type GCOBJ,		GCobj
|.type STR,		GCstr
|.type TAB,		GCtab
|.type LFUNC,		GCfuncL
|.type CFUNC,		GCfuncC
|.type PROTO,		GCproto
|.type UPVAL,		GCupval
|.type NODE,		Node
|.type NARGS8,		int
|.type TRACE,		GCtrace
|
|//-----------------------------------------------------------------------
|
|// Trap for not-yet-implemented parts.
|.macro NYI; .long 0xf0f0f0f0; .endmacro
|
|//-----------------------------------------------------------------------
|
|.define FRAME_PC,	-4
|.define FRAME_FUNC,	-8
|.define LO,		0
|.define HI,		4
|.define OFS_OP,	0
|.define OFS_RA,	1
|.define OFS_RD,	2
|
|// Instruction decode.
|.macro decode_OP1, dst, ins; bfextu dst, ins, 0, 7; .endmacro
|.macro decode_OP4a, dst, ins; bfextu dst, ins, 0, 7; .endmacro
|.macro decode_OP4b, dst; shli dst, dst, 3; .endmacro
|.macro decode_RC4a, dst, ins; shrui dst, ins, 14; .endmacro
|.macro decode_RC4b, dst; bfextu dst, dst, 2, 9; shli dst, dst, 2; .endmacro
|.macro decode_RD4b, dst; shli dst, dst, 2; .endmacro
|.macro decode_RA8a, dst, ins; shrui dst, ins, 5; .endmacro
|.macro decode_RA8b, dst; bfextu dst, dst, 3, 10; shli dst, dst, 3; .endmacro
|.macro decode_RB8a, dst, ins; shrui dst, ins, 21; .endmacro
|.macro decode_RB8b, dst; bfextu dst, dst, 3, 10; shli dst, dst, 3; .endmacro
|.macro decode_RD8a, dst, ins; shrui dst, ins, 16; .endmacro
|.macro decode_RD8b, dst; shli dst, dst, 3; .endmacro
|.macro decode_RDtoRC8, dst, src; bfextu dst, src, 3, 10; shli dst, dst, 3; .endmacro
|
|// Instruction fetch.
|.macro ins_NEXT1
|  ld4u_add INS, PC, 4
|.endmacro
|
|// Instruction decode+dispatch.
|.macro ins_NEXT2
|  decode_OP4a TMP1, INS
|  decode_OP4b TMP1
|  B_X
|    B_add_x0 TMP0, DISPATCH, TMP1
|    B_shrui_x1 RD, INS, 16
|  B_X
|    B_shrui_x0, RA, INS, 5
|    B_ld_x1, AT, TMP0
|  B_X
|    B_bfextu_x0, RA, RA, 3, 10
|    B_shli_x1, RD, RD, 3
|  B_X
|    B_shli_x0, RA, RA, 3
|    B_jr_x1, AT
|.endmacro
|.macro ins_NEXT
|  ins_NEXT1
|  ins_NEXT2
|.endmacro
|
|// Instruction footer.
|.if 1
|  // Replicated dispatch. Less unpredictable branches, but higher I-Cache use.
|  .define ins_next, ins_NEXT
|  .define ins_next_, ins_NEXT
|  .define ins_next1, ins_NEXT1
|  .define ins_next2, ins_NEXT2
|.else
|  // Common dispatch. Lower I-Cache use, only one (very) unpredictable branch.
|  // Affects only certain kinds of benchmarks (and only with -j off).
|  .macro ins_next
|    b ->ins_next
|  .endmacro
|  .macro ins_next1
|  .endmacro
|  .macro ins_next2
|    b ->ins_next
|  .endmacro
|  .macro ins_next_
|  ->ins_next:
|    ins_NEXT
|  .endmacro
|.endif
|
|// Call decode and dispatch.
|.macro ins_callt
|  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
|  addlo PC, LFUNC:RB->pc
|  ld4u PC, PC
|  ld4u_add INS, PC, 4
|  B_X
|    B_bfextu_x0 TMP1, INS, 0, 7
|    B_shrui_x1 RA, INS, 5
|  B_X
|    B_bfextu_x0 RA, RA, 3, 10
|    B_shli_x1 TMP1, TMP1, 3
|  B_X
|    B_shli_x0 RA, RA, 3
|    B_add_x1 TMP0, DISPATCH, TMP1
|  B_X
|    B_add_x0 RA, RA, BASE
|    B_ld_x1 TMP0, TMP0
|  jr TMP0
|.endmacro
|
|.macro ins_call
|  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, PC = caller PC
|  addi AT, BASE, FRAME_PC
|  B_X
|    B_addlo_x0 AT2, LFUNC:RB->pc
|    B_st4_x1 AT, PC
|  ld4u PC, AT2
|  ld4u_add INS, PC, 4
|  B_X
|    B_bfextu_x0 TMP1, INS, 0, 7
|    B_shrui_x1 RA, INS, 5
|  B_X
|    B_bfextu_x0 RA, RA, 3, 10
|    B_shli_x1 TMP1, TMP1, 3
|  B_X
|    B_shli_x0 RA, RA, 3
|    B_add_x1 TMP0, DISPATCH, TMP1
|  B_X
|    B_add_x0 RA, RA, BASE
|    B_ld_x1 TMP0, TMP0
|  jr TMP0
|.endmacro
|
|//-----------------------------------------------------------------------
|
|.macro branch_RD
|  B_X
|    B_shrui_x0 TMP0, RD, 1
|    B_moveli_x1 AT, (-(BCBIAS_J*4 >> 16) & 65535)
|  shl16insli AT, AT, 0
|  add TMP0, TMP0, AT
|  add PC, PC, TMP0
|.endmacro
|
|// Assumes DISPATCH is relative to GL.
#define DISPATCH_GL(field)	(GG_DISP2G + (int)offsetof(global_State, field))
#define DISPATCH_J(field)	(GG_DISP2J + (int)offsetof(jit_State, field))
#define GG_DISP2GOT		(GG_OFS(got) - GG_OFS(dispatch))
#define DISPATCH_GOT(name)	(GG_DISP2GOT + 8*LJ_GOT_##name)
|
#define PC2PROTO(field)  ((int)offsetof(GCproto, field)-(int)sizeof(GCproto))
|
|.macro load_got, func
|  addli CFUNCADDR, DISPATCH, DISPATCH_GOT(func)
|  ld CFUNCADDR, CFUNCADDR
|.endmacro
|// Much faster. Sadly, there's no easy way to force the required code layout.
|// .macro call_intern, func; bal extern func; .endmacro
|.macro call_intern, func; jalr CFUNCADDR; .endmacro
|.macro call_extern; jalr CFUNCADDR; .endmacro
|.macro jmp_extern; jr CFUNCADDR; .endmacro
|
|.macro hotcheck, delta, target
|  shrui TMP1, PC, 1
|  andi TMP1, TMP1, 126
|  add TMP1, TMP1, DISPATCH
|  addi TMP2, TMP1, GG_DISP2HOT
|  ld2u TMP2, TMP2
|  addli TMP2, TMP2, -delta
|  addi AT, TMP1, GG_DISP2HOT
|  st2 AT, TMP2
|  bltz TMP2, target
|.endmacro
|
|.macro hotloop
|  hotcheck HOTCOUNT_LOOP, ->vm_hotloop
|.endmacro
|
|.macro hotcall
|  hotcheck HOTCOUNT_CALL, ->vm_hotcall
|.endmacro
|
|// Set current VM state. Uses TMP0.
|.macro li_vmstate, st; moveli TMP0, ~LJ_VMST_..st; .endmacro
|.macro st_vmstate; addli AT, DISPATCH, DISPATCH_GL(vmstate); st4 AT, TMP0; .endmacro
|
|// Move table write barrier back. Overwrites mark and tmp.
|.macro barrierback, tab, mark, tmp, target
|  addli tmp, DISPATCH, DISPATCH_GL(gc.grayagain)
|  B_X
|    B_andi_x0 mark, mark, ~LJ_GC_BLACK & 255
|    B_ld4u_x1 tmp, tmp
|  addli AT, DISPATCH, DISPATCH_GL(gc.grayagain)
|  B_X
|    B_addlo_x0 AT2, tab->marked
|    B_st4_x1 AT, tab
|  B_X
|    B_addlo_x0 AT, tab->gclist
|    B_st1_x1 AT2, mark
|  st4 AT, tmp
|  b target
|.endmacro
|
|.macro fixsidf_inline, R0, R1, R2, R3
|  B_X
|    B_cmpltsi_x0 R3, R0, 0
|    B_sub_x1 R2, zero, R0
|  B_X
|    B_cmovnez_x0 R0, R3, R2
|    B_moveli_x1 R1, 539
|  B_X
|    B_shli_x0 R1, R1, 8
|    B_shli_x1 R2, R0, 4
|  bfins R1, R3, 20, 20
|  fdouble_pack1 R0, R2, R1
|  fdouble_pack2 R0, R2, zero
|.endmacro
|
|.macro fixdfsi_inline, R0, R1, R2, R3, R4
|  B_X
|    B_bfextu_x0 R1, R0, 52, 62
|    B_moveli_x1 R4, 1054
|  B_X
|    B_cmples_x0 R3, R1, R4
|    B_shrui_x1 R2, R0, 63
|  B_X
|    B_bfextu_x0 R4, R0, 0, 51
|    B_bnezt_x1 R3, >3
|  B_X
|    B_moveli_x0 R0, 2047
|    B_cmpne_x1 R4, R4, zero
|  cmpeq R1, R1, R0
|  and R1, R1, R4
|  beqzt R1, >4
|1:
|  moveli R0, 32767
|  shl16insli R0, R0, -1
|2:
|  b >5
|3:
|  moveli R0, 1022
|  B_X
|    B_cmples_x0 R3, R1, R0
|    B_movei_x1 R0, 0
|  bnez R3, <2
|  B_X
|    B_movei_x0 R0, 1
|    B_moveli_x1 R3, 1075
|  B_X
|    B_shli_x0 R0, R0, 52
|    B_subx_x1 R1, R3, R1
|  or R0, R4, R0
|  shru R0, R0, R1
|  B_X
|    B_addxi_x0 R0, R0, 0
|    B_subx_x1 R1, zero, R0
|  cmovnez R0, R2, R1
|  shruxi R1, R0, 31
|  cmpeq R1, R1, R2
|  bnez R1, <2
|4:
|  movei R0, -1
|  B_X
|    B_shli_x0 R0, R0, 31
|    B_beqz_x1 R2, <1
|5:
|.endmacro
|//-----------------------------------------------------------------------

/* Generate subroutines used by opcodes and other parts of the VM. */
/* The .code_sub section should be last to help static branch prediction. */
static void build_subroutines(BuildCtx *ctx)
{
  |.code_sub
  |
  |//-----------------------------------------------------------------------
  |//-- Return handling ----------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_returnp:
  |  // See vm_return. Also: TMP2 = previous base.
  |  B_X
  |    B_andi_x0 AT, PC, FRAME_P
  |    B_lnk_x1 ASMENTRY
  |  B_X
  |    B_addi_x0 TMP1, zero, LJ_TTRUE
  |    B_beqz_x1 AT, ->cont_dispatch
  |
  |  // Return from pcall or xpcall fast func.
  |  addi PC, TMP2, FRAME_PC
  |  B_Y2
  |    B_move_y0 BASE, TMP2			// Restore caller base.
  |    // Prepending may overwrite the pcall frame, so do it at the end.
  |    B_addi_y1 AT, RA, FRAME_PC
  |    B_ld4s_y2 PC, PC
  |  B_X
  |    B_addli_x0 RA, RA, -8
  |    B_st4_x1 AT, TMP1
  |
  |->vm_returnc:
  |  B_X
  |    B_addli_x0 RD, RD, 8			// RD = (nresults+1)*8.
  |    B_andi_x1 TMP0, PC, FRAME_TYPE
  |  B_X
  |    B_addi_x0 CRET1, zero, 1 //LUA_YIELD
  |    B_beqz_x1 RD, ->vm_unwind_c_eh
  |  B_X
  |    B_move_x0 MULTRES, RD
  |    B_beqz_x1 TMP0, ->BC_RET_Z		// Handle regular return to Lua.
  |
  |->vm_return:
  |  // BASE = base, RA = resultptr, RD/MULTRES = (nresults+1)*8, PC = return
  |  // TMP0 = PC & FRAME_TYPE
  |  B_X
  |    B_addi_x0 TMP2, zero, -8
  |    B_xori_x1 AT, TMP0, FRAME_C
  |  and TMP2, PC, TMP2
  |  B_X
  |    B_sub_x0 TMP2, BASE, TMP2		// TMP2 = previous base.
  |    B_bnez_x1 AT, ->vm_returnp
  |
  |  B_X
  |    B_addli_x0 TMP1, RD, -8
  |    B_addlo_x1 AT, L:LREG->base
  |  B_X
  |    //li_vmstate C
  |    B_moveli_x0 TMP0, ~LJ_VMST_C
  |    B_st_x1 AT, TMP2
  |  addli TMP2, sp, SAVE_NRES
  |  B_X
  |    B_addli_x0 BASE, BASE, -8
  |    B_ld_x1 TMP2, TMP2
  |  st_vmstate
  |  B_X
  |    B_shli_x0 TMP2, TMP2, 3
  |    B_beqz_x1 TMP1, >2
  |1:
  |  B_X
  |    B_addli_x0 TMP1, TMP1, -8
  |    B_ld_x1 AT, RA
  |  B_X
  |    B_addli_x0 RA, RA, 8
  |    B_st_x1 BASE, AT
  |  B_X
  |    B_addli_x0 BASE, BASE, 8
  |    B_bnez_x1 TMP1, <1
  |
  |2:
  |  B_X
  |    B_cmpne_x0 AT, TMP2, RD
  |    B_addlo_x1 AT1, L:LREG->top
  |  st AT1, BASE
  |  bnez AT, >6
  |
  |->vm_leave_cp:
  |  B_X
  |    B_addli_x0 TMP0, sp, SAVE_CFRAME
  |    B_addlo_x1 AT, L:LREG->cframe
  |  B_X
  |    B_move_x0 CRET1, zero		// Ok return status for vm_pcall.
  |    B_ld_x1 TMP0, TMP0		// Restore previous C frame.
  |  st AT, TMP0
  |
  |->vm_leave_unw:
  |  restoreregs_ret
  |
  |6:
  |  addlo TMP1, L:LREG->maxstack
  |  B_X
  |    B_cmplts_x0 AT, TMP2, RD
  |    B_ld4u_x1 TMP1, TMP1
  |  // More results wanted. Check stack size and fill up results with nil.
  |  B_X
  |    B_cmplts_x0 AT1, BASE, TMP1
  |    B_bnez_x1 AT, >7			// Less results wanted?
  |  beqz AT1, >8
  |  B_X
  |    B_addi_x0 RD, RD, 8
  |    B_st_add_x1 BASE, TISNIL, 8
  |  b <2
  |
  |7:  // Less results wanted.
  |  B_X
  |    B_addlo_x0 AT, L:LREG->top
  |    B_sub_x1 TMP0, RD, TMP2
  |  sub TMP0, BASE, TMP0		// Either keep top or shrink it.
  |  cmovnez BASE, TMP2, TMP0		// LUA_MULTRET+1 case?
  |  st AT, BASE
  |  b ->vm_leave_cp
  |
  |8:  // Corner case: need to grow stack for filling up results.
  |  // This can happen if:
  |  // - A C function grows the stack (a lot).
  |  // - The GC shrinks the stack in between.
  |  // - A return back from a lua_call() with (high) nresults adjustment.
  |
  |  //load_got lj_state_growstack
  |  B_X
  |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_state_growstack)
  |    B_move_x1 MULTRES, RD
  |  B_X
  |    B_move_x0 CARG2, TMP2
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  B_X
  |    B_move_x0 CARG1, L
  |    //call_intern lj_state_growstack	// (lua_State *L, int n)
  |    B_jalr_x1 CFUNCADDR
  |  addli TMP2, sp, SAVE_NRES
  |  B_X
  |    B_addlo_x0 BASE, L:LREG->top			// Need the (realloced) L->top in BASE.
  |    B_ld_x1 TMP2, TMP2
  |  B_Y2
  |    B_move_y0 RD, MULTRES
  |    B_shli_y1 TMP2, TMP2, 3
  |    B_ld_y2 BASE, BASE
  |  b <2
  |
  |->vm_unwind_c:			// Unwind C stack, return from vm_pcall.
  |  // (void *cframe, int errcode)
  |  B_X
  |    B_move_x0 sp, CARG1
  |    B_move_x1 CRET1, CARG2
  |->vm_unwind_c_eh:			// Landing pad for external unwinder.
  |  addli L, sp, SAVE_L
  |  B_X
  |    B_addi_x0 TMP0, zero, ~LJ_VMST_C
  |    B_ld_x1 L, L
  |  addlo GL:TMP1, L:LREG->glref
  |  ld4u GL:TMP1, GL:TMP1
  |  addlo AT, GL:TMP1->vmstate
  |  st4 AT, TMP0
  |  b ->vm_leave_unw
  |
  |->vm_unwind_ff:			// Unwind C stack, return from ff pcall.
  |  // (void *cframe)
  |  addi AT, zero, -4
  |  and sp, CARG1, AT
  |->vm_unwind_ff_eh:			// Landing pad for external unwinder.
  |  B_X
  |    B_addli_x0 L, sp, SAVE_L
  |    B_moveli_x1 TOBIT, 14403
  |  B_Y2
  |    B_addi_y0 TISNIL, zero, -1 // LJ_TNIL
  |    B_movei_y1 TISNUM, -2 // LJ_TISNUM high 16bit
  |    B_ld_y2 L, L
  |  B_X
  |    B_revbytes_x0 TOBIT, TOBIT
  |    B_addlo_x1 BASE, L:LREG->base
  |  B_X
  |    B_addlo_x0 DISPATCH, L:LREG->glref		// Setup pointer to dispatch table.
  |    B_ld_x1 BASE, BASE
  |  B_X
  |    B_addi_x0 TMP1, zero, LJ_TFALSE
  |    B_ld4u_x1 DISPATCH, DISPATCH
  |  B_X
  |    //li_vmstate INTERP
  |    B_moveli_x0 TMP0, ~LJ_VMST_INTERP
  |    B_addi_x1 PC, BASE, FRAME_PC
  |  B_X
  |    B_addli_x0 RA, BASE, -8			// Results start at BASE-8.
  |    B_ld4s_x1 PC, PC
  |  B_X
  |    B_addli_x0 DISPATCH, DISPATCH, GG_G2DISP
  |    B_addi_x1 AT, RA, HI
  |  B_X
  |    //st_vmstate
  |    B_addli_x0 AT1, DISPATCH, DISPATCH_GL(vmstate)
  |    B_st4_x1 AT, TMP1
  |  B_X
  |    B_shl16insli_x0 TISNUM, TISNUM, -1
  |    B_st4_x1 AT1, TMP0
  |  B_X
  |    B_addi_x0 RD, zero, 16				// 2 results: false + error message.
  |    B_b_x1 ->vm_returnc
  |
  |//-----------------------------------------------------------------------
  |//-- Grow stack for calls -----------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_growstack_c:			// Grow stack for C function.
  |  B_X
  |    B_addi_x0 CARG2, zero, LUA_MINSTACK
  |    B_b_x1 >2
  |
  |->vm_growstack_l:			// Grow stack for Lua function.
  |  // BASE = new base, RA = BASE+framesize*8, RC = nargs*8, PC = first PC
  |  B_X
  |    B_add_x0 RC, BASE, RC
  |    B_sub_x1 RA, RA, BASE
  |  B_X
  |    B_addlo_x0 AT, L:LREG->base
  |    B_addli_x1 PC, PC, 4			// Must point after first instruction.
  |  B_X
  |    B_addlo_x0 AT1, L:LREG->top
  |    B_st_x1 AT, BASE
  |  B_X
  |    B_shrui_x0 CARG2, RA, 3
  |    B_st_x1 AT1, RC
  |2:
  |  // L->base = new base, L->top = top
  |  //load_got lj_state_growstack
  |  B_X
  |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_state_growstack)
  |    B_addi_x1 AT, sp, SAVE_PC
  |  B_X
  |    B_move_x0 CARG1, L
  |    B_st_x1 AT, PC
  |  ld CFUNCADDR, CFUNCADDR
  |  call_intern lj_state_growstack	// (lua_State *L, int n)
  |  addlo BASE, L:LREG->base
  |  B_X
  |    B_addlo_x0 RC, L:LREG->top
  |    B_ld_x1 BASE, BASE
  |  B_X
  |    B_addi_x0 LFUNC:RB, BASE, FRAME_FUNC
  |    B_ld_x1 RC, RC
  |  B_X
  |    B_sub_x0 RC, RC, BASE
  |    B_ld4s_x1 LFUNC:RB, LFUNC:RB
  |  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
  |  ins_callt				// Just retry the call.
  |
  |//-----------------------------------------------------------------------
  |//-- Entry points into the assembler VM ---------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_resume:				// Setup C frame and resume thread.
  |  // (lua_State *L, TValue *base, int nres1 = 0, ptrdiff_t ef = 0)
  |  //saveregs
  |  addi sp, sp, -40 // 8 + 32
  |  st_add sp, r30, -8
  |  st_add sp, r31, -8
  |  st_add sp, r32, -8
  |  st_add sp, r33, -8
  |  st_add sp, r34, -8
  |  st_add sp, r35, -8
  |  st_add sp, r36, -8
  |  st_add sp, r37, -8
  |  st_add sp, r38, -8
  |  st_add sp, r39, -8
  |  st_add sp, r45, -8
  |  st_add sp, r51, -8
  |  st_add sp, r52, -8
  |  B_X
  |    B_move_x0 L, CARG1
  |    B_st_add_x1 sp, lr, -TILE_ABI_RESERV
  |  B_X
  |    B_addlo_x0 DISPATCH, L:LREG->glref	// Setup pointer to dispatch table.
  |    B_move_x1 BASE, CARG2
  |  B_X
  |    B_addlo_x0 TMP1, L:LREG->status
  |    B_ld4u_x1 DISPATCH, DISPATCH
  |  B_X
  |    B_addli_x0 AT, sp, SAVE_L
  |    B_ld1u_x1 TMP1, TMP1
  |  B_Y3
  |    B_addi_y0 PC, zero, 5 // FRAME_CP
  |    B_addi_y1 TMP0, sp, 1 //CFRAME_RESUME
  |    B_st_y2 AT, L
  |  B_X
  |    B_addli_x0 DISPATCH, DISPATCH, GG_G2DISP
  |    B_addli_x1 AT, sp, SAVE_NRES
  |  B_X
  |    B_addli_x0 AT1, sp, SAVE_ERRF
  |    B_st_x1 AT, zero
  |  B_X
  |    B_addlo_x0 AT, L:LREG->cframe
  |    B_st_x1 AT1, zero
  |  B_X
  |    B_addli_x0 AT1, sp, SAVE_CFRAME
  |    B_st_x1 AT, TMP0
  |  B_X
  |    B_addi_x0 AT, sp, SAVE_PC
  |    B_st_x1 AT1, zero
  |  st AT, CARG1
  |  beqz TMP1, >3
  |
  |  // Resume after yield (like a return).
  |  B_X
  |    B_move_x0 RA, BASE
  |    B_addlo_x1 BASE, L:LREG->base
  |  B_X
  |    B_addlo_x0 TMP1, L:LREG->top
  |    B_ld_x1 BASE, BASE
  |  B_Y2
  |    B_addi_y0 PC, BASE, FRAME_PC
  |    B_movei_y1 TISNUM, -2 // LJ_TISNUM high 16bit
  |    B_ld_y2 TMP1, TMP1
  |  B_X
  |    B_sub_x0 RD, TMP1, BASE
  |    B_ld4s_x1 PC, PC
  |  B_X
  |    B_addlo_x0 AT, L:LREG->status
  |    B_moveli_x1 TOBIT, 14403
  |  B_X
  |    B_shl16insli_x0 TISNUM, TISNUM, -1
  |    B_st1_x1 AT, zero
  |  B_X
  |    B_addli_x0 RD, RD, 8
  |    //st_vmstate
  |    B_addli_x1 AT, DISPATCH, DISPATCH_GL(vmstate)
  |  B_Y3
  |    B_move_y0 MULTRES, RD
  |    B_movei_y1 TMP0, -1 // ~LJ_VMST_INTERP
  |    B_st4_y2 AT, TMP0
  |  B_X
  |    B_andi_x0 TMP0, PC, FRAME_TYPE
  |    B_addi_x1 TISNIL, zero, LJ_TNIL
  |  B_X
  |    B_revbytes_x0 TOBIT, TOBIT
  |    B_beqz_x1 TMP0, ->BC_RET_Z
  |  b ->vm_return
  |
  |->vm_pcall:				// Setup protected C frame and enter VM.
  |  // (lua_State *L, TValue *base, int nres1, ptrdiff_t ef)
  |  saveregs
  |  addli AT, sp, SAVE_ERRF
  |  B_X
  |    B_addi_x0 PC, zero, FRAME_CP
  |    B_st_x1 AT, CARG4
  |  b >1
  |
  |->vm_call:				// Setup C frame and enter VM.
  |  // (lua_State *L, TValue *base, int nres1)
  |  // saveregs
  |  addi sp, sp, -40 // 8 + 32
  |  st_add sp, r30, -8
  |  st_add sp, r31, -8
  |  st_add sp, r32, -8
  |  st_add sp, r33, -8
  |  st_add sp, r34, -8
  |  st_add sp, r35, -8
  |  st_add sp, r36, -8
  |  st_add sp, r37, -8
  |  st_add sp, r38, -8
  |  st_add sp, r39, -8
  |  st_add sp, r45, -8
  |  st_add sp, r51, -8
  |  st_add sp, r52, -8
  |  B_X
  |    B_addi_x0 PC, zero, FRAME_C
  |    B_st_add_x1 sp, lr, -TILE_ABI_RESERV
  |
  |1:  // Entry point for vm_pcall above (PC = ftype).
  |  addlo TMP1, L:CARG1->cframe
  |  B_X
  |    B_addli_x0 AT, sp, SAVE_NRES
  |    B_ld_x1 TMP1, TMP1
  |  B_X
  |    B_move_x0 L, CARG1
  |    B_st_x1 AT, CARG3
  |  B_X
  |    B_addli_x0 AT, sp, SAVE_L
  |    B_move_x1 BASE, CARG2
  |  B_X
  |    B_addlo_x0 AT1, L:LREG->cframe			// Add our C frame to cframe chain.
  |    B_st_x1 AT, CARG1
  |  B_X
  |    B_addlo_x0 DISPATCH, L:LREG->glref		// Setup pointer to dispatch table.
  |    B_st_x1 AT1, sp
  |  B_X
  |    B_addi_x0 AT, sp, SAVE_PC
  |    B_ld4u_x1 DISPATCH, DISPATCH
  |  B_X
  |    B_addli_x0 AT1, sp, SAVE_CFRAME
  |    B_st_x1 AT, CARG1
  |  B_X
  |    B_addli_x0 DISPATCH, DISPATCH, GG_G2DISP
  |    B_st_x1 AT1, TMP1
  |
  |3:  // Entry point for vm_cpcall/vm_resume (BASE = base, PC = ftype).
  |  B_X
  |    B_addlo_x0 TMP2, L:LREG->base		
  |    B_moveli_x1 TOBIT, 14403
  |  B_X
  |    B_addlo_x0 TMP1, L:LREG->top		
  |    B_ld_x1 TMP2, TMP2			// TMP2 = old base (used in vmeta_call).
  |  B_Y2
  |    B_add_y0 PC, PC, BASE
  |    B_movei_y1 TISNUM, -2
  |    B_ld_y2 TMP1, TMP1
  |  B_X
  |    B_sub_x0 NARGS8:RC, TMP1, BASE
  |    B_sub_x1 PC, PC, TMP2			// PC = frame delta + frame type
  |  B_X
  |    //li_vmstate INTERP
  |    B_moveli_x0 TMP0, ~LJ_VMST_INTERP
  |    B_moveli_x1 TISNIL, LJ_TNIL
  |  B_X
  |    B_revbytes_x0 TOBIT, TOBIT
  |    //st_vmstate
  |    B_addli_x1 AT, DISPATCH, DISPATCH_GL(vmstate)
  |  B_X
  |    B_shl16insli_x0 TISNUM, TISNUM, -1
  |    B_st4_x1 AT, TMP0
  |
  |->vm_call_dispatch:
  |  // TMP2 = old base, BASE = new base, RC = nargs*8, PC = caller PC
  |  addi TMP0, BASE, FRAME_PC
  |  B_X
  |    B_moveli_x0 AT, LJ_TFUNC
  |    B_ld4s_x1 TMP0, TMP0
  |  B_X
  |    B_cmpne_x0 AT1, TMP0, AT
  |    B_addi_x1 LFUNC:RB, BASE, FRAME_FUNC
  |  ld4s LFUNC:RB, LFUNC:RB
  |  bnez AT1, ->vmeta_call
  |
  |->vm_call_dispatch_f:
  |  ins_call
  |  // BASE = new base, RB = func, RC = nargs*8, PC = caller PC
  |
  |->vm_cpcall:				// Setup protected C frame, call C.
  |  // (lua_State *L, lua_CFunction func, void *ud, lua_CPFunction cp)
  |  // saveregs
  |  addi sp, sp, -40 // 8 + 32
  |  st_add sp, r30, -8
  |  st_add sp, r31, -8
  |  st_add sp, r32, -8
  |  st_add sp, r33, -8
  |  st_add sp, r34, -8
  |  st_add sp, r35, -8
  |  st_add sp, r36, -8
  |  st_add sp, r37, -8
  |  st_add sp, r38, -8
  |  st_add sp, r39, -8
  |  st_add sp, r45, -8
  |  st_add sp, r51, -8
  |  st_add sp, r52, -8
  |  B_X
  |    B_move_x0 L, CARG1
  |    B_st_add_x1 sp, lr, -TILE_ABI_RESERV
  |  addlo TMP0, L:CARG1->stack
  |  B_X
  |    B_addli_x0 AT, sp, SAVE_L
  |    B_ld4u_x1 TMP0, TMP0
  |  B_X
  |    B_addlo_x0 TMP1, L:CARG1->top
  |    B_st_x1 AT, CARG1
  |  B_X
  |    B_addi_x0 AT, sp, SAVE_PC
  |    B_ld_x1 TMP1, TMP1
  |  B_X
  |    B_sub_x0 TMP0, TMP0, TMP1		// Compute -savestack(L, L->top).
  |    B_st_x1 AT, CARG1			// Any value outside of bytecode is ok.
  |  addlo AT, L:CARG1->cframe
  |  ld TMP1, AT
  |  B_X
  |    B_addli_x0 AT1, sp, SAVE_NRES		// Neg. delta means cframe w/o frame.
  |    B_st_x1 AT, sp			// Add our C frame to cframe chain.
  |  B_X
  |    B_addli_x0 AT, sp, SAVE_ERRF		// No error function.
  |    B_st_x1 AT1, TMP0
  |  B_X
  |    B_addli_x0 AT1, sp, SAVE_CFRAME
  |    B_st_x1 AT, r0
  |  st AT1, TMP1
  |  jalr CARG4			// (lua_State *L, lua_CFunction func, void *ud)
  |  B_X
  |    B_move_x0 BASE, CRET1
  |    B_addlo_x1 DISPATCH, L:LREG->glref	// Setup pointer to dispatch table.
  |  B_X
  |    B_addi_x0 PC, zero, FRAME_CP
  |    B_ld4u_x1 DISPATCH, DISPATCH
  |  B_X
  |    B_addli_x0 DISPATCH, DISPATCH, GG_G2DISP
  |    B_bnez_x1 CRET1, <3			// Else continue with the call.
  |  b ->vm_leave_cp			// No base? Just remove C frame.
  |
  |//-----------------------------------------------------------------------
  |//-- Metamethod handling ------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |// The lj_meta_* functions (except for lj_meta_cat) don't reallocate the
  |// stack, so BASE doesn't need to be reloaded across these calls.
  |
  |//-- Continuation dispatch ----------------------------------------------
  |
  |->cont_dispatch:
  |  // BASE = meta base, RA = resultptr, RD = (nresults+1)*8
  |  addi TMP0, BASE, -16+LO
  |  ld4s TMP0, TMP0
  |  add TMP0, TMP0, ASMENTRY
  |  B_X
  |    B_addi_x0 TMP0, TMP0, -8
  |    B_move_x1 RB, BASE
  |  B_X
  |    B_move_x0 BASE, TMP2			// Restore caller BASE.
  |    B_addi_x1 LFUNC:TMP1, TMP2, FRAME_FUNC
  |.if FFI
  |  B_X
  |    B_cmpltui_x0 AT, TMP0, 2
  |    B_ld4s_x1 LFUNC:TMP1, LFUNC:TMP1
  |  addi PC, RB, -16+HI
  |.else  
  |  B_X
  |    B_addi_x0 PC, RB, -16+HI
  |    B_ld4s_x1 LFUNC:TMP1, LFUNC:TMP1
  |.endif
  |  B_X
  |    B_add_x0 TMP2, RA, RD
  |    B_ld4s_x1 PC, PC
  |  addlo TMP1, LFUNC:TMP1->pc
  |  B_X
  |    B_addi_x0 AT1, TMP2, -8+HI
  |    B_ld4u_x1 TMP1, TMP1
  |  st4 AT1, TISNIL
  |.if FFI
  |  bnez AT, >1
  |.endif
  |  // BASE = base, RA = resultptr, RB = meta base
  |  addi KBASE, TMP1, PC2PROTO(k)
  |  ld4u KBASE, KBASE
  |  jr TMP0				// Jump to continuation.
  |
  |.if FFI
  |1:
  |  // cont = 0: tailcall from C function.
  |  B_X
  |    B_addli_x0 TMP1, RB, -16
  |    B_bnez_x1 TMP0, ->cont_ffi_callback	// cont = 1: return from FFI callback.
  |  B_X
  |    B_sub_x0 RC, TMP1, BASE
  |    B_b_x1 ->vm_call_tail
  |.endif
  |
  |->cont_cat:				// RA = resultptr, RB = meta base
  |  addi INS, PC, -4
  |  B_X
  |    B_addli_x0 CARG2, RB, -16
  |    B_ld4u_x1 INS, INS
  |  B_X
  |    B_shrui_x0 MULTRES, INS, 21
  |    B_ld_x1 AT, RA
  |  B_X
  |    B_bfextu_x0 MULTRES, MULTRES, 3, 10
  |    B_shrui_x1 RA, INS, 5
  |  B_X
  |    B_bfextu_x0 RA, RA, 3, 10
  |    B_shli_x1 MULTRES, MULTRES, 3
  |  B_X
  |    B_shli_x0 RA, RA, 3
  |    B_add_x1 TMP1, BASE, MULTRES
  |  B_X
  |    B_addlo_x0 AT1, L:LREG->base
  |    B_st_x1 CARG2, AT
  |  B_X
  |    B_sub_x0 CARG3, CARG2, TMP1
  |    B_st_x1 AT1, BASE
  |  cmpne AT1, TMP1, CARG2
  |  bnez AT1, ->BC_CAT_Z
  |  add RA, BASE, RA
  |  st RA, AT
  |  b ->cont_nop
  |
  |//-- Table indexing metamethods -----------------------------------------
  |
  |->vmeta_tgets1:
  |  B_X
  |    B_addli_x0 CARG3, DISPATCH, DISPATCH_GL(tmptv)
  |    B_addi_x1 TMP0, zero, LJ_TSTR
  |  B_X
  |    B_addi_x0 AT, CARG3, HI
  |    B_st4_x1 CARG3, STR:RC
  |  st4 AT, TMP0
  |  b >1
  |
  |->vmeta_tgets:
  |  B_X
  |    B_addli_x0 CARG2, DISPATCH, DISPATCH_GL(tmptv)
  |    B_addi_x1 TMP0, zero, LJ_TTAB
  |  B_X
  |    B_addli_x0 CARG3, DISPATCH, DISPATCH_GL(tmptv2)
  |    B_st4_x1 CARG2, TAB:RB
  |  B_X
  |    B_addi_x0 AT, CARG2, HI
  |    B_st4_x1 CARG3, STR:RC
  |  B_Y3
  |    B_addi_y0 TMP1, zero, -5 //LJ_TSTR
  |    B_addi_y1 AT1, CARG3, HI
  |    B_st4_y2 AT, TMP0
  |  st4 AT1, TMP1
  |  b >1
  |
  |->vmeta_tgetb:			// TMP0 = index
  |.if not DUALNUM
  |  B_X
  |    B_cmpltsi_x0 AT, TMP0, 0
  |    B_sub_x1 AT1, zero, TMP0
  |  B_X
  |    B_cmovnez_x0 TMP0, AT, AT1
  |    B_moveli_x1 AT2, 539
  |  B_X
  |    B_shli_x0 AT2, AT2, 8
  |    B_shli_x1 AT1, TMP0, 4
  |  bfins AT2, AT, 20, 20
  |  fdouble_pack1 TMP0, AT1, AT2
  |  B_X
  |    B_fdouble_pack2_x0 TMP0, AT1, zero
  |    B_addli_x1 CARG3, DISPATCH, DISPATCH_GL(tmptv)
  |  st CARG3, TMP0
  |.else
  |  B_X
  |    B_v4int_l_x0 TMP0, TISNUM, TMP0
  |    B_addli_x1 CARG3, DISPATCH, DISPATCH_GL(tmptv)
  |  st CARG3, TMP0
  |.endif
  |
  |->vmeta_tgetv:
  |1:
  |  // load_got lj_meta_tget
  |  addli CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_meta_tget)
  |  B_X
  |    B_addlo_x0 AT, L:LREG->base
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  B_X
  |    B_addi_x0 AT1, sp, SAVE_PC
  |    B_st_x1 AT, BASE
  |  B_X
  |    B_move_x0 CARG1, L
  |    B_st_x1 AT1, PC
  |  call_intern lj_meta_tget		// (lua_State *L, TValue *o, TValue *k)
  |  // Returns TValue * (finished) or NULL (metamethod).
  |  B_X
  |    B_addli_x0 TMP1, BASE, -FRAME_CONT
  |    B_beqz_x1 CRET1, >3
  |  ld AT, CRET1
  |  ins_next1
  |  st RA, AT
  |  ins_next2
  |
  |3:  // Call __index metamethod.
  |  // BASE = base, L->top = new base, stack = cont/func/t/k
  |  addlo BASE, L:LREG->top
  |  ld BASE, BASE
  |  addi AT, BASE, -16 + HI
  |  B_X
  |    B_sub_x0 PC, BASE, TMP1
  |    B_st4_x1 AT, PC
  |  addi LFUNC:RB, BASE, FRAME_FUNC
  |  B_X
  |    B_addi_x0 NARGS8:RC, zero, 16			// 2 args for func(t, k).
  |    B_ld4s_x1 LFUNC:RB, LFUNC:RB
  |  b ->vm_call_dispatch_f
  |
  |//-----------------------------------------------------------------------
  |
  |->vmeta_tsets1:
  |  B_X
  |    B_addli_x0 CARG3, DISPATCH, DISPATCH_GL(tmptv)
  |    B_addi_x1 TMP0, zero, LJ_TSTR
  |  B_X
  |    B_addi_x0 AT, CARG3, HI
  |    B_st4_x1 CARG3, STR:RC
  |  st4 AT, TMP0
  |  b >1
  |
  |->vmeta_tsets:
  |  B_X
  |    B_addli_x0 CARG2, DISPATCH, DISPATCH_GL(tmptv)
  |    B_addi_x1 TMP0, zero, LJ_TTAB
  |  B_X
  |    B_addli_x0 CARG3, DISPATCH, DISPATCH_GL(tmptv2)
  |    B_st4_x1 CARG2, TAB:RB
  |  B_X
  |    B_addi_x0 AT, CARG2, HI
  |    B_st4_x1 CARG3, STR:RC
  |  B_X
  |    B_addi_x0 TMP1, zero, LJ_TSTR
  |    B_st4_x1 AT, TMP0
  |  addi AT, CARG3, HI
  |  st4 AT, TMP1
  |  b >1
  |
  |->vmeta_tsetb:			// TMP0 = index
  |.if not DUALNUM
  |  B_X
  |    B_cmpltsi_x0 AT, TMP0, 0
  |    B_sub_x1 AT1, zero, TMP0
  |  B_X
  |    B_cmovnez_x0 TMP0, AT, AT1
  |    B_moveli_x1 AT2, 539
  |  B_X
  |    B_shli_x0 AT2, AT2, 8
  |    B_shli_x1 AT1, TMP0, 4
  |  bfins AT2, AT, 20, 20
  |  fdouble_pack1 TMP0, AT1, AT2
  |  B_X
  |    B_fdouble_pack2_x0 TMP0, AT1, zero
  |    B_addli_x1 CARG3, DISPATCH, DISPATCH_GL(tmptv)
  |  st CARG3, TMP0
  |.else
  |  B_X
  |    B_v4int_l_x0 TMP0, TISNUM, TMP0
  |    B_addli_x1 CARG3, DISPATCH, DISPATCH_GL(tmptv)
  |  st CARG3, TMP0
  |.endif
  |
  |->vmeta_tsetv:
  |1:
  |  //load_got lj_meta_tset
  |  addli CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_meta_tset)
  |  B_X
  |    B_addlo_x0 AT, L:LREG->base
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  B_X
  |    B_addi_x0 AT1, sp, SAVE_PC
  |    B_st_x1 AT, BASE
  |  B_X
  |    B_move_x0 CARG1, L
  |    B_st_x1 AT1, PC
  |  call_intern lj_meta_tset		// (lua_State *L, TValue *o, TValue *k)
  |  // Returns TValue * (finished) or NULL (metamethod).
  |  ld AT2, RA
  |  beqz CRET1, >3
  |  // NOBARRIER: lj_meta_tset ensures the table is not black.
  |  ins_next1
  |  st CRET1, AT2
  |  ins_next2
  |
  |3:  // Call __newindex metamethod.
  |  // BASE = base, L->top = new base, stack = cont/func/t/k/(v)
  |  addli TMP1, BASE, -FRAME_CONT
  |  addlo BASE, L:LREG->top
  |  ld BASE, BASE
  |  addi AT, BASE, -16+HI
  |  B_X
  |    B_sub_x0 PC, BASE, TMP1
  |    B_st4_x1 AT, PC
  |  addi LFUNC:RB, BASE, FRAME_FUNC
  |  B_X
  |    B_addi_x0 AT, BASE, 16
  |    B_ld4s_x1 LFUNC:RB, LFUNC:RB
  |  B_X
  |    B_addi_x0 NARGS8:RC, zero, 24			// 3 args for func(t, k, v)
  |    B_st_x1 AT, AT2
  |  b ->vm_call_dispatch_f
  |
  |//-- Comparison metamethods ---------------------------------------------
  |
  |->vmeta_comp:
  |  // CARG2, CARG3 are already set by BC_ISLT/BC_ISGE/BC_ISLE/BC_ISGT.
  |  // load_got lj_meta_comp
  |  B_X
  |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_meta_comp)
  |    B_addli_x1 PC, PC, -4
  |  B_X
  |    B_addlo_x0 AT, L:LREG->base
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  B_X
  |    B_addi_x0 AT1, sp, SAVE_PC
  |    B_st_x1 AT, BASE
  |  B_X
  |    B_bfextu_x0 CARG4, INS, 0, 7
  |    B_st_x1 AT1, PC
  |  B_X
  |    B_move_x0 CARG1, L
  |    //call_intern lj_meta_comp	// (lua_State *L, TValue *o1, *o2, int op)
  |    B_jalr_x1 CFUNCADDR
  |  // Returns 0/1 or TValue * (metamethod).
  |3:
  |  cmpltui AT, CRET1, 2
  |  beqz AT, ->vmeta_binop
  |  sub TMP2, zero, CRET1
  |4:
  |  B_X
  |    B_addi_x0 RD, PC, OFS_RD
  |    B_addli_x1 PC, PC, 4
  |  B_X
  |    B_moveli_x0 TMP1, (-(BCBIAS_J*4 >> 16) & 65535)
  |    B_ld2u_x1 RD, RD
  |  B_X
  |    B_shl16insli_x0 TMP1, TMP1, 0
  |    B_shli_x1 RD, RD, 2
  |  add RD, RD, TMP1
  |  and RD, RD, TMP2
  |  add PC, PC, RD
  |->cont_nop:
  |  ins_next
  |
  |->cont_ra:				// RA = resultptr
  |  addi TMP1, PC, -4+OFS_RA
  |  ld1u TMP1, TMP1
  |  B_X
  |    B_shli_x0 TMP1, TMP1, 3
  |    B_ld_x1 AT, RA
  |  add TMP1, BASE, TMP1
  |  st TMP1, AT
  |  b ->cont_nop
  |
  |->cont_condt:			// RA = resultptr
  |  ld TMP0, RA
  |  shrsi TMP0, TMP0, 32
  |  cmpltui AT, TMP0, LJ_TISTRUECOND
  |  sub TMP2, zero, AT
  |  b <4
  |
  |->cont_condf:			// RA = resultptr
  |  ld TMP0, RA
  |  shrsi TMP0, TMP0, 32
  |  cmpltui AT, TMP0, LJ_TISTRUECOND
  |  addli TMP2, AT, -1		// Branch if result is false.
  |  b <4
  |
  |->vmeta_equal:
  |  // CARG2, CARG3, CARG4 are already set by BC_ISEQV/BC_ISNEV.
  |  // load_got lj_meta_equal
  |  B_X
  |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_meta_equal)
  |    B_addli_x1 PC, PC, -4
  |  B_X
  |    B_addlo_x0 AT, L:LREG->base
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  B_X
  |    B_addi_x0 AT1, sp, SAVE_PC
  |    B_st_x1 AT, BASE
  |  B_X
  |    B_move_x0 CARG1, L
  |    B_st_x1 AT1, PC
  |  call_intern lj_meta_equal  // (lua_State *L, GCobj *o1, *o2, int ne)
  |  // Returns 0/1 or TValue * (metamethod).
  |  b <3
  |
  |->vmeta_equal_cd:
  |.if FFI
  |  //load_got lj_meta_equal_cd
  |  B_X
  |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_meta_equal)
  |    B_move_x1 CARG2, INS
  |  B_X
  |    B_addli_x0 PC, PC, -4
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  addlo AT, L:LREG->base
  |  B_X
  |    B_addi_x0 AT1, sp, SAVE_PC
  |    B_st_x1 AT, BASE
  |  B_X
  |    B_move_x0 CARG1, L
  |    B_st_x1 AT1, PC
  |  call_intern lj_meta_equal_cd	// (lua_State *L, BCIns op)
  |  // Returns 0/1 or TValue * (metamethod).
  |  b <3
  |.endif
  |
  |//-- Arithmetic metamethods ---------------------------------------------
  |
  |->vmeta_unm:
  |  move CARG4, CARG3
  |
  |->vmeta_arith:
  |  //load_got lj_meta_arith
  |  //decode_OP1 TMP0, INS
  |  B_X
  |    B_bfextu_x0 TMP0, INS, 0, 7
  |    B_addli_x1 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_meta_arith)
  |  B_X
  |    B_addlo_x0 AT, L:LREG->base
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  B_X
  |    B_addi_x0 AT1, sp, SAVE_PC
  |    B_st_x1 AT, BASE
  |  B_Y3
  |    B_move_y0 CARG2, RA
  |    B_move_y1 ARG5, TMP0
  |    B_st_y2 AT1, PC
  |  B_X
  |    B_move_x0 CARG1, L
  |    //call_intern lj_meta_arith  // (lua_State *L, TValue *ra,*rb,*rc, BCReg op)
  |    B_jalr_x1 CFUNCADDR
  |  // Returns NULL (finished) or TValue * (metamethod).
  |  beqz CRET1, ->cont_nop
  |
  |  // Call metamethod for binary op.
  |->vmeta_binop:
  |  // BASE = old base, CRET1 = new base, stack = cont/func/o1/o2
  |  B_X
  |    B_sub_x0 TMP1, CRET1, BASE
  |    B_addi_x1 AT, CRET1, -16+HI
  |  B_X
  |    B_move_x0 TMP2, BASE
  |    B_st4_x1 AT, PC
  |  B_X
  |    B_addli_x0 PC, TMP1, FRAME_CONT
  |    B_move_x1 BASE, CRET1
  |  B_X
  |    B_addi_x0 NARGS8:RC, zero, 16			// 2 args for func(o1, o2).
  |    B_b_x1 ->vm_call_dispatch
  |
  |->vmeta_len:
  |  // CARG2 already set by BC_LEN.
#if LJ_52
  |  move MULTRES, CARG1
#endif
  |  //load_got lj_meta_len
  |  addli CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_meta_len)
  |  B_X
  |    B_addlo_x0 AT, L:LREG->base
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  B_X
  |    B_addi_x0 AT1, sp, SAVE_PC
  |    B_st_x1 AT, BASE
  |  st AT1, PC
  |  B_X
  |    B_move_x0 CARG1, L
  |    //call_intern lj_meta_len		// (lua_State *L, TValue *o)
  |    B_jalr_x1 CFUNCADDR
  |  // Returns NULL (retry) or TValue * (metamethod base).
#if LJ_52
  |  bnez CRET1, ->vmeta_binop		// Binop call for compatibility.
  |  B_X
  |    B_move_x0 CARG1, MULTRES
  |    B_b_x1 ->BC_LEN_Z
#else
  |  b ->vmeta_binop			// Binop call for compatibility.
#endif
  |
  |//-- Call metamethod ----------------------------------------------------
  |
  |->vmeta_call:			// Resolve and call __call metamethod.
  |  // TMP2 = old base, BASE = new base, RC = nargs*8
  |  // load_got lj_meta_call
  |  B_X
  |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_meta_call)
  |    B_addi_x1 AT1, sp, SAVE_PC
  |  B_X
  |    B_addlo_x0 AT, L:LREG->base			// This is the callers base!
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  B_X
  |    B_addli_x0 CARG2, BASE, -8
  |    B_st_x1 AT, TMP2
  |  B_X
  |    B_add_x0 CARG3, BASE, RC
  |    B_st_x1 AT1, PC
  |  B_X
  |    B_move_x0 MULTRES, NARGS8:RC
  |    B_move_x1 CARG1, L
  |  call_intern lj_meta_call	// (lua_State *L, TValue *func, TValue *top)
  |  addi LFUNC:RB, BASE, FRAME_FUNC
  |  B_X
  |    B_addli_x0 NARGS8:RC, MULTRES, 8	// Got one more argument now.
  |    B_ld4s_x1 LFUNC:RB, LFUNC:RB
  |  ins_call
  |
  |->vmeta_callt:			// Resolve __call for BC_CALLT.
  |  // BASE = old base, RA = new base, RC = nargs*8
  |  // load_got lj_meta_call
  |  B_X
  |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_meta_call)
  |    B_addi_x1 AT1, sp, SAVE_PC
  |  B_X
  |    B_addlo_x0 AT, L:LREG->base
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  B_X
  |    B_addli_x0 CARG2, RA, -8
  |    B_st_x1 AT, BASE
  |  B_X
  |    B_add_x0 CARG3, RA, RC
  |    B_st_x1 AT1, PC
  |  B_X
  |    B_move_x0 MULTRES, NARGS8:RC
  |    B_move_x1 CARG1, L
  |  call_intern lj_meta_call	// (lua_State *L, TValue *func, TValue *top)
  |  addi TMP1, BASE, FRAME_PC
  |  B_X
  |    B_addi_x0 LFUNC:RB, RA, FRAME_FUNC
  |    B_ld4s_x1 TMP1, TMP1
  |  B_X
  |    B_addli_x0 NARGS8:RC, MULTRES, 8	// Got one more argument now.
  |    B_ld4s_x1 LFUNC:RB, LFUNC:RB
  |  b ->BC_CALLT_Z
  |
  |//-- Argument coercion for 'for' statement ------------------------------
  |
  |->vmeta_for:
  |  // load_got lj_meta_for
  |  B_X
  |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_meta_for)
  |    B_addi_x1 AT1, sp, SAVE_PC
  |  B_X
  |    B_addlo_x0 AT, L:LREG->base
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  B_X
  |    B_move_x0 CARG2, RA
  |    B_st_x1 AT, BASE
  |  B_Y3
  |    B_move_y0 MULTRES, INS
  |    B_move_y1 CARG1, L
  |    B_st_y2 AT1, PC
  |  call_intern lj_meta_for	// (lua_State *L, TValue *base)
  |.if JIT
  |  B_X
  |    //decode_OP1 TMP0, MULTRES
  |    B_bfextu_x0 TMP0, MULTRES, 0, 7
  |    B_addi_x1 AT, zero, BC_JFORI
  |.endif
  |    // decode_RA8a RA, MULTRES
  |    // decode_RD8a RD, MULTRES
  |  B_X
  |    B_shrui_x0 RA, MULTRES, 5
  |    B_shrui_x1 RD, MULTRES, 16
  |.if JIT
  |  // decode_RA8b RA
  |  // decode_RD8b RD
  |  B_X
  |    B_bfextu_x0 RA, RA, 3, 10
  |    B_shli_x1 RD, RD, 3
  |  B_X
  |    B_shli_x0 RA, RA, 3
  |    B_cmpeq_x1 AT1, TMP0, AT
  |  bnez AT1, =>BC_JFORI
  |  b =>BC_FORI
  |.else
  |  // decode_RA8b RA
  |  // decode_RD8b RD
  |  B_X
  |    B_bfextu_x0 RA, RA, 3, 10
  |    B_shli_x1 RD, RD, 3
  |  B_X
  |    B_shli_x0 RA, RA, 3
  |    B_b_x1 =>BC_FORI
  |.endif
  |
  |//-----------------------------------------------------------------------
  |//-- Fast functions -----------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |.macro .ffunc, name
  |->ff_ .. name:
  |.endmacro
  |
  |.macro .ffunc_1, name
  |->ff_ .. name:
  |  ld CARG1, BASE
  |.if "name" == "math_abs"
  |  shrsi CARG3, CARG1, 32
  |.else
  |  B_X
  |    B_bfexts_x0 CARG1, CARG1, 0, 31
  |    B_shrsi_x1 CARG3, CARG1, 32
  |.endif
  |  beqz NARGS8:RC, ->fff_fallback
  |.endmacro
  |
  |.macro .ffunc_2, name
  |->ff_ .. name:
  |  B_X
  |    B_addi_x0 CARG2, BASE, 8
  |    B_ld_x1 CARG1, BASE
  |  B_X
  |    B_shrsi_x0 CARG3, CARG1, 32
  |    B_ld_x1 CARG2, CARG2
  |  B_X
  |    B_cmpltui_x0 AT, NARGS8:RC, 16
  |    B_shrsi_x1 CARG4, CARG2, 32
  |  bfexts CARG1, CARG1, 0, 31
  |  B_X
  |    B_bfexts_x0 CARG2, CARG2, 0, 31
  |    B_bnez_x1 AT, ->fff_fallback
  |.endmacro
  |
  |.macro .ffunc_n, name	// Caveat: has delay slot!
  |->ff_ .. name:
  |  ld CARG1, BASE
  |  B_X
  |    B_shrsi_x0 CARG3, CARG1, 32
  |    B_beqz_x1 NARGS8:RC, ->fff_fallback
  |  cmpltu AT, CARG3, TISNUM
  |.if "name" == "math_rad"
  |  addlo CARG2, CFUNC:RB->upvalue[0]
  |  ld CARG2, CARG2
  |.endif
  |  beqz AT, ->fff_fallback
  |.endmacro
  |
  |.macro .ffunc_nn, name	// Caveat: has delay slot!
  |->ff_ .. name:
  |  B_X
  |    B_cmpltui_x0 AT, NARGS8:RC, 16
  |    B_ld_x1 CARG1, BASE
  |  B_X
  |    B_addi_x0 AT1, BASE, 8
  |    B_bnez_x1 AT, ->fff_fallback
  |  B_X
  |    B_shrsi_x0 CARG3, CARG1, 32
  |    B_ld_x1 CARG2, AT1
  |  shrsi CARG4, CARG2, 32
  |  B_X
  |    B_cmpltu_x0 TMP0, CARG3, TISNUM
  |    B_cmpltu_x1 TMP1, CARG4, TISNUM
  |  and TMP0, TMP0, TMP1
  |  beqz TMP0, ->fff_fallback
  |.endmacro
  |
  |// Inlined GC threshold check. Caveat: uses TMP0 and TMP1 and has delay slot!
  |.macro ffgccheck
  |  addli TMP0, DISPATCH, DISPATCH_GL(gc.total)
  |  B_X
  |    B_addli_x0 TMP1, DISPATCH, DISPATCH_GL(gc.threshold)
  |    B_ld4u_x1 TMP0, TMP0
  |  ld4u TMP1, TMP1
  |  sub AT, TMP0, TMP1
  |  cmplts AT, zero, AT
  |  beqz AT, >1
  |  jal ->fff_gcstep
  |  1:
  |.endmacro
  |
  |//-- Base library: checks -----------------------------------------------
  |
  |.ffunc_1 assert
  |  B_X
  |    B_cmpltui_x0 AT, CARG3, LJ_TISTRUECOND
  |    B_addli_x1 RA, BASE, -8
  |  beqz AT, ->fff_fallback
  |  B_X
  |    B_addi_x0 PC, BASE, FRAME_PC
  |    B_addli_x1 RD, NARGS8:RC, 8		// Compute (nresults+1)*8.
  |  B_Y2
  |    B_add_y0 TMP2, RA, NARGS8:RC
  |    B_addi_y1 AT, RA, HI
  |    B_ld4s_y2 PC, PC
  |  B_X
  |    B_addi_x0 TMP1, BASE, 8
  |    B_st4_x1 AT, CARG3
  |  B_X
  |    B_addi_x0 AT, RA, LO
  |    B_cmpeq_x1 AT1, BASE, TMP2
  |  st4 AT, CARG1
  |  bnez AT1, ->fff_res		// Done if exactly 1 argument.
  |1:
  |  B_X
  |    B_addi_x0 AT, TMP1, -8
  |    B_ld_x1 AT2, TMP1
  |  B_X
  |    B_cmpne_x0 AT1, TMP1, TMP2
  |    B_st_x1 AT, AT2
  |  B_X
  |    B_addli_x0 TMP1, TMP1, 8
  |    B_bnez_x1 AT1, <1
  |  b ->fff_res
  |
  |.ffunc type
  |  ld CARG3, BASE
  |  shrsi CARG3, CARG3, 32
  |  move AT, CARG3
  |  shrsi AT, AT, 15
  |  cmpeqi AT, AT, -2
  |  bnez AT, >3
  |  B_X
  |    B_movei_x0 TMP1, ~LJ_TNUMX
  |    B_nor_x1 CARG3, CARG3, zero
  |  cmpleu TMP0, CARG3, TMP1
  |  cmovnez TMP1, TMP0, CARG3
  |2:
  |  shli TMP1, TMP1, 3
  |  add TMP1, CFUNC:RB, TMP1
  |  addlo CRET1, CFUNC:TMP1->upvalue
  |  ld CRET1, CRET1
  |  b ->fff_resn
  |3:  
  |  B_X
  |    B_movei_x0 TMP1, ~LJ_TLIGHTUD
  |    B_b_x1 <2
  |
  |//-- Base library: getters and setters ---------------------------------
  |
  |.ffunc_1 getmetatable
  |  addi AT1, zero, LJ_TTAB
  |  B_X
  |    B_addi_x0 AT, zero, LJ_TUDATA
  |    B_cmpne_x1 AT1, CARG3, AT1
  |  bnez AT1, >6
  |1:  // Field metatable must be at same offset for GCtab and GCudata!
  |  addlo TAB:CARG1, TAB:CARG1->metatable
  |  ld4u TAB:CARG1, TAB:CARG1
  |2:
  |  addli STR:RC, DISPATCH, DISPATCH_GL(gcroot[GCROOT_MMNAME+MM_metatable])
  |  B_X
  |    B_addi_x0 CARG3, zero, LJ_TNIL
  |    B_ld4u_x1 STR:RC, STR:RC
  |  beqz TAB:CARG1, ->fff_restv
  |  B_X
  |    B_addlo_x0 TMP0, TAB:CARG1->hmask
  |    B_addi_x1 CARG3, zero, LJ_TTAB			// Use metatable as default result.
  |  B_X
  |    B_addlo_x0 TMP1, STR:RC->hash
  |    B_ld4u_x1 TMP0, TMP0
  |  B_X
  |    B_addlo_x0 NODE:TMP2, TAB:CARG1->node
  |    B_ld4u_x1 TMP1, TMP1
  |  ld4u NODE:TMP2, NODE:TMP2
  |  and TMP1, TMP1, TMP0		// idx = str->hash & tab->hmask
  |  B_X
  |    B_shli_x0 TMP0, TMP1, 5
  |    B_shli_x1 TMP1, TMP1, 3
  |  sub TMP1, TMP0, TMP1
  |  B_X
  |    B_add_x0 NODE:TMP2, NODE:TMP2, TMP1	// node = tab->node + (idx*32-idx*8)
  |    B_addi_x1 AT, zero, LJ_TSTR
  |3:  // Rearranged logic, because we expect _not_ to find the key.
  |  addi CARG4, NODE:TMP2, offsetof(Node, key)+HI
  |  B_X
  |    B_addi_x0 TMP0, NODE:TMP2, offsetof(Node, key)+LO
  |    B_ld4s_x1 CARG4, CARG4
  |  B_X
  |    B_addlo_x0 NODE:TMP3, NODE:TMP2->next
  |    B_ld4s_x1 TMP0, TMP0
  |  B_X
  |    B_addi_x0 CARG2, NODE:TMP2, offsetof(Node, val)+HI
  |    B_ld4s_x1 NODE:TMP3, NODE:TMP3
  |  B_X
  |    B_cmpne_x0 AT1, CARG4, AT
  |    B_ld4s_x1 CARG2, CARG2
  |  bnez AT1, >4
  |  addi TMP1, NODE:TMP2, offsetof(Node, val)+LO
  |  B_X
  |    B_cmpeq_x0 AT, TMP0, STR:RC
  |    B_ld4s_x1 TMP1, TMP1
  |  bnez AT, >5
  |4:
  |  B_X
  |    B_move_x0 NODE:TMP2, NODE:TMP3
  |    B_beqz_x1 NODE:TMP3, ->fff_restv	// Not found, keep default result.
  |  b <3
  |5:
  |  cmpeq AT, CARG2, TISNIL
  |  bnez AT, ->fff_restv	// Ditto for nil value.
  |  B_X
  |    B_move_x0 CARG3, CARG2			// Return value of mt.__metatable.
  |    B_move_x1 CARG1, TMP1
  |  b ->fff_restv
  |
  |6:
  |  moveli AT2, (short)((LJ_TISNUM >> 16) & 0xFFFF)
  |  shl16insli AT2, AT2, (short)(LJ_TISNUM & 0xFFFF)
  |  B_X
  |    B_cmpltu_x0 TMP0, CARG3, AT2
  |    B_cmpeq_x1 AT1, CARG3, AT
  |  bnez AT1, <1
  |  cmoveqz AT2, TMP0, CARG3
  |  nor AT2, AT2, zero
  |  shli AT2, AT2, 2
  |  add AT2, DISPATCH, AT2
  |  addli TAB:CARG1, AT2, DISPATCH_GL(gcroot[GCROOT_BASEMT])
  |  ld TAB:CARG1, TAB:CARG1
  |  b <2
  |
  |.ffunc_2 setmetatable
  |  // Fast path: no mt for table yet and not clearing the mt.
  |  B_X
  |    B_addi_x0 AT, zero, LJ_TTAB
  |    B_addli_x1 CARG4, CARG4, -LJ_TTAB
  |  cmpne AT, CARG3, AT
  |  bnez AT, ->fff_fallback
  |  addlo TAB:TMP1, TAB:CARG1->metatable
  |  B_X
  |    B_addlo_x0 TMP3, TAB:CARG1->marked
  |    B_ld4u_x1 TAB:TMP1, TAB:TMP1
  |  B_X
  |    B_or_x0 AT, CARG4, TAB:TMP1
  |    B_ld1u_x1 TMP3, TMP3
  |  andi AT, TMP3, LJ_GC_BLACK	// isblack(table)
  |  bnez AT, ->fff_fallback
  |  addlo AT1, TAB:CARG1->metatable
  |  st4 AT1, TAB:CARG2
  |  beqz AT, ->fff_restv
  |  barrierback TAB:CARG1, TMP3, TMP0, ->fff_restv
  |
  |.ffunc rawget
  |  B_X
  |    B_addi_x0 CARG4, BASE, HI
  |    B_cmpltui_x1 AT, NARGS8:RC, 16
  |  B_X
  |    B_addi_x0 TAB:CARG2, BASE, LO
  |    B_ld4s_x1 CARG4, CARG4
  |  B_X
  |    // load_got lj_tab_get
  |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_tab_get)
  |    B_ld4s_x1 TAB:CARG2, TAB:CARG2
  |  B_X
  |    B_addli_x0 CARG4, CARG4, -LJ_TTAB
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  or AT, AT, CARG4
  |  bnez AT, ->fff_fallback
  |  B_X
  |    B_addli_x0 CARG3, BASE, 8
  |    B_move_x1 CARG1, L
  |  call_intern lj_tab_get	// (lua_State *L, GCtab *t, cTValue *key)
  |  // Returns cTValue *.
  |  ld AT2, CRET1
  |  b ->fff_resn
  |
  |//-- Base library: conversions ------------------------------------------
  |
  |.ffunc tonumber
  |  // Only handles the number case inline (without a base argument).
  |  ld CRET1, BASE
  |  B_X
  |    B_shrsi_x0 AT1, CRET1, 32
  |    B_xori_x1 AT, NARGS8:RC, 8
  |  cmpltu CARG1, AT1, TISNUM
  |  cmovnez CARG1, AT, zero
  |  beqz CARG1, ->fff_fallback		// Exactly one number argument.
  |  ld CRET1, BASE
  |  b ->fff_resn
  |
  |.ffunc_1 tostring
  |  // Only handles the string or number case inline.
  |  B_X
  |    B_addi_x0 AT, zero, LJ_TSTR
  |  // A __tostring method in the string base metatable is ignored.
  |  // Handle numbers inline, unless a number base metatable is present.
  |    B_addli_x1 TMP1, DISPATCH, DISPATCH_GL(gcroot[GCROOT_BASEMT_NUM])
  |  B_X
  |    B_cmpeq_x0 AT, CARG3, AT
  |    B_ld4u_x1 TMP1, TMP1
  |  bnez AT, ->fff_restv			// String key?
  |  B_X
  |    B_cmpltu_x0 TMP0, CARG3, TISNUM
  |    B_cmpltui_x1 TMP1, TMP1, 1
  |  B_X
  |    B_and_x0 TMP0, TMP0, TMP1
  |    B_addlo_x1 AT, L:LREG->base			// Add frame since C call can throw.
  |  st AT, BASE
  |  B_X
  |    B_addi_x0 AT, sp, SAVE_PC
  |    B_beqz_x1 TMP0, ->fff_fallback
  |  B_X
  |.if DUALNUM
  |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_str_fromnumber)
  |.else
  |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_str_fromnum)
  |.endif
  |    B_st_x1 AT, PC
  |  ffgccheck
  |  // load_got lj_str_fromnum
  |  B_Y2
  |    B_move_y0 CARG1, L
  |    B_move_y1 CARG2, BASE
  |    B_ld_y2 CFUNCADDR, CFUNCADDR
  |  call_intern lj_str_fromnum		// (lua_State *L, lua_Number *np)
  |  // Returns GCstr *.
  |  B_X
  |    B_addi_x0 CARG3, zero, LJ_TSTR
  |    //move CARG1, CRET1
  |    B_b_x1 ->fff_restv
  |
  |//-- Base library: iterators -------------------------------------------
  |
  |.ffunc next
  |  B_X
  |    B_addi_x0 AT6, BASE, 8
  |    B_ld_x1 CARG1, BASE
  |  B_X
  |    B_shrsi_x0 CARG1, CARG1, 32
  |    B_ld_add_x1 MULTRES, AT6, 8
  |  B_X
  |    B_add_x0 TMP2, BASE, NARGS8:RC
  |    B_ld4s_x1 TAB:CARG2, BASE
  |  beqz NARGS8:RC, ->fff_fallback
  |  B_X
  |    B_addi_x0 AT1, TMP2, HI
  |    B_ld_add_x1 CROSSTMP1, AT6, 8
  |  B_Y3
  |    B_addi_y0 AT, zero, -12//LJ_TTAB
  |    B_addi_y1 PC, BASE, -4 //FRAME_PC
  |    B_st4_y2 AT1, TISNIL
  |  B_X
  |    B_cmpne_x0 AT1, CARG1, AT
  |    B_ld4s_x1 PC, PC
  |  B_X
  |    // load_got lj_tab_next
  |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_tab_next)
  |    B_bnez_x1 AT1, ->fff_fallback
  |  B_X
  |    B_addlo_x0 AT, L->base			// Add frame since C call can throw.
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  B_X
  |    B_addlo_x0 AT1, L->top			// Add frame since C call can throw.
  |    B_st_x1 AT, BASE
  |  B_X
  |    B_addli_x0 CARG3, BASE, 8
  |    B_st_x1 AT1, BASE
  |  addi AT, sp, SAVE_PC
  |  B_X
  |    B_move_x0 CARG1, L
  |    B_st_x1 AT, PC
  |  call_intern lj_tab_next		// (lua_State *L, GCtab *t, TValue *key)
  |  // Returns 0 at end of traversal.
  |  B_X
  |    B_addi_x0 CARG3, zero, LJ_TNIL
  |    B_beqz_x1 CRET1, ->fff_restv		// End of traversal: return nil.
  |  B_X
  |    B_addi_x0 RA, BASE, -8
  |    B_addi_x1 RD, zero, (2+1)*8
  |  B_X
  |    B_addi_x0 AT, RA, 8
  |    B_st_x1 RA, MULTRES
  |  st AT, CROSSTMP1
  |  b ->fff_res
  |
  |.ffunc_1 pairs
  |  B_X
  |    B_addi_x0 AT, zero, LJ_TTAB
  |    B_addi_x1 PC, BASE, FRAME_PC
  |  B_X
  |    B_cmpne_x0 AT, CARG3, AT
  |    B_ld4s_x1 PC, PC
  |  bnez AT, ->fff_fallback
#if LJ_52
  |  B_X
  |    B_addli_x0 RA, BASE, -8
  |    B_addlo_x1 TAB:TMP2, TAB:CARG1->metatable
  |  B_X
  |    B_addlo_x0 AT2, CFUNC:RB->upvalue[0]
  |    B_ld4u_x1 TAB:TMP2, TAB:TMP2
  |  ld AT2, AT2
  |  bnez TAB:TMP2, ->fff_fallback
#else
  |  B_X
  |    B_addli_x0 RA, BASE, -8
  |    B_addlo_x1 AT2, CFUNC:RB->upvalue[0]
  |  ld AT2, AT2
#endif
  |  B_X
  |    B_addi_x0 AT, BASE, 8+HI
  |    B_st_x1 RA, AT2
  |  B_X
  |    B_addi_x0 RD, zero, (3+1)*8
  |    B_st4_x1 AT, TISNIL
  |  b ->fff_res
  |
  |.ffunc ipairs_aux
  |.if DUALNUM
  |  B_X
  |    B_addi_x0 CARG2, BASE, 8
  |    B_ld_x1 TAB:CARG1, BASE
  |  B_X
  |    B_shrsi_x0 CARG3, CARG1, 32
  |    B_ld_x1 CARG2, CARG2
  |  B_X
  |    B_bfexts_x0 CARG1, CARG1, 0, 31
  |    B_shrsi_x1 CARG4, CARG2, 32
  |  B_X
  |    B_bfexts_x0 CARG2, CARG2, 0, 31
  |    B_cmpltui_x1 AT, NARGS8:RC, 16
  |  B_X
  |    B_cmpeqi_x0 AT, CARG3, -12 // LJ_TTAB
  |    B_bnez_x1 AT, ->fff_fallback
  |  B_X
  |    B_cmpne_x0 AT, CARG4, TISNUM
  |    B_beqz_x1 AT, ->fff_fallback
  |  B_X
  |    B_addi_x0 PC, BASE, FRAME_PC
  |    B_bnez_x1 AT, ->fff_fallback
  |  B_X
  |    B_addlo_x0 TMP0, TAB:CARG1->asize
  |    B_ld4s_x1 PC, PC
  |  B_X
  |    B_addlo_x0 TMP1, TAB:CARG1->array
  |    B_ld4u_x1 TMP0, TMP0
  |  B_Y2
  |    B_addi_y0 RA, BASE, -8
  |    B_addi_y1 TMP2, CARG2, 1
  |    B_ld4u_y2 TMP1, TMP1
  |  v4int_l AT, TISNUM, TMP2
  |  B_Y3
  |    B_cmpltu_y0 AT, TMP2, TMP0
  |    B_shli_y1 TMP3, TMP2, 3
  |    B_st_y2 RA, AT
  |  B_X
  |    B_add_x0 TMP3, TMP1, TMP3
  |    B_beqz_x1 AT, >2			// Not in array part?
  |  ld AT2, TMP3
  |  shrsi TMP2, AT2, 32
  |1:
  |  B_X
  |    B_addi_x0 RD, zero, (0+1)*8
  |    B_cmpeq_x1 AT, TMP2, TISNIL
  |  bnez AT, ->fff_res	// End of iteration, return 0 results.
  |  B_X
  |    B_addi_x0 RD, zero, (2+1)*8
  |    B_addi_x1 AT, RA, 8
  |  st AT, AT2
  |  b ->fff_res
  |2:  // Check for empty hash part first. Otherwise call C function.
  |  addlo TMP0, TAB:CARG1->hmask
  |  B_X
  |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_tab_getinth)
  |    B_ld4u_x1 TMP0, TMP0
  |  B_X
  |    B_addi_x0 RD, zero, (0+1)*8
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  beqz TMP0, ->fff_res
  |  B_X
  |    B_move_x0 CARG2, TMP2
  |    B_jalr_x1 CFUNCADDR // (GCtab *t, int32_t key)
  |  // Returns cTValue * or NULL.
  |  B_X
  |    B_addi_x0 RD, zero, (0+1)*8
  |    B_beqz_x1 CRET1, ->fff_res
  |  B_X
  |    B_addi_x0 TMP2, CRET1, HI
  |    B_ld_x1 AT2, CRET1
  |  ld4s TMP2, TMP2
  |  b <1
  |.else // DUALNUM
  |  B_X
  |    B_cmpltui_x0 AT, NARGS8:RC, 16
  |    B_addi_x1 CARG3, BASE, HI
  |  B_X
  |    B_addi_x0 TAB:CARG1, BASE, LO
  |    B_ld4s_x1 CARG3, CARG3
  |  B_X
  |    B_addi_x0 CARG4, BASE, 8+HI
  |    B_ld4s_x1 TAB:CARG1, TAB:CARG1
  |  B_X
  |    B_addi_x0 CARG2, BASE, 8
  |    B_ld4s_x1 CARG4, CARG4
  |  ld CARG2, CARG2
  |  B_X
  |    B_moveli_x0 AT, (short)((LJ_TISNUM >> 16) & 0xFFFF)
  |    B_bnez_x1 AT, ->fff_fallback
  |  B_X
  |    B_addli_x0 CARG3, CARG3, -LJ_TTAB
  |    B_shl16insli_x1 AT, AT, (short)(LJ_TISNUM & 0xFFFF)
  |  cmpltu AT, CARG4, AT
  |  B_X
  |    B_cmovnez_x0 AT, CARG3, zero
  |    B_addi_x1 PC, BASE, FRAME_PC
  |  ld4s PC, PC
  |  B_X
  |    B_move_x0 AT2, CARG2
  |    B_beqz_x1 AT, ->fff_fallback
  |   //cvt.w.d FRET1, FARG2
  |  fixdfsi_inline AT2, AT3, AT4, AT5, AT6
  |  B_X
  |    B_move_x0 TMP2, AT2
  |    //cvt.d.w FARG1, FARG1
  |    B_moveli_x1 TMP3, 16368
  |  shl16insli TMP3, TMP3, 0
  |  B_X
  |    B_shl16insli_x0 TMP3, TMP3, 0
  |    B_addli_x1 RA, BASE, -8
  |  B_X
  |    B_shl16insli_x0 TMP3, TMP3, 0
  |    B_addlo_x1 TMP0, TAB:CARG1->asize
  |  B_X
  |    B_addlo_x0 TMP1, TAB:CARG1->array
  |    B_ld4u_x1 TMP0, TMP0
  |  B_X
  |    //add.d CARG2, CARG2, TMP3
  |    B_fdouble_add_flags_x0 AT, CARG2, TMP3
  |    B_ld4u_x1 TMP1, TMP1
  |  fdouble_unpack_min AT1, CARG2, TMP3
  |  fdouble_unpack_max TMP3, CARG2, TMP3
  |  fdouble_addsub TMP3, AT1, AT
  |  fdouble_pack1 CARG2, TMP3, AT
  |  B_X
  |    B_fdouble_pack2_x0 CARG2, TMP3, zero
  |    B_addli_x1 TMP2, TMP2, 1
  |  B_X
  |    B_cmpltu_x0 AT, TMP2, TMP0
  |    B_shli_x1 TMP3, TMP2, 3
  |  B_X
  |    B_add_x0 TMP3, TMP1, TMP3
  |    B_st_x1 RA, CARG2
  |  beqz AT, >2			// Not in array part?
  |  B_X
  |    B_addi_x0 TMP2, TMP3, HI
  |    B_ld_x1 AT2, TMP3
  |  ld4s TMP2, TMP2
  |1:
  |  B_X
  |    B_addi_x0 RD, zero, (0+1)*8
  |    B_cmpeq_x1 AT, TMP2, TISNIL
  |  bnez AT, ->fff_res	// End of iteration, return 0 results.
  |  B_X
  |    B_addi_x0 RD, zero, (2+1)*8
  |    B_addi_x1 AT, RA, 8
  |  st AT, AT2
  |  b ->fff_res
  |2:  // Check for empty hash part first. Otherwise call C function.
  |  addlo TMP0, TAB:CARG1->hmask
  |  B_X
  |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_tab_getinth)
  |    B_ld4u_x1 TMP0, TMP0
  |  B_X
  |    B_addi_x0 RD, zero, (0+1)*8
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  beqz TMP0, ->fff_res
  |  B_X
  |    B_move_x0 CARG2, TMP2
  |    B_jalr_x1 CFUNCADDR // (GCtab *t, int32_t key)
  |  // Returns cTValue * or NULL.
  |  B_X
  |    B_addi_x0 RD, zero, (0+1)*8
  |    B_beqz_x1 CRET1, ->fff_res
  |  B_X
  |    B_addi_x0 TMP2, CRET1, HI
  |    B_ld_x1 AT2, CRET1
  |  ld4s TMP2, TMP2
  |  b <1
  |.endif
  |
  |.ffunc_1 ipairs
  |  B_X
  |    B_addi_x0 AT, zero, LJ_TTAB
  |    B_addi_x1 PC, BASE, FRAME_PC
  |  B_X
  |    B_cmpne_x0 AT, CARG3, AT
  |    B_ld4s_x1 PC, PC
  |  bnez AT, ->fff_fallback
#if LJ_52
  |  B_X
  |    B_addli_x0 RA, BASE, -8
  |    B_addlo_x1 TAB:TMP2, TAB:CARG1->metatable
  |  B_X
  |    B_addlo_x0 AT2, CFUNC:RB->upvalue[0]
  |    B_ld4u_x1 TAB:TMP2, TAB:TMP2
  |  ld AT2, AT2
  |  B_X
  |    B_addi_x0 AT, BASE, 8+HI
  |    B_bnez_x1 TAB:TMP2, ->fff_fallback
#else
  |  B_X
  |    B_addli_x0 RA, BASE, -8
  |    B_addlo_x1 AT2, CFUNC:RB->upvalue[0]
  |  B_X
  |    B_addi_x0 AT, BASE, 8+HI
  |    B_ld_x1 AT2, AT2
#endif
  |  B_X
  |    B_addi_x0 AT1, BASE, 8+LO
  |.if DUALNUM
  |    B_st4_x1 AT, TISNUM
  |.else
  |    B_st4_x1 AT, zero
  |.endif
  |  B_X
  |    B_addi_x0 RD, zero, (3+1)*8
  |    B_st4_x1 AT1, zero
  |  st RA, AT2
  |  b ->fff_res
  |
  |//-- Base library: catch errors ----------------------------------------
  |
  |.ffunc pcall
  |  addli TMP3, DISPATCH, DISPATCH_GL(hookmask)
  |  ld1u TMP3, TMP3
  |  beqz NARGS8:RC, ->fff_fallback
  |  B_X
  |    B_move_x0 TMP2, BASE
  |    B_addli_x1 BASE, BASE, 8
  |  // Remember active hook before pcall.
  |  shrui TMP3, TMP3, HOOK_ACTIVE_SHIFT
  |  andi TMP3, TMP3, 1
  |  B_X
  |    B_addli_x0 PC, TMP3, 8+FRAME_PCALL
  |    B_addli_x1 NARGS8:RC, NARGS8:RC, -8
  |  b ->vm_call_dispatch
  |
  |.ffunc xpcall
  |  B_X
  |    B_cmpltui_x0 AT, NARGS8:RC, 16
  |    B_addi_x1 CARG4, BASE, 8+HI
  |  B_X
  |    B_addi_x0 AT2, BASE, 8
  |    B_ld4s_x1 CARG4, CARG4
  |  ld AT2, AT2
  |  bnez AT, ->fff_fallback
  |  B_X
  |    B_addli_x0 TMP1, DISPATCH, DISPATCH_GL(hookmask)
  |    B_ld_x1 AT3, BASE
  |  B_X
  |    B_addi_x0 AT, zero, LJ_TFUNC
  |    B_ld1u_x1 TMP1, TMP1
  |  B_X
  |    B_move_x0 TMP2, BASE
  |    B_cmpne_x1 AT1, CARG4, AT
  |  bnez AT1, ->fff_fallback  // Traceback must be a function.
  |  B_X
  |    B_addli_x0 BASE, BASE, 16
  |    // Remember active hook before pcall.
  |    B_shrui_x1 TMP3, TMP3, HOOK_ACTIVE_SHIFT
  |  B_Y3
  |    B_andi_y0 TMP3, TMP3, 1
  |    B_addi_y1 AT, TMP2, 8
  |    B_st_y2 TMP2, AT2  // Swap function and traceback.
  |  B_X
  |    B_addli_x0 PC, TMP3, 16+FRAME_PCALL
  |    B_st_x1 AT, AT3
  |  B_X
  |    B_addli_x0 NARGS8:RC, NARGS8:RC, -16
  |    B_b_x1 ->vm_call_dispatch
  |
  |//-- Coroutine library --------------------------------------------------
  |
  |.macro coroutine_resume_wrap, resume
  |.if resume
  |.ffunc_1 coroutine_resume
  |  addi AT, zero, LJ_TTHREAD
  |  cmpne AT, CARG3, AT
  |  bnez AT, ->fff_fallback
  |.else
  |.ffunc coroutine_wrap_aux
  |  addlo L:CARG1, CFUNC:RB->upvalue[0].gcr
  |  ld4u L:CARG1, L:CARG1
  |.endif
  |  addlo TMP0, L:CARG1->status
  |  ld1u TMP0, TMP0
  |   addlo TMP1, L:CARG1->cframe
  |   ld TMP1, TMP1
  |    addlo CARG2, L:CARG1->top
  |    ld CARG2, CARG2
  |    addlo TMP2, L:CARG1->base
  |    ld TMP2, TMP2
  |  addli TMP3, TMP0, -LUA_YIELD
  |   xor TMP2, TMP2, CARG2
  |  bgtz TMP3, ->fff_fallback		// st > LUA_YIELD?
  |  or AT, TMP2, TMP0
  |  bnez TMP1, ->fff_fallback		// cframe != 0?
  |  addlo TMP0, L:CARG1->maxstack
  |  ld4u TMP0, TMP0
  |  addi PC, BASE, FRAME_PC
  |  ld4s PC, PC
  |  beqz AT, ->fff_fallback		// base == top && st == 0?
  |  add TMP2, CARG2, NARGS8:RC
  |  cmpltu AT, TMP0, TMP2
  |  addi AT1, sp, SAVE_PC
  |  st AT1, PC
  |  bnez AT, ->fff_fallback		// Stack overflow?
  |   addlo AT, L->base
  |   st AT, BASE
  |1:
  |.if resume
  |  addli BASE, BASE, 8		// Keep resumed thread in stack for GC.
  |  addli NARGS8:RC, NARGS8:RC, -8
  |  addli TMP2, TMP2, -8
  |.endif
  |  addlo AT, L:CARG1->top
  |  st AT, TMP2
  |  add TMP1, BASE, NARGS8:RC
  |  move CARG3, CARG2
  |  addlo AT, L->top
  |  st AT, BASE
  |2:  // Move args to coroutine.
  |   ld AT2, BASE
  |  cmpltu AT, BASE, TMP1
  |  addli BASE, BASE, 8
  |  beqz AT, >3
  |   st CARG3, AT2
  |  addli CARG3, CARG3, 8
  |  b <2
  |3:
  |  move L:RA, L:CARG1
  |  jal ->vm_resume			// (lua_State *L, TValue *base, 0, 0)
  |  // Returns thread status.
  |4:
  |  addlo TMP2, L:RA->base
  |  ld TMP2, TMP2
  |   cmpltui AT, CRET1, LUA_YIELD+1
  |  addlo TMP3, L:RA->top
  |  ld TMP3, TMP3
  |    li_vmstate INTERP
  |  addlo BASE, L->base
  |  ld BASE, BASE
  |    st_vmstate
  | sub RD, TMP3, TMP2
  |   beqz AT, >8
  |   addlo TMP0, L->maxstack
  |   ld4u TMP0, TMP0
  |  add TMP1, BASE, RD
  |  beqz RD, >6			// No results?
  |  cmpltu AT, TMP0, TMP1
  |  add TMP3, TMP2, RD
  |  bnez AT, >9			// Need to grow stack?
  |  addlo AT, L:RA->top			// Clear coroutine stack.
  |  st AT, TMP2
  |  move TMP1, BASE
  |5:  // Move results from coroutine.
  |   ld AT2, TMP2
  |  addli TMP2, TMP2, 8
  |  cmpltu AT, TMP2, TMP3
  |   st TMP1, AT2
  |  addli TMP1, TMP1, 8
  |  bnez AT, <5
  |6:
  |  andi TMP0, PC, FRAME_TYPE
  |.if resume
  |  addi TMP1, zero, LJ_TTRUE
  |   addli RA, BASE, -8
  |  addi AT, BASE, -8+HI
  |  st4 AT, TMP1
  |  addli RD, RD, 16
  |.else
  |  move RA, BASE
  |  addli RD, RD, 8
  |.endif
  |7:
  |  addi AT, sp, SAVE_PC
  |  st AT, PC
  |  move MULTRES, RD
  |  beqz TMP0, ->BC_RET_Z
  |  b ->vm_return
  |
  |8:  // Coroutine returned with error (at co->top-1).
  |.if resume
  |  addli TMP3, TMP3, -8
  |   addi TMP1, zero, LJ_TFALSE
  |  ld AT2, TMP3
  |   addlo AT, L:RA->top		// Remove error from coroutine stack.
  |   st AT, TMP3
  |    addi RD, zero, (2+1)*8
  |   addi AT, BASE, -8+HI
  |   st4 AT, TMP1
  |    addli RA, BASE, -8
  |  st BASE, AT2
  |  andi TMP0, PC, FRAME_TYPE
  |  b <7
  |.else
  |  load_got lj_ffh_coroutine_wrap_err
  |  move CARG2, L:RA
  |  move CARG1, L
  |  call_intern lj_ffh_coroutine_wrap_err  // (lua_State *L, lua_State *co)
  |.endif
  |
  |9:  // Handle stack expansion on return from yield.
  |  load_got lj_state_growstack
  |  shrui CARG2, RD, 3
  |  move CARG1, L
  |  call_intern lj_state_growstack	// (lua_State *L, int n)
  |  move CRET1, zero
  |  b <4
  |.endmacro
  |
  |  coroutine_resume_wrap 1		// coroutine.resume
  |  coroutine_resume_wrap 0		// coroutine.wrap
  |
  |.ffunc coroutine_yield
  |  addlo TMP0, L->cframe
  |  ld TMP0, TMP0
  |   add TMP1, BASE, NARGS8:RC
  |   addlo AT, L->base
  |   st AT, BASE
  |  andi TMP0, TMP0, CFRAME_RESUME
  |   addlo AT, L->top
  |   st AT, TMP1
  |   addi CRET1, zero, LUA_YIELD
  |  beqz TMP0, ->fff_fallback
  |  addlo AT, L->cframe
  |  st AT, zero
  |  addlo AT, L:LREG->status
  |  st1 AT, CRET1
  |  b ->vm_leave_unw
  |
  |//-- Math library -------------------------------------------------------
  |
  |.ffunc_1 math_abs
  |  B_X
  |    B_cmpne_x0 AT, CARG3, TISNUM
  |    B_cmpltu_x1 AT1, CARG3, TISNUM
  |.if DUALNUM
  |  bnez AT, >2
  |  bgez CARG1, ->fff_resi
  |  subx CARG1, zero, CARG1
  |  bltz CARG1, >1
  |  // inline "b ->fff_resi"
  |  B_X
  |    B_v4int_l_x0 CRET1, TISNUM, CRET1
  |    B_addi_x1 PC, BASE, FRAME_PC
  |  B_X
  |    B_addli_x0 RA, BASE, -8
  |    B_ld4s_x1 PC, PC
  |  st RA, CRET1
  |  b ->fff_res1
  |1:
  |  moveli CRET1, -8127
  |  bfextu CRET1, CRET1, 0, 15
  |  B_X
  |    B_revbytes_x0 CRET1, CRET1
  |    B_b_x1 ->fff_resn
  |2:
  |.endif
  |  B_X
  |    B_bfextu_x0 CRET1, CARG1, 0, 62
  |    B_beqz_x1 AT1, ->fff_fallback
  |->fff_resn:
  |  addi PC, BASE, FRAME_PC
  |  B_X
  |    B_addli_x0 RA, BASE, -8
  |    B_ld4s_x1 PC, PC
  |  st RA, CRET1
  |  b ->fff_res1
  |
  |->fff_restv:
  |  // CARG3/CARG1 = TValue result.
  |  addi PC, BASE, FRAME_PC
  |  B_X
  |    B_addi_x0 AT, BASE, -8+HI
  |    B_ld4s_x1 PC, PC
  |  B_Y3
  |    B_addi_y0 RA, BASE, -8
  |    B_addi_y1 AT1, BASE, -8
  |    B_st4_y2 AT, CARG3
  |  st4 AT1, CARG1
  |->fff_res1:
  |  // RA = results, PC = return.
  |  addi RD, zero, (1+1)*8
  |->fff_res:
  |  // RA = results, RD = (nresults+1)*8, PC = return.
  |  B_X
  |    B_andi_x0 TMP0, PC, FRAME_TYPE
  |    B_move_x1 MULTRES, RD
  |  B_X
  |    B_addi_x0 AT, PC, -4
  |    B_bnez_x1 TMP0, ->vm_return
  |  ld4u INS, AT
  |  //decode_RB8a RB, INS
  |  shrui RB, INS, 21
  |  //decode_RB8b RB
  |  bfextu RB, RB, 3, 10
  |  shli RB, RB, 3
  |5:
  |  B_X
  |    B_cmpltu_x0 AT, RD, RB
  |    //decode_RA8a TMP0, INS
  |    B_shrui_x1 TMP0, INS, 5
  |  B_X
  |    B_bfextu_x0 TMP0, TMP0, 3, 10 
  |    B_bnez_x1 AT, >6			// More results expected?
  |  B_X
  |    //decode_RA8b TMP0
  |    B_shli_x0 TMP0, TMP0, 3
  |    //ins_next1
  |    B_ld4u_add_x1 INS, PC, 4
  |  // Adjust BASE. KBASE is assumed to be set for the calling frame.
  |  sub BASE, RA, TMP0
  |  ins_next2
  |
  |6:  // Fill up results with nil.
  |  B_X
  |    B_add_x0 TMP1, RA, RD
  |    B_addli_x1 RD, RD, 8
  |  addi AT, TMP1, -8+HI
  |  st4 AT, TISNIL
  |  b <5
  |
  |.macro math_extern, func
  |->ff_math_ .. func:
  |  B_X
  |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(func)
  |    B_ld_x1 CARG1, BASE
  |  B_X
  |    B_shrsi_x0 CARG3, CARG1, 32
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  B_X
  |    B_cmpltu_x0 AT, CARG3, TISNUM
  |    B_beqz_x1 NARGS8:RC, ->fff_fallback
  |  beqz AT, ->fff_fallback
  |  call_extern
  |  b ->fff_resn
  |.endmacro
  |
  |.macro math_extern2, func
  |  .ffunc_nn math_ .. func
  |  load_got func
  |  call_extern
  |  b ->fff_resn
  |.endmacro
  |
  |.macro math_round, func
  |  .ffunc_n math_ .. func
  |  jal ->vm_ .. func
  |  b ->fff_resn
  |.endmacro
  |
  |  math_round floor
  |  math_round ceil
  |
  |.ffunc math_log
  |  B_X
  |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(log)
  |    B_ld_x1 CARG1, BASE
  |  addi AT, zero, 8
  |  //load_got log
  |  B_X
  |    B_cmpne_x0 AT1, NARGS8:RC, AT
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  shrsi CARG3, CARG1, 32
  |  B_X
  |    B_cmpltu_x0 AT, CARG3, TISNUM
  |    B_bnez_x1 AT1, ->fff_fallback
  |  beqz AT, ->fff_fallback
  |  call_extern
  |  b ->fff_resn
  |
  |  math_extern sqrt
  |  math_extern log10
  |  math_extern exp
  |  math_extern sin
  |  math_extern cos
  |  math_extern tan
  |  math_extern asin
  |  math_extern acos
  |  math_extern atan
  |  math_extern sinh
  |  math_extern cosh
  |  math_extern tanh
  |  math_extern2 pow
  |  math_extern2 atan2
  |  math_extern2 fmod
  |
  |->ff_math_deg:
  |.ffunc_n math_rad
  |  fdouble_unpack_max AT, CARG1, zero
  |  fdouble_unpack_max AT1, CARG2, zero
  |  fdouble_mul_flags CARG1, CARG1, CARG2
  |  mul_hu_lu CARG2, AT, AT1
  |  mul_lu_lu AT4, AT, AT1
  |  mula_hu_lu CARG2, AT1, AT
  |  B_X
  |    B_mul_hu_hu_x0 AT, AT, AT1
  |    B_shli_x1 AT5, CARG2, 32
  |  B_X
  |    B_shrui_x0 CARG2, CARG2, 32
  |    B_add_x1 AT4, AT4, AT5
  |  B_X
  |    B_add_x0 CARG2, AT, CARG2
  |    B_cmpltu_x1 AT5, AT4, AT5
  |  add CARG2, CARG2, AT5
  |  fdouble_pack1 CARG1, CARG2, CARG1
  |  B_X
  |    B_fdouble_pack2_x0 CARG1, CARG2, AT4 // CARG1 is the same as CRET1
  |    B_b_x1 ->fff_resn
  |
  |.ffunc_nn math_ldexp
  |  fixdfsi_inline CARG2, AT, AT1, AT2, AT3
  |  load_got ldexp
  |  call_extern
  |  b ->fff_resn
  |
  |.ffunc_n math_frexp
  |  //load_got frexp
  |  B_X
  |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(frexp)
  |    B_addi_x1 PC, BASE, FRAME_PC
  |  B_X
  |    B_addli_x0 CARG2, DISPATCH, DISPATCH_GL(tmptv)
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  ld4s PC, PC
  |  call_extern
  |  addli TMP1, DISPATCH, DISPATCH_GL(tmptv)
  |  B_X
  |    B_addli_x0 RA, BASE, -8
  |    B_ld_x1 TMP1, TMP1
  |  B_X
  |    B_cmpltsi_x0 AT, TMP1, 0
  |    B_st_x1 RA, CRET1
  |  B_X
  |    B_sub_x0 AT1, zero, TMP1
  |    B_moveli_x1 AT2, 539
  |  B_X
  |    B_cmovnez_x0 TMP1, AT, AT1
  |    B_shli_x1 AT2, AT2, 8
  |  B_X
  |    B_bfins_x0 AT2, AT, 20, 20
  |    B_shli_x1 AT1, TMP1, 4
  |  fdouble_pack1 TMP1, AT1, AT2
  |  B_X
  |    B_fdouble_pack2_x0 TMP1, AT1, zero
  |    B_addi_x1 AT, RA, 8
  |  st AT, TMP1
  |  B_X
  |    B_addi_x0 RD, zero, (2+1)*8
  |    B_b_x1 ->fff_res
  |
  |.ffunc_n math_modf
  |  B_X
  |    //load_got modf
  |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(modf)
  |    B_addi_x1 PC, BASE, FRAME_PC
  |  ld CFUNCADDR, CFUNCADDR
  |  B_X
  |    B_addli_x0 CARG2, BASE, -8
  |    B_ld4s_x1 PC, PC
  |  call_extern
  |  B_X
  |    B_addli_x0 RA, BASE, -8
  |    B_st_x1 BASE, CRET1
  |  B_X
  |    B_addi_x0 RD, zero, (2+1)*8
  |    B_b_x1 ->fff_res
  |
  |.macro math_minmax, name, ismax
  |.if DUALNUM
  |  .ffunc_1 name
  |  B_X
  |    B_cmpne_x0 AT, CARG3, TISNUM
  |    B_cmpltu_x1 AT1, CARG3, TISNUM
  |  B_X
  |    B_addi_x0 TMP1, BASE, 8
  |    B_add_x1 TMP2, BASE, NARGS8:RC
  |  bnez AT, >4
  |1:  // Handle integers.
  |  B_X
  |    B_cmpleu_x0 AT, TMP2, TMP1
  |    B_ld_x1 CARG2, TMP1
  |  bnez AT, ->fff_resi
  |  B_X
  |    B_bfexts_x0 CARG2, CARG2, 0, 31
  |    B_shrsi_x1 CARG4, CARG2, 32
  |  B_X
  |    B_cmpne_x0 AT, CARG2, TISNUM
  |    B_cmpltu_x1 AT1, CARG2, TISNUM
  |  B_X
  |    B_cmplts_x0 AT, CARG1, CARG2
  |    B_bnez_x1 AT, >3
  |.if ismax
  |  B_X
  |    B_cmoveqz_x0 CARG1, AT, CARG2
  |    B_addi_x1 TMP1, TMP1, 8
  |.else
  |  B_X
  |    B_cmovnez_x0 CARG1, AT, CARG2
  |    B_addi_x1 TMP1, TMP1, 8
  |.endif
  |  b <1
  |3:
  |  beqz AT1, ->fff_fallback
  |  // Convert intermediate result to number and continue below.
  |  fixsidf_inline CARG1, AT, AT1, AT2
  |  ld CARG2, TMP1
  |  b >6
  |4:
  |  ld CARG1, BASE
  |  beqz AT1, ->fff_fallback
  |5:  // Handle numbers.
  |  B_X
  |    B_cmpleu_x0 AT, TMP2, TMP1
  |    B_ld_x1 CARG2, TMP1
  |  B_X
  |    B_shrsi_x0 CARG4, CARG2, 32
  |    B_bnez_x1 AT, ->fff_resn
  |  B_X
  |    B_cmpltu_x0 AT, CARG4, TISNUM
  |    B_cmpne_x1 AT1, CARG4, TISNUM
  |  beqz AT, >7
  |6:
  |.if ismax
  |  fdouble_add_flags AT, CARG2, CRET1
  |  bfextu AT, AT, 26, 26
  |.else
  |  fdouble_add_flags AT, CRET1, CARG2
  |  bfextu AT, AT, 26, 26
  |.endif
  |  B_X
  |    B_cmoveqz_x0 CRET1, AT, CARG2
  |    B_addi_x1 TMP1, TMP1, 8
  |  b <5
  |7:  // Convert integer to number and continue above.
  |  B_X
  |    B_bfexts_x0 CARG2, CARG2, 0, 31
  |    B_bnez_x1 AT1, ->fff_fallback
  |  fixsidf_inline CARG2, AT, AT1, AT2
  |  b <6
  |.else
  |->ff_ .. name:
  |  B_X
  |    B_addi_x0 CARG3, BASE, HI
  |    B_ld_x1 CRET1, BASE
  |  ld4s CARG3, CARG3
  |  beqz NARGS8:RC, ->fff_fallback
  |  B_X
  |    B_cmpltu_x0 AT, CARG3, TISNUM
  |    B_add_x1 TMP2, BASE, NARGS8:RC
  |  B_X
  |    B_addli_x0 TMP1, BASE, 8
  |    B_beqz_x1 AT, ->fff_fallback
  |  cmpeq AT, TMP1, TMP2
  |  bnez AT, ->fff_resn
  |1:
  |  B_X
  |    B_addi_x0 CARG3, TMP1, HI
  |    B_ld_x1 CARG2, TMP1
  |  B_X
  |    B_addli_x0 TMP1, TMP1, 8
  |    B_ld4s_x1 CARG3, CARG3
  |  cmpltu AT, CARG3, TISNUM
  |  beqz AT, ->fff_fallback
  |.if ismax
  |  fdouble_add_flags AT, CARG2, CRET1
  |  bfextu AT, AT, 26, 26
  |.else
  |  fdouble_add_flags AT, CRET1, CARG2
  |  bfextu AT, AT, 26, 26
  |.endif
  |  cmoveqz CRET1, AT, CARG2
  |  cmpne AT, TMP1, TMP2
  |  bnez AT, <1
  |  b ->fff_resn
  |.endif
  |.endmacro
  |
  |  math_minmax math_min, 0
  |  math_minmax math_max, 1
  |
  |//-- String library -----------------------------------------------------
  |
  |.ffunc_1 string_len
  |  addi AT, zero, LJ_TSTR
  |  cmpne AT, CARG3, AT
  |  B_X
  |    B_addlo_x0 AT1, STR:CARG1->len
  |    B_bnez_x1 AT, ->fff_fallback
  |  ld4u CRET1, AT1
  |  b ->fff_resi
  |
  |.ffunc string_byte			// Only handle the 1-arg case here.
  |.if DUALNUM
  |  ld STR:CARG1, BASE
  |  B_X
  |    B_xori_x0 AT, NARGS8:RC, 8
  |    B_shrsi_x1 CARG3, CARG1, 32
  |  B_X
  |    B_addli_x0 CARG3, CARG3, -LJ_TSTR
  |    B_or_x1 AT, AT, CARG3
  |  B_X
  |    B_addlo_x0 TMP0, STR:CARG1->len
  |    B_bnez_x1 AT, ->fff_fallback		// Need exactly 1 string argument.
  |  B_X
  |    B_addlo_x0 CARG1, STR:CARG1[1]		// Access is always ok (NUL at end).
  |    B_ld4u_x1 TMP0, TMP0
  |  B_Y1
  |    B_addi_y0 RA, BASE, -8
  |    B_addi_y1 PC, BASE, FRAME_PC
  |    B_ld1u_y2 CARG1, CARG1
  |  B_X
  |    B_addi_x0 RD, zero, 8
  |    B_ld4s_x1 PC, PC
  |  beqz TMP0, ->fff_res
  |  b ->fff_resi
  |.else
  |  B_X
  |    B_addi_x0 CARG3, BASE, HI
  |    B_ld4s_x1 STR:CARG1, BASE
  |  B_X
  |    B_xori_x0 AT, NARGS8:RC, 8
  |    B_ld4s_x1 CARG3, CARG3
  |  addli CARG3, CARG3, -LJ_TSTR
  |  or AT, AT, CARG3
  |  B_X
  |    B_addlo_x0 AT1, STR:CARG1->len
  |    B_bnez_x1 AT, ->fff_fallback		// Need exactly 1 string argument.
  |  B_X
  |    B_addlo_x0 TMP1, STR:CARG1[1]		// Access is always ok (NUL at end).
  |    B_ld4u_x1 TMP0, AT1
  |  B_X
  |    B_addli_x0 RA, BASE, -8
  |    B_ld1u_x1 TMP1, TMP1
  |  cmpltu RD, r0, TMP0
  |  B_X
  |    B_addli_x0 RD, RD, 1
  |    B_cmpltsi_x1 AT, TMP1, 0
  |  B_X
  |    B_sub_x0 AT1, zero, TMP1
  |    B_moveli_x1 AT2, 539
  |  B_X
  |    B_cmovnez_x0 TMP1, AT, AT1
  |    B_shli_x1 AT2, AT2, 8
  |  B_X
  |    B_bfins_x0 AT2, AT, 20, 20
  |    B_shli_x1 AT1, TMP1, 4
  |  fdouble_pack1 TMP1, AT1, AT2
  |  B_X
  |    B_fdouble_pack2_x0 TMP1, AT1, zero
  |    B_addi_x1 PC, BASE, FRAME_PC
  |  B_X
  |    B_shli_x0 RD, RD, 3			// RD = ((str->len != 0)+1)*8
  |    B_ld4s_x1 PC, PC
  |  st RA, TMP1
  |  b ->fff_res
  |.endif
  |
  |.ffunc string_char			// Only handle the 1-arg case here.
  |.if DUALNUM
  |  ffgccheck
  |  B_X
  |    B_addi_x0 AT2, zero, 1
  |    B_ld_x1 TMP0, BASE
  |  B_X
  |    B_cmpeqi_y0 AT, NARGS8:RC, 8
  |    B_shli_y1 AT2, AT2, 8 // 256
  |  shrsi CARG3, TMP0, 32
  |  B_X
  |    B_cmpne_x0 AT1, CARG3, TISNUM
  |    B_beqz_x1 AT, ->fff_fallback
  |  B_X
  |    B_addi_x0 CARG3, zero, 1
  |    B_bnez_x1 AT1, ->fff_fallback
  |  B_X
  |    B_cmpltu_x0 AT, TMP0, AT2
  |    B_addi_x1 CARG2, sp, SAVE_MULTRES
  |  st4 CARG2, TMP0
  |  beqz AT, ->fff_fallback
  |.else
  |  ffgccheck
  |  B_X
  |    B_addi_x0 CARG3, BASE, HI
  |    B_ld_x1 CARG1, BASE
  |  B_X
  |    B_addi_x0 AT, zero, 8
  |    B_ld4s_x1 CARG3, CARG3
  |  moveli AT1, (short)((LJ_TISNUM >> 16) & 0xFFFF)
  |  shl16insli AT1, AT1, (short)(LJ_TISNUM & 0xFFFF)
  |  B_X
  |    B_cmpltu_x0 AT1, CARG3, AT1
  |    B_cmpne_x1 AT, NARGS8:RC, AT
  |  bnez AT, ->fff_fallback
  |  B_X
  |    B_addi_x0 CARG3, zero, 1
  |    B_beqz_x1 AT1, ->fff_fallback
  |  fixdfsi_inline CARG1, AT2, AT3, AT4, AT5
  |  B_X
  |    B_move_x0 TMP1, CRET1
  |    B_addli_x1 AT, zero, 256
  |  B_X
  |    B_cmpltu_x0 AT, TMP0, AT
  |    B_addi_x1 CARG2, sp, SAVE_MULTRES
  |  st CARG2, TMP1
  |  beqz AT, ->fff_fallback
  |.endif
  |->fff_newstr:
  |  addli CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_str_new)
  |  B_X
  |    B_addlo_x0 AT, L->base
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  B_X
  |    B_addi_x0 AT1, sp, SAVE_PC
  |    B_st_x1 AT, BASE
  |  B_X
  |    B_move_x0 CARG1, L
  |    B_st_x1 AT1, PC
  |  B_X
  |    B_addlo_x0 CROSSTMP1, L->base
  |    //call_intern lj_str_new		// (lua_State *L, char *str, size_t l)
  |    B_jalr_x1 CFUNCADDR
  |  B_X
  |    B_move_x0 CARG1, CRET1
  |    B_ld_x1 BASE, CROSSTMP1
  |  B_X
  |    B_addi_x0 CARG3, zero, LJ_TSTR
  |    B_b_x1 ->fff_restv
  |
  |.ffunc string_sub
  |.if DUALNUM
  |  ffgccheck
  |  B_X
  |    B_addi_x0 AT3, BASE, 8
  |    B_ld_x1 STR:CARG1, BASE
  |  B_X
  |    B_addi_x0 AT1, BASE, 16
  |    B_ld_x1 AT3, AT3
  |  B_X
  |    B_addi_x0 AT, NARGS8:RC, -16
  |    B_ld_x1 AT1, AT1
  |  B_X
  |    B_bfexts_x0 CARG1, CARG1, 0, 31
  |    B_shrsi_x1 TMP0, CARG1, 32
  |  B_X
  |    B_bfexts_x0 AT3, AT3, 0, 31
  |    B_shrsi_x1 CARG2, AT3, 32
  |  B_X
  |    B_bfexts_x0 AT1, AT1, 0, 31
  |    B_shrsi_x1 CARG3, AT1, 32
  |  B_X
  |    B_addi_x0 CARG4, zero, -1
  |    B_bltz_x1 AT, ->fff_fallback
  |  B_X
  |    B_cmpne_x0 AT, CARG3, TISNUM
  |    B_beqz_x1 AT, >1
  |  B_X
  |    B_move_x0 CARG4, AT1
  |    B_bnez_x1 AT, ->fff_fallback
  |1:
  |  B_X
  |    B_move_x0 CARG3, AT3
  |    B_cmpne_x1 AT1, CARG2, TISNUM
  |  B_X
  |    B_addlo_x0 CARG2, STR:CARG1->len
  |    B_bnez_x1 AT1, ->fff_fallback
  |  B_X
  |    B_cmpeqi_x0 AT, TMP0, -5 // LJ_TSTR
  |    B_ld4u_x1 CARG2, CARG2
  |  beqz AT, ->fff_fallback
  |  // STR:CARG1 = str, CARG2 = str->len, CARG3 = start, CARG4 = end
  |  B_X
  |    B_cmplts_x0 AT, CARG4, zero
  |    B_addli_x1 TMP0, CARG2, 1
  |  B_X
  |    B_add_x0 TMP1, CARG4, TMP0
  |    B_cmplts_x1 TMP3, CARG3, zero
  |  B_X
  |    B_cmovnez_x0 CARG4, AT, TMP1
  |    B_add_x1 TMP1, CARG3, TMP0
  |  B_X
  |    B_cmovnez_x0 CARG3, TMP3, TMP1
  |    B_addi_x1 TMP2, zero, 1
  |  B_X
  |    B_cmplts_x0 AT, CARG4, zero
  |    B_cmplts_x1 TMP3, zero, CARG3
  |  cmovnez CARG4, AT, zero
  |  B_X
  |    B_cmoveqz_x0 CARG3, TMP3, TMP2		// if (start < 1) start = 1
  |    B_cmplts_x1 AT, CARG2, CARG4
  |  B_X
  |    B_cmovnez_x0 CARG4, AT, CARG2
  |    B_add_x1 CARG2, STR:CARG1, CARG3
  |  B_X
  |    B_sub_x0 CARG3, CARG4, CARG3		// len = end - start
  |    B_addli_x1 CARG2, CARG2, sizeof(GCstr)-1
  |  addli CARG3, CARG3, 1		// len++
  |  bgez CARG3, ->fff_newstr
  |->fff_emptystr:  // Return empty string.
  |  B_X
  |    B_addli_x0 STR:CARG1, DISPATCH, DISPATCH_GL(strempty)
  |    B_addi_x1 CARG3, zero, LJ_TSTR
  |  b ->fff_restv
  |.else
  |  ffgccheck
  |  B_X
  |    B_addli_x0 AT, NARGS8:RC, -16
  |    B_addi_x1 CARG3, BASE, 16+HI
  |  B_X
  |    B_addi_x0 AT2, BASE, 16
  |    B_ld4s_x1 CARG3, CARG3
  |  B_X
  |    B_addi_x0 TMP0, BASE, HI
  |    B_ld_x1 AT2, AT2
  |  ld4s TMP0, TMP0
  |  ld4s STR:CARG1, BASE
  |  B_X
  |    B_addi_x0 CARG2, BASE, 8+HI
  |    B_bltz_x1 AT, ->fff_fallback
  |  B_X
  |    B_addi_x0 AT3, BASE, 8
  |    B_ld4s_x1 CARG2, CARG2
  |  B_X
  |    B_addi_x0 CARG4, zero, -1
  |    B_ld_x1 AT3, AT3
  |  beqz AT, >1
  |   //cvt.w.d f0, f0
  |  fixdfsi_inline AT2, TMP1, AT4, AT5, AT6
  |  B_X
  |    B_move_x0 CARG4, AT2
  |    B_moveli_x1 TMP1, (short)((LJ_TISNUM >> 16) & 0xFFFF)
  |  shl16insli TMP1, TMP1, (short)(LJ_TISNUM & 0xFFFF)
  |  cmpltu AT, CARG3, TMP1
  |  beqz AT, ->fff_fallback
  |1:
  |  cmpltu AT1, CARG2, TMP1
  |  beqz AT1, ->fff_fallback
  |  //cvt.w.d f2, f2
  |  fixdfsi_inline AT3, AT2, AT4, AT5, AT6
  |  B_X
  |    B_move_x0 CARG3, AT3
  |    B_addlo_x1 CARG2, STR:CARG1->len
  |  B_X
  |    B_addi_x0 AT, zero, LJ_TSTR
  |    B_ld4u_x1 CARG2, CARG2
  |  cmpne AT, TMP0, AT
  |  bnez AT, ->fff_fallback
  |  // STR:CARG1 = str, CARG2 = str->len, CARG3 = start, CARG4 = end
  |  B_X
  |    B_cmplts_x0 AT, CARG4, zero
  |    B_addli_x1 TMP0, CARG2, 1
  |  B_X
  |    B_add_x0 TMP1, CARG4, TMP0
  |    B_cmplts_x1 TMP3, CARG3, zero
  |  B_X
  |    B_cmovnez_x0 CARG4, AT, TMP1
  |    B_add_x1 TMP1, CARG3, TMP0
  |  B_X
  |    B_cmovnez_x0 CARG3, TMP3, TMP1
  |    B_addi_x1 TMP2, zero, 1
  |  B_X
  |    B_cmplts_x0 AT, CARG4, zero
  |    B_cmplts_x1 TMP3, zero, CARG3
  |  cmovnez CARG4, AT, zero
  |  B_X
  |    B_cmoveqz_x0 CARG3, TMP3, TMP2		// if (start < 1) start = 1
  |    B_cmplts_x1 AT, CARG2, CARG4
  |  B_X
  |    B_cmovnez_x0 CARG4, AT, CARG2
  |    B_add_x1 CARG2, STR:CARG1, CARG3
  |  B_X
  |    B_sub_x0 CARG3, CARG4, CARG3		// len = end - start
  |    B_addli_x1 CARG2, CARG2, sizeof(GCstr)-1
  |  addli CARG3, CARG3, 1		// len++
  |  bgez CARG3, ->fff_newstr
  |->fff_emptystr:  // Return empty string.
  |  B_X
  |    B_addli_x0 STR:CARG1, DISPATCH, DISPATCH_GL(strempty)
  |    B_addi_x1 CARG3, zero, LJ_TSTR
  |  b ->fff_restv
  |.endif
  |
  |.ffunc string_rep			// Only handle the 1-char case inline.
  |.if DUALNUM
  |  ffgccheck
  |  B_X
  |    B_addi_x0 CARG3, BASE, 8
  |    B_ld_x1 STR:CARG1, BASE
  |  B_X
  |    B_addli_x0 AT, NARGS8:RC, -16		// Exactly 2 arguments.
  |    B_ld_x1 CARG3, CARG3
  |  B_X
  |    B_bfexts_x0 STR:CARG1, STR:CARG1, 0, 31
  |    B_shrsi_x1 TMP0, STR:CARG1, 32
  |  B_X
  |    B_addi_x0 TMP0, TMP0, -LJ_TSTR
  |    B_shrsi_x1 CARG4, CARG3, 32
  |  B_X
  |    B_bfexts_x0 CARG3, CARG3, 0, 31
  |    B_or_x1 AT, AT, TMP0
  |  cmpne AT1, CARG4, TISNUM
  |  B_X
  |    B_addlo_x0 TMP0, STR:CARG1->len
  |    B_bnez_x1 AT, ->fff_fallback
  |  ld4u TMP0, TMP0
  |  B_X
  |    B_addli_x0 TMP1, DISPATCH, DISPATCH_GL(tmpbuf.sz)
  |    B_bnez_x1 AT1, ->fff_fallback
  |  B_X
  |    B_addi_x0 AT, zero, 1
  |    B_ld4u_x1 TMP1, TMP1
  |  B_X
  |    B_cmpltu_x0 AT, AT, TMP0
  |    B_blez_x1 CARG3, ->fff_emptystr	// Count <= 0?
  |  cmpltu TMP0, TMP1, CARG3
  |  B_X
  |    B_or_x0 AT, AT, TMP0
  |    B_beqz_x1 TMP0, ->fff_emptystr		// Zero length string?
  |  addli CARG2, DISPATCH, DISPATCH_GL(tmpbuf.buf)
  |  B_X
  |    B_addlo_x0 TMP0, STR:CARG1[1]
  |    B_ld_x1 CARG2, CARG2
  |  ld1u TMP0, TMP0
  |  B_X
  |    B_add_x0 TMP2, CARG2, CARG3
  |    B_bnez_x1 AT, ->fff_fallback		// Fallback for > 1-char strings.
  |1:  // Fill buffer with char. Yes, this is suboptimal code (do you care?).
  |  B_X
  |    B_addli_x0 TMP2, TMP2, -1
  |    B_cmpltu_x1 AT, CARG2, TMP2
  |  st1 TMP2, TMP0
  |  bnez AT, <1
  |  b ->fff_newstr
  |.else
  |  ffgccheck
  |  B_X
  |    B_addi_x0 TMP0, BASE, HI
  |    B_addi_x1 CARG4, BASE, 8+HI
  |  B_X
  |    B_addli_x0 AT, NARGS8:RC, -16		// Exactly 2 arguments.
  |    B_ld4s_x1 TMP0, TMP0
  |  B_X
  |    B_addi_x0 STR:CARG1, BASE, LO
  |    B_ld4s_x1 CARG4, CARG4
  |  B_X
  |    B_addli_x0 TMP0, TMP0, -LJ_TSTR
  |    B_ld4s_x1 STR:CARG1, STR:CARG1
  |  B_X
  |    B_addi_x0 AT2, BASE, 8
  |    B_or_x1 AT, AT, TMP0
  |  B_X
  |    B_moveli_x0 AT1, (short)((LJ_TISNUM >> 16) & 0xFFFF)
  |    B_ld_x1 AT2, AT2
  |  shl16insli AT1, AT1, (short)(LJ_TISNUM & 0xFFFF)
  |  B_X
  |    B_cmpltu_x0 AT1, CARG4, AT1
  |    B_bnez_x1 AT, ->fff_fallback
  |  //cvt.w.d f0, f0
  |  fixdfsi_inline AT2, AT3, AT4, AT5, AT6
  |  B_X
  |    B_move_x0 CARG3, AT2
  |    B_addlo_x1 TMP0, STR:CARG1->len
  |  ld4u TMP0, TMP0
  |  B_X
  |    B_addli_x0 TMP1, DISPATCH, DISPATCH_GL(tmpbuf.sz)
  |    B_beqz_x1 AT1, ->fff_fallback
  |  B_X
  |    B_addi_x0 AT, zero, 1
  |    B_ld4u_x1 TMP1, TMP1
  |  B_X
  |    B_cmpltu_x0 AT, AT, TMP0
  |    B_blez_x1 CARG3, ->fff_emptystr	// Count <= 0?
  |  cmpltu TMP0, TMP1, CARG3
  |  B_X
  |    B_or_x0 AT, AT, TMP0
  |    B_beqz_x1 TMP0, ->fff_emptystr		// Zero length string?
  |  addli CARG2, DISPATCH, DISPATCH_GL(tmpbuf.buf)
  |  B_X
  |    B_addlo_x0 TMP0, STR:CARG1[1]
  |    B_ld_x1 CARG2, CARG2
  |  ld1u TMP0, TMP0
  |  B_X
  |    B_add_x0 TMP2, CARG2, CARG3
  |    B_bnez_x1 AT, ->fff_fallback		// Fallback for > 1-char strings.
  |1:  // Fill buffer with char. Yes, this is suboptimal code (do you care?).
  |  B_X
  |    B_addli_x0 TMP2, TMP2, -1
  |    B_cmpltu_x1 AT, CARG2, TMP2
  |  st1 TMP2, TMP0
  |  bnez AT, <1
  |  b ->fff_newstr
  |.endif
  |
  |.ffunc string_reverse
  |  ffgccheck
  |  B_X
  |    B_addi_x0 AT, zero, LJ_TSTR
  |    B_ld_x1 STR:CARG1, BASE
  |  B_X
  |    B_addli_x0 TMP1, DISPATCH, DISPATCH_GL(tmpbuf.sz)
  |    B_beqz_x1 NARGS8:RC, ->fff_fallback
  |  B_X
  |    B_shrsi_x0 CARG3, STR:CARG1, 32
  |    B_ld4u_x1 TMP1, TMP1
  |  B_X
  |    B_bfexts_x0 STR:CARG1, STR:CARG1, 0, 31
  |    B_cmpne_x1 AT, CARG3, AT
  |  B_X
  |    B_addlo_x0 CARG3, STR:CARG1->len
  |    B_bnez_x1 AT, ->fff_fallback
  |  B_X
  |    B_addli_x0 CARG1, STR:CARG1, #STR
  |    B_ld4u_x1 CARG3, CARG3
  |  addli CARG2, DISPATCH, DISPATCH_GL(tmpbuf.buf)
  |  B_X
  |    B_cmpltu_x0 AT, TMP1, CARG3
  |    B_ld_x1 CARG2, CARG2
  |  B_X
  |    B_add_x0 TMP3, CARG1, CARG3
  |    B_bnez_x1 AT, ->fff_fallback
  |  add CARG4, CARG2, CARG3
  |1:  // Reverse string copy.
  |  B_X
  |    B_cmpltu_x0 AT, CARG1, TMP3
  |    B_ld1u_x1 TMP1, CARG1
  |  B_X
  |    B_addli_x0 CARG1, CARG1, 1
  |    B_beqz_x1 AT, ->fff_newstr
  |  addli CARG4, CARG4, -1
  |  st1 CARG4, TMP1
  |  b <1
  |
  |.macro ffstring_case, name, lo
  |  .ffunc name
  |  ffgccheck
  |  addi CARG3, BASE, HI
  |  B_X
  |    B_addi_x0 STR:CARG1, BASE, LO
  |    B_ld4s_x1 CARG3, CARG3
  |  B_X
  |    B_addi_x0 AT, zero, LJ_TSTR
  |    B_ld4s_x1 STR:CARG1, STR:CARG1
  |  B_X
  |    B_addli_x0 TMP1, DISPATCH, DISPATCH_GL(tmpbuf.sz)
  |    B_beqz_x1 NARGS8:RC, ->fff_fallback
  |  B_X
  |    B_cmpne_x0 AT, CARG3, AT
  |    B_ld4u_x1 TMP1, TMP1
  |  B_X
  |    B_addlo_x0 CARG3, STR:CARG1->len
  |    B_bnez_x1 AT, ->fff_fallback
  |  B_X
  |    B_addli_x0 CARG1, STR:CARG1, #STR
  |    B_ld4u_x1 CARG3, CARG3
  |  addli CARG2, DISPATCH, DISPATCH_GL(tmpbuf.buf)
  |  B_X
  |    B_cmpltu_x0 AT, TMP1, CARG3
  |    B_ld_x1 CARG2, CARG2
  |  B_X
  |    B_add_x0 TMP3, CARG1, CARG3
  |    B_bnez_x1 AT, ->fff_fallback
  |  move CARG4, CARG2
  |1:  // ASCII case conversion.
  |  B_X
  |    B_cmpltu_x0 AT, CARG1, TMP3
  |    B_ld1u_x1 TMP1, CARG1
  |  B_X
  |    B_addli_x0 TMP0, TMP1, -lo
  |    B_beqz_x1 AT, ->fff_newstr
  |  B_X
  |    B_xori_x0 TMP2, TMP1, 0x20
  |    B_cmpltui_x1 AT, TMP0, 26
  |  B_X
  |    B_cmovnez_x0 TMP1, AT, TMP2
  |    B_addli_x1 CARG1, CARG1, 1
  |  st1 CARG4, TMP1
  |  B_X
  |    B_addli_x0 CARG4, CARG4, 1
  |    B_b_x1 <1
  |.endmacro
  |
  |ffstring_case string_lower, 65
  |ffstring_case string_upper, 97
  |
  |//-- Table library ------------------------------------------------------
  |
  |.ffunc_1 table_getn
  |  B_X
  |    B_addi_x0 AT, zero, LJ_TTAB
  |    //load_got lj_tab_len
  |    B_addli_x1 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_tab_len)
  |  B_X
  |    B_cmpne_x0 AT, CARG3, AT
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  bnez AT, ->fff_fallback
  |  call_intern lj_tab_len		// (GCtab *t)
  |  // Returns uint32_t (but less than 2^31).
  |  b ->fff_resi
  |
  |//-- Bit library --------------------------------------------------------
  |
  |.macro .ffunc_bit, name
  |->ff_bit_..name:
  |.if DUALNUM
  |  ld CARG1, BASE
  |  B_X
  |    B_bfexts_x0 CARG1, CARG1, 0, 31
  |    B_shrsi_x1 CARG3, CARG1, 32
  |  B_X
  |    B_cmpne_x0 AT, CARG3, TISNUM
  |    B_beqz_x1 NARGS8:RC, ->fff_fallback
  |  B_X
  |    B_move_x0 AT5, CARG1
  |    B_beqzt_x1 AT, >9
  |  B_X
  |    B_cmpltu_x0 AT4, TISNUM, CARG3
  |    B_jal_x1 ->fff_tobit_fb
  |9:  
  |.else
  |  B_Y2
  |    B_addi_y0 CARG3, BASE, HI
  |    B_move_y1 AT, TOBIT
  |    B_ld_y2 CARG1, BASE
  |  B_X
  |    B_fdouble_add_flags_x0  AT1, CARG1, AT
  |    B_ld4s_x1 CARG3, CARG3
  |  B_X
  |    B_moveli_x0 AT3, (short)((LJ_TISNUM >> 16) & 0xFFFF)
  |    B_beqz_x1 NARGS8:RC, ->fff_fallback
  |  B_X
  |    B_fdouble_unpack_min_x0 AT2, CARG1, AT
  |    B_shl16insli_x1 AT3, AT3, (short)(LJ_TISNUM & 0xFFFF)
  |  B_X
  |    B_fdouble_unpack_max_x0 AT,  CARG1, AT
  |    B_cmpltu_x1 AT3, CARG3, AT3
  |  B_X
  |    B_fdouble_addsub_x0 AT, AT2, AT1
  |    B_beqz_x1 AT3, ->fff_fallback
  |  //add.d FARG1, FARG1, TOBIT
  |  fdouble_pack1 CARG1, AT, AT1
  |  fdouble_pack2 CARG1, AT, zero
  |  bfexts AT5, CARG1, 0, 31
  |.endif
  |.endmacro
  |
  |.macro .ffunc_bit_op, name, ins
  |  .ffunc_bit name
  |.if DUALNUM
  |  B_X
  |    B_addli_x0 TMP1, BASE, 8
  |    B_add_x1 TMP2, BASE, NARGS8:RC
  |1:
  |  B_X
  |    B_cmpeq_x0 AT3, TMP1, TMP2
  |    B_ld_x1 CARG1, TMP1
  |  B_X
  |    B_bfexts_x0 CARG1, CARG1, 0, 31
  |    B_shrsi_x1 CARG4, CARG1, 32
  |  B_X
  |    B_cmpne_x0 AT3, CARG4, TISNUM
  |    B_bnez_x1 AT3, ->fff_resi
  |  B_X
  |    B_cmpltu_x0 AT4, TISNUM, CARG4
  |    B_bnez_x1 AT3, ->fff_bitop_fb
  |  ins CRET1, AT5, CARG1
  |  B_X
  |    B_addi_x0 TMP1, TMP1, 8
  |    B_b_x1 <1
  |.else
  |  B_X
  |    B_addli_x0 TMP1, BASE, 8
  |    B_add_x1 TMP2, BASE, NARGS8:RC
  |1:
  |  B_X
  |    B_addi_x0 CARG4, TMP1, HI
  |    B_move_x1 AT, TOBIT
  |  B_X
  |    B_fdouble_add_flags_x0  AT1, CARG1, AT
  |    B_ld4s_x1 CARG4, CARG4
  |  B_X
  |    B_moveli_x0 AT3, (short)((LJ_TISNUM >> 16) & 0xFFFF)
  |    B_ld_x1 CARG1, TMP1
  |  B_X
  |    B_cmpeq_x0 AT4, TMP1, TMP2
  |    B_shl16insli_x1 AT3, AT3, (short)(LJ_TISNUM & 0xFFFF)
  |  B_X
  |    B_fdouble_unpack_min_x0 AT2, CARG1, AT
  |    B_bnez_x1 AT4, ->fff_resi
  |  B_X
  |    B_fdouble_unpack_max_x0 AT,  CARG1, AT
  |    B_cmpltu_x1 AT4, CARG4, AT3
  |  B_X
  |    B_fdouble_addsub_x0 AT, AT2, AT1
  |    B_beqz_x1 AT4, ->fff_fallback
  |  //add.d FARG1, FARG1, TOBIT
  |  //mfc1 CARG2, FARG1
  |  fdouble_pack1 CARG1, AT, AT1
  |  fdouble_pack2 CARG1, AT, zero
  |  bfexts CARG2, CARG1, 0, 31
  |  ins CRET1, AT5, CARG2
  |  B_X
  |    B_addli_x0 TMP1, TMP1, 8
  |    B_b_x1 <1
  |.endif
  |.endmacro
  |
  |.ffunc_bit_op band, and
  |.ffunc_bit_op bor, or
  |.ffunc_bit_op bxor, xor
  |
  |.ffunc_bit bswap
  |  revbytes CRET1, AT5
  |  B_X
  |    B_shrsi_x0 CRET1, CRET1, 32
  |    B_b_x1 ->fff_resi
  |
  |.ffunc_bit bnot
  |  B_X
  |    B_nor_x0 CRET1, AT5, zero
  |    B_b_x1 ->fff_resi
  |
  |.macro .ffunc_bit_sh, name, ins, shmod
  |.if DUALNUM
  |  .ffunc_2 bit_..name
  |  B_X
  |    B_cmpne_x0 AT, CARG3, TISNUM
  |    B_cmpltu_x1 AT4, TISNUM, CARG3
  |  B_X
  |    B_move_x0 AT5, CARG1
  |    B_beqz_x1 AT, >1
  |  jal ->fff_tobit_fb
  |1:
  |    cmpne AT, CARG4, TISNUM
  |  B_X
  |    B_move_x0 AT4, CARG2
  |    B_bnez_x1 AT, ->fff_fallback
  |.if shmod == 1
  |  ins CRET1, AT5, AT4
  |  bfexts AT, CRET1, 32, 63
  |  bfexts CRET1, CRET1, 0, 31
  |  B_X
  |    B_or_x0 CRET1, CRET1, AT
  |    B_b_x1 ->fff_resi
  |.elif shmod == 2
  |  addi AT, zero, 32
  |  B_X
  |    B_sub_x0 TMP0, AT, AT4
  |    B_shru_x1 AT4, AT5, AT4
  |  shlx AT5, AT5, TMP0
  |  B_X
  |    ins CRET1, AT5, AT4
  |    B_b_x1 ->fff_resi
  |.else
  |  B_X
  |    ins CRET1, AT5, AT4
  |    B_b_x1 ->fff_resi
  |.endif
  |.else // DUALNUM
  |->ff_bit_..name:
  |  B_X
  |    B_cmpltui_x0 AT6, NARGS8:RC, 16
  |    B_addi_x1 CARG3, BASE, HI
  |  B_X
  |    B_addi_x0 CARG4, BASE, 8+HI
  |    B_ld_x1 CARG1, BASE
  |  B_X
  |    B_move_x0 AT, TOBIT
  |    B_ld4s_x1 CARG4, CARG4
  |  B_X
  |    B_fdouble_add_flags_x0 AT1, CARG1, AT
  |    B_bnez_x1 AT6, ->fff_fallback
  |  B_X
  |    B_addi_x0 AT3, BASE, 8
  |    B_ld4s_x1 CARG3, CARG3
  |  B_X
  |    B_moveli_x0 AT6, (short)((LJ_TISNUM >> 16) & 0xFFFF)
  |    B_ld_x1 CARG2, AT3
  |  B_X
  |    B_fdouble_unpack_min_x0 AT2, CARG1, AT
  |    B_shl16insli_x1 AT6, AT6, (short)(LJ_TISNUM & 0xFFFF)
  |  B_X
  |    B_cmpltu_x0 TMP0, CARG3, AT6
  |    B_cmpltu_x1 TMP1, CARG4, AT6
  |  B_X
  |    B_fdouble_unpack_max_x0 AT,  CARG1, AT
  |    B_and_x1 TMP0, TMP0, TMP1
  |  B_X
  |    B_fdouble_addsub_x0 AT, AT2, AT1
  |    B_beqz_x1 TMP0, ->fff_fallback
  |  fdouble_pack1 CARG1, AT, AT1
  |  fdouble_pack2 CARG1, AT, zero
  |  B_X
  |    B_bfexts_x0 AT5, CARG1, 0, 31
  |    B_move_x1 AT, TOBIT
  |  fdouble_add_flags  AT1, CARG2, AT
  |  fdouble_unpack_min AT2, CARG2, AT
  |  fdouble_unpack_max AT,  CARG2, AT
  |  fdouble_addsub AT, AT2, AT1
  |  fdouble_pack1 CARG2, AT, AT1
  |  fdouble_pack2 CARG2, AT, zero
  |  bfexts AT4, CARG2, 0, 31
  |.if shmod == 1
  |  ins CRET1, AT5, AT4
  |  bfexts AT, CRET1, 32, 63
  |  bfexts CRET1, CRET1, 0, 31
  |  B_X
  |    B_or_x0 CRET1, CRET1, AT
  |    B_b_x1 ->fff_resi
  |.elif shmod == 2
  |  addi AT, zero, 32
  |  sub TMP0, AT, AT4
  |  shru AT4, AT5, AT4
  |  shlx AT5, AT5, TMP0
  |  B_X
  |    ins CRET1, AT5, AT4
  |    B_b_x1 ->fff_resi
  |.else
  |  B_X
  |    ins CRET1, AT5, AT4
  |    B_b_x1 ->fff_resi
  |.endif
  |.endif
  |.endmacro
  |
  |.ffunc_bit_sh lshift, B_shl_x0, 0
  |.ffunc_bit_sh rshift, B_shru_x0, 0
  |.ffunc_bit_sh arshift, B_shrs_x0, 0
  |// Can't use rotrv, since it's only in MIPS32R2.
  |.ffunc_bit_sh rol, rotl, 1
  |.ffunc_bit_sh ror, B_or_x0, 2
  |
  |.ffunc_bit tobit
  |  move CRET1, AT5
  |.if DUALNUM
  |->fff_resi:
  |  B_X
  |    B_v4int_l_x0 CRET1, TISNUM, CRET1
  |    B_addi_x1 PC, BASE, FRAME_PC
  |  B_X
  |    B_addli_x0 RA, BASE, -8
  |    B_ld4s_x1 PC, PC
  |  st RA, CRET1
  |  b ->fff_res1
  |.else
  |->fff_resi:
  |  B_X
  |    B_cmpltsi_x0 AT, CRET1, 0
  |    B_sub_x1 AT1, zero, CRET1
  |  B_X
  |    B_cmovnez_x0 CRET1, AT, AT1
  |    B_moveli_x1 AT2, 539
  |  B_X
  |    B_shli_x0 AT2, AT2, 8
  |    B_shli_x1 AT1, CRET1, 4
  |  bfins AT2, AT, 20, 20
  |  fdouble_pack1 CRET1, AT1, AT2
  |  fdouble_pack2 CRET1, AT1, zero
  |  b ->fff_resn
  |.endif
  |
  |//-----------------------------------------------------------------------
  |
  |->fff_tobit_fb:
  |.if DUALNUM
  |  bnez AT4, ->fff_fallback
  |  B_X
  |    B_move_x0 AT, TOBIT
  |    B_ld_x1 CARG1, BASE
  |  fdouble_add_flags  AT1, CARG1, AT
  |  fdouble_unpack_min AT2, CARG1, AT
  |  fdouble_unpack_max AT,  CARG1, AT
  |  fdouble_addsub AT, AT2, AT1
  |  fdouble_pack1 CARG1, AT, AT1
  |  fdouble_pack2 CARG1, AT, zero
  |  B_X
  |    B_bfexts_x0 AT5, CARG1, 0, 31
  |    B_jr_x1 lr
  |.endif
  |->fff_bitop_fb:
  |.if DUALNUM
  |  bnez AT4, ->fff_fallback
  |  B_X
  |    B_move_x0 AT, TOBIT
  |    B_ld_x1 CARG1, TMP1
  |  fdouble_add_flags  AT1, CARG1, AT
  |  fdouble_unpack_min AT2, CARG1, AT
  |  fdouble_unpack_max AT,  CARG1, AT
  |  fdouble_addsub AT, AT2, AT1
  |  fdouble_pack1 CARG1, AT, AT1
  |  fdouble_pack2 CARG1, AT, zero
  |  B_X
  |    B_bfexts_x0 CARG1, CARG1, 0, 31
  |    B_jr_x1 lr
  |.endif
  |->fff_fallback:			// Call fast function fallback handler.
  |  // BASE = new base, RB = CFUNC, RC = nargs*8
  |  B_X
  |    B_addlo_x0 TMP3, CFUNC:RB->f
  |    B_addi_x1 PC, BASE, FRAME_PC
  |  B_X
  |    B_add_x0 TMP1, BASE, NARGS8:RC
  |    B_ld_x1 TMP3, TMP3
  |  B_X
  |    B_addli_x0 TMP0, TMP1, 8*LUA_MINSTACK
  |    B_ld4s_x1 PC, PC
  |  B_X
  |    B_addlo_x0 TMP2, L:LREG->maxstack
  |    B_addlo_x1 AT2, L->top
  |  B_X
  |    B_addi_x0 AT, sp, SAVE_PC
  |    B_ld4u_x1 TMP2, TMP2
  |  B_X
  |    B_cmpltu_x0 AT, TMP2, TMP0
  |    B_st_x1 AT, PC
  |  B_X
  |    B_addlo_x0 AT1, L->base
  |    B_st_x1 AT2, TMP1
  |  B_X
  |    B_move_x0 CFUNCADDR, TMP3
  |    B_st_x1 AT1, BASE
  |  bnez AT, >5			// Need to grow stack.
  |  B_X
  |    B_move_x0 CARG1, L
  |    B_jalr_x1 TMP3				// (lua_State *L)
  |  // Either throws an error, or recovers and returns -1, 0 or nresults+1.
  |  addlo BASE, L->base
  |  B_X
  |    B_shli_x0 RD, CRET1, 3
  |    B_ld_x1 BASE, BASE
  |  B_X
  |    B_addli_x0 RA, BASE, -8
  |    B_bgtz_x1 CRET1, ->fff_res		// Returned nresults+1?
  |1:  // Returned 0 or -1: retry fast path.
  |  addlo TMP0, L->top
  |  B_X
  |    B_addi_x0 LFUNC:RB, BASE, FRAME_FUNC
  |    B_ld_x1 TMP0, TMP0
  |  B_X
  |    B_sub_x0 NARGS8:RC, TMP0, BASE
  |    B_ld4s_x1 LFUNC:RB, LFUNC:RB
  |  bnez CRET1, ->vm_call_tail		// Returned -1?
  |  ins_callt				// Returned 0: retry fast path.
  |
  |// Reconstruct previous base for vmeta_call during tailcall.
  |->vm_call_tail:
  |  B_X
  |    B_andi_x0 TMP0, PC, FRAME_TYPE
  |    B_addi_x1 AT, zero, -4
  |  B_X
  |    B_and_x0 TMP1, PC, AT
  |    B_bnez_x1 TMP0, >3
  |  addi TMP1, PC, OFS_RA
  |  ld1u TMP1, TMP1
  |  shli TMP1, TMP1, 3
  |  addli TMP1, TMP1, 8
  |3:
  |  B_X
  |    B_sub_x0 TMP2, BASE, TMP1
  |    B_b_x1 ->vm_call_dispatch		// Resolve again for tailcall.
  |
  |5:  // Grow stack for fallback handler.
  |  B_X
  |    //load_got lj_state_growstack
  |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_state_growstack)
  |    B_addi_x1 CARG2, zero, LUA_MINSTACK
  |  B_X
  |    B_move_x0 CARG1, L
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  call_intern lj_state_growstack	// (lua_State *L, int n)
  |  addlo BASE, L->base
  |  B_X
  |    B_move_x0 CRET1, zero			// Force retry.
  |    B_ld_x1 BASE, BASE
  |  b <1
  |
  |->fff_gcstep:			// Call GC step function.
  |  // BASE = new base, RC = nargs*8
  |  B_X
  |    B_move_x0 MULTRES, lr
  |    //load_got lj_gc_step
  |    B_addli_x1 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_gc_step)
  |  B_X
  |    B_addlo_x0 AT, L:LREG->base
  |    B_ld_x1 CFUNCADDR, CFUNCADDR
  |  B_X
  |    B_add_x0 TMP0, BASE, NARGS8:RC
  |    B_st_x1 AT, BASE
  |  addi AT, sp, SAVE_PC
  |  B_X
  |    B_addlo_x0 AT1, L:LREG->top
  |    B_st_x1 AT, PC
  |  st AT1, TMP0
  |  B_X
  |    B_move_x0 CARG1, L
  |    //call_intern lj_gc_step		// (lua_State *L)
  |    B_jalr_x1 CFUNCADDR
  |  B_X
  |    B_addlo_x0 BASE, L:LREG->base
  |    B_addlo_x1 TMP0, L->top
  |  B_X
  |    B_move_x0 lr, MULTRES
  |    B_ld_x1 BASE, BASE
  |  B_X
  |    B_addi_x0 CFUNC:RB, BASE, FRAME_FUNC
  |    B_ld_x1 TMP0, TMP0
  |  B_X
  |    B_sub_x0 NARGS8:RC, TMP0, BASE
  |    B_ld4s_x1 CFUNC:RB, CFUNC:RB
  |  jr lr
  |
  |//-----------------------------------------------------------------------
  |//-- Special dispatch targets -------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_record:				// Dispatch target for recording phase.
  |.if JIT
  |  addli TMP3, DISPATCH, DISPATCH_GL(hookmask)
  |  ld1u TMP3, TMP3
  |  B_X
  |    B_andi_x0 AT, TMP3, HOOK_VMEVENT	// No recording while in vmevent.
  |    // Decrement the hookcount for consistency, but always do the call.
  |    B_addli_x1 TMP2, DISPATCH, DISPATCH_GL(hookcount)
  |  ld4u TMP2, TMP2
  |  B_X
  |    B_andi_x0 AT, TMP3, HOOK_ACTIVE
  |    B_bnez_x1 AT, >5
  |  B_X
  |    B_addli_x0 TMP2, TMP2, -1
  |    B_bnez_x1 AT, >1
  |  andi AT, TMP3, LUA_MASKLINE|LUA_MASKCOUNT
  |  B_X
  |    B_addli_x0 AT, DISPATCH, DISPATCH_GL(hookcount)
  |    B_beqz_x1 AT, >1
  |  st4 AT, TMP2
  |  b >1
  |.endif
  |
  |->vm_rethook:			// Dispatch target for return hooks.
  |  addli TMP3, DISPATCH, DISPATCH_GL(hookmask)
  |  ld1u TMP3, TMP3
  |  andi AT, TMP3, HOOK_ACTIVE		// Hook already active?
  |  beqz AT, >1
  |5:  // Re-dispatch to static ins.
  |  addi AT, TMP0, GG_DISP2STATIC
  |  ld AT, AT
  |  jr AT
  |
  |->vm_inshook:			// Dispatch target for instr/line hooks.
  |  addli TMP3, DISPATCH, DISPATCH_GL(hookmask)
  |  ld1u TMP3, TMP3
  |  addli TMP2, DISPATCH, DISPATCH_GL(hookcount)
  |  ld4u TMP2, TMP2
  |  andi AT, TMP3, HOOK_ACTIVE		// Hook already active?
  |  andi AT, TMP3, LUA_MASKLINE|LUA_MASKCOUNT
  |  bnez AT, <5
  |  addli TMP2, TMP2, -1
  |  beqz AT, <5
  |  addli AT, DISPATCH, DISPATCH_GL(hookcount)
  |  st4 AT, TMP2
  |  beqz TMP2, >1
  |  andi AT, TMP3, LUA_MASKLINE
  |  beqz AT, <5
  |1:
  |  load_got lj_dispatch_ins
  |   addi AT, sp, SAVE_MULTRES
  |   st AT, MULTRES
  |  move CARG2, PC
  |   addlo AT, L->base
  |   st AT, BASE
  |  // SAVE_PC must hold the _previous_ PC. The callee updates it with PC.
  |  move CARG1, L
  |  call_intern lj_dispatch_ins	// (lua_State *L, const BCIns *pc)
  |3:
  |  addlo BASE, L->base
  |  ld BASE, BASE
  |4:  // Re-dispatch to static ins.
  |  addi INS, PC, -4
  |  ld4u INS, INS
  |  decode_OP4a TMP1, INS
  |  decode_OP4b TMP1
  |  add TMP0, DISPATCH, TMP1
  |   decode_RD8a RD, INS
  |  addi AT, TMP0, GG_DISP2STATIC
  |  ld AT, AT
  |   decode_RA8a RA, INS
  |   decode_RD8b RD
  |  jr AT
  |   decode_RA8b RA
  |
  |->cont_hook:				// Continue from hook yield.
  |  addli PC, PC, 4
  |  addi MULTRES, RB, -24+LO
  |  ld4s MULTRES, MULTRES
  |  b <4
  |
  |->vm_hotloop:			// Hot loop counter underflow.
  |.if JIT
  |  addi LFUNC:TMP1, BASE, FRAME_FUNC
  |  ld4s LFUNC:TMP1, LFUNC:TMP1
  |   addli CARG1, DISPATCH, GG_DISP2J
  |   addi AT, sp, SAVE_PC
  |   st AT, PC
  |  addlo TMP1, LFUNC:TMP1->pc
  |  ld4u TMP1, TMP1
  |   move CARG2, PC
  |   addli, AT, DISPATCH, DISPATCH_J(L)
  |   st AT, L
  |  addi TMP1, TMP1, PC2PROTO(framesize)
  |  ld1u TMP1, TMP1
  |  load_got lj_trace_hot
  |   addlo AT, L->base
  |   st AT, BASE
  |  shli TMP1, TMP1, 3
  |  add TMP1, BASE, TMP1
  |  addlo AT, L:LREG->top
  |  st AT, TMP1
  |  call_intern lj_trace_hot		// (jit_State *J, const BCIns *pc)
  |  b <3
  |.endif
  |
  |->vm_callhook:			// Dispatch target for call hooks.
  |  move CARG2, PC
  |.if JIT
  |  b >1
  |.endif
  |
  |->vm_hotcall:			// Hot call counter underflow.
  |.if JIT
  |  ori CARG2, PC, 1
  |1:
  |.endif
  |  load_got lj_dispatch_call
  |  add TMP0, BASE, RC
  |  addi AT, sp, SAVE_PC
  |   st AT, PC
  |   addlo AT, L:LREG->base
  |   st AT, BASE
  |  sub RA, RA, BASE
  |   addlo AT, L:LREG->top
  |   st AT, TMP0
  |  move CARG1, L
  |  call_intern lj_dispatch_call	// (lua_State *L, const BCIns *pc)
  |  // Returns ASMFunction.
  |  addlo BASE, L:LREG->base
  |  ld BASE, BASE
  |   addlo TMP0, L:LREG->top
  |   ld TMP0, TMP0
  |   addi AT, sp, SAVE_PC
  |   st AT, zero
  |  sub NARGS8:RC, TMP0, BASE
  |  add RA, BASE, RA
  |  addi LFUNC:RB, BASE, FRAME_FUNC
  |  ld4s LFUNC:RB, LFUNC:RB
  |  addi AT, PC, -4
  |  ld4u INS, AT
  |  jr CRET1
  |
  |//-----------------------------------------------------------------------
  |//-- Trace exit handler -------------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |.macro savex_, a, b
  |  //sdc1 f..a, 16+a*8(sp)
  |  addli AT, sp, 16+32*8+a*4
  |  st AT, r..a
  |  addli AT, sp, 16+32*8+b*4
  |  st AT, r..b
  |.endmacro
  |
  |->vm_exit_handler:
  |.if JIT
  |  addli sp, sp, -(16+32*8+32*4)
  |  savex_ 0, 1
  |  savex_ 2, 3
  |  savex_ 4, 5
  |  savex_ 6, 7
  |  savex_ 8, 9
  |  savex_ 10, 11
  |  savex_ 12, 13
  |  savex_ 14, 15
  |  savex_ 16, 17
  |  savex_ 18, 19
  |  savex_ 20, 21
  |  savex_ 22, 23
  |  savex_ 24, 25
  |  savex_ 26, 27
  |  //sdc1 f28, 16+28*8(sp)
  |  addli AT, sp, 16+32*8+28*4
  |  st AT, r28
  |  //sdc1 f30, 16+30*8(sp)
  |  addli AT, sp, 16+32*8+30*4
  |  st AT, r30
  |  addli AT, sp, 16+32*8+31*4
  |  st AT, r0
  |  li_vmstate EXIT
  |   addli TMP2, sp, 16+32*8+32*4	// Recompute original value of sp.
  |  addli DISPATCH, JGL, -GG_DISP2G-32768
  |  ld TMP1, TMP2			// Load exit number.
  |  st_vmstate
  |   addli AT, sp, 16+32*8+29*4
  |   st AT, TMP2
  |  addli L, DISPATCH, DISPATCH_GL(jit_L)
  |  ld L, L
  |  addli BASE, DISPATCH, DISPATCH_GL(jit_base)
  |  ld BASE, BASE
  |  load_got lj_trace_exit
  |  addli AT, DISPATCH, DISPATCH_J(L)
  |  st AT, L
  |  addli AT, DISPATCH, DISPATCH_J(parent)
  |  st AT, lr
  |  addli AT, DISPATCH, DISPATCH_J(exitno)
  |  st4 AT, TMP1
  |  addli CARG1, DISPATCH, GG_DISP2J
  |  addlo AT, L->base
  |  st AT, BASE
  |  addli CARG2, sp, 16
  |  call_intern lj_trace_exit		// (jit_State *J, ExitState *ex)
  |  // Returns MULTRES (unscaled) or negated error code.
  |  addlo TMP1, L->cframe
  |  ld TMP1, TMP1
  |  addi AT, zero, -4
  |   addlo BASE, L->base
  |   ld BASE, BASE
  |  and sp, TMP1, AT
  |   ld PC, sp
  |  addli AT, L, SAVE_L
  |  st AT, L
  |  b >1
  |.endif
  |->vm_exit_interp:
  |.if JIT
  |  // CRET1 = MULTRES or negated error code, BASE, PC and JGL set.
  |  addli L, sp, SAVE_L
  |  ld L, L
  |  addli DISPATCH, JGL, -GG_DISP2G-32768
  |1:
  |  addi LFUNC:TMP1, BASE, FRAME_FUNC
  |  ld4s LFUNC:TMP1, LFUNC:TMP1
  |  bltz CRET1, >3			// Check for error from exit.
  |  moveli TOBIT, 14403
  |  revbytes TOBIT, TOBIT
  |  shli MULTRES, CRET1, 3
  |    addi TISNIL, zero, LJ_TNIL
  |    movei TISNUM, -2
  |    shl16insli TISNUM, TISNUM, -1
  |   addi AT, sp, SAVE_MULTRES
  |  st AT, MULTRES
  |  addlo TMP1, LFUNC:TMP1->pc
  |  ld4u TMP1, TMP1
  |   addli AT, DISPATCH, DISPATCH_GL(jit_L)
  |   st4 AT, zero
  |  addi KBASE, TMP1, PC2PROTO(k)
  |  ld4u KBASE, KBASE
  |  // Modified copy of ins_next which handles function header dispatch, too.
  |  ld INS, PC
  |   addli PC, PC, 4
  |    // Assumes TISNIL == ~LJ_VMST_INTERP == -1
  |    addli AT, DISPATCH, DISPATCH_GL(vmstate)
  |    st4 AT, TISNIL
  |  decode_OP4a TMP1, INS
  |  decode_OP4b TMP1
  |    cmpltui TMP2, TMP1, BC_FUNCF*4	// Function header?
  |  add TMP0, DISPATCH, TMP1
  |   decode_RD8a RD, INS
  |  ld AT, TMP0
  |   decode_RA8a RA, INS
  |  decode_RA8b RA
  |    beqz TMP2, >2
  |  decode_RD8b RD
  |  jr AT
  |2:
  |  addli RC, MULTRES, -8
  |  add RA, RA, BASE
  |  jr AT
  |
  |3:  // Rethrow error from the right C frame.
  |  load_got lj_err_throw
  |  //negu CARG2, CRET1
  |  move CARG1, L
  |  call_intern lj_err_throw		// (lua_State *L, int errcode)
  |.endif
  |
  |//-----------------------------------------------------------------------
  |//-- Math helper functions ----------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |->vm_floor:
  |  math_extern floor
  |->vm_ceil:
  |  math_extern ceil
  |->vm_trunc:
  |.if JIT
  |  math_extern trunc
  |.endif
  |
  |//-----------------------------------------------------------------------
  |//-- Miscellaneous functions --------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |//-----------------------------------------------------------------------
  |//-- FFI helper functions -----------------------------------------------
  |//-----------------------------------------------------------------------
  |
  |// Handler for callback functions. Callback slot number in r1, g in r2.
  |->vm_ffi_callback:
  |.if FFI
  |.type CTSTATE, CTState, PC
  |  saveregs
  |  addlo CTSTATE, GL:r2->ctype_state
  |  ld4u CTSTATE, CTSTATE
  |   addli DISPATCH, r2, GG_G2DISP
  |  load_got lj_ccallback_enter
  |  addlo AT, CTSTATE->cb.slot
  |  st AT, r1
  |  addlo AT, CTSTATE->cb.gpr[0]
  |  st AT, CARG1
  |  addlo AT, CTSTATE->cb.gpr[1]
  |  st AT, CARG2
  |   //sdc1 FARG1, CTSTATE->cb.fpr[0]
  |  addlo AT, CTSTATE->cb.gpr[2]
  |  st AT, CARG3
  |  addlo AT, CTSTATE->cb.gpr[3]
  |  st AT, CARG4
  |   //sdc1 FARG2, CTSTATE->cb.fpr[1]
  |  addli TMP0, sp, CFRAME_SPACE+16
  |  addlo AT, CTSTATE->cb.stack
  |  st AT, TMP0
  |  addi AT, sp, SAVE_PC
  |  st AT, zero
  |   move CARG2, sp
  |  move CARG1, CTSTATE
  |  call_intern lj_ccallback_enter	// (CTState *cts, void *cf)
  |  // Returns lua_State *.
  |  addlo BASE, L:CRET1->base
  |  ld BASE, BASE
  |  addlo RC, L:CRET1->top
  |  ld RC, RC
  |   move L, CRET1
  |    moveli TOBIT, 14403
  |    revbytes TOBIT, TOBIT
  |  movei TISNUM, -2
  |  shl16insli TISNUM, TISNUM, -1
  |  addi LFUNC:RB, BASE, FRAME_FUNC
  |  ld4s LFUNC:RB, LFUNC:RB
  |    li_vmstate INTERP
  |     addi TISNIL, zero, LJ_TNIL
  |  sub RC, RC, BASE
  |    st_vmstate
  |  ins_callt
  |.endif
  |
  |->cont_ffi_callback:			// Return from FFI callback.
  |.if FFI
  |  load_got lj_ccallback_leave
  |  addli CTSTATE, DISPATCH, DISPATCH_GL(ctype_state)
  |  ld4u CTSTATE, CTSTATE
  |   addlo AT, L->base
  |   st AT, BASE
  |   addlo AT, L->top
  |   st AT, RB
  |  addlo AT, CTSTATE->L
  |  st AT, L
  |  move CARG2, RA
  |  move CARG1, CTSTATE
  |  call_intern lj_ccallback_leave	// (CTState *cts, TValue *o)
  |  addlo CRET1, CTSTATE->cb.gpr[0]
  |  ld CRET1, CRET1
  |   //ldc1 FRET1, CTSTATE->cb.fpr[0]
  |  addlo CRET2, CTSTATE->cb.gpr[1]
  |  ld CRET2, CRET2
  |  //ldc1 FRET2, CTSTATE->cb.fpr[1]
  |  b ->vm_leave_unw
  |.endif
  |
  |->vm_ffi_call:			// Call C function via FFI.
  |  // Caveat: needs special frame unwinding, see below.
  |.if FFI
  |  .type CCSTATE, CCallState, CARG1
  |  addlo TMP1, CCSTATE->spadj
  |  ld TMP1, TMP1
  |   addlo CARG2, CCSTATE->nsp
  |   ld1u CARG2, CARG2
  |  move TMP2, sp
  |  sub sp, sp, TMP1
  |  addi AT, TMP2, -4
  |  st4 AT, lr
  |   shli CARG2, CARG2, 2
  |  addi AT, TMP2, -8
  |  st4 AT, r16
  |  addi AT, TMP2, -12
  |  st4 AT, CCSTATE
  |  move r16, TMP2
  |  addli TMP1, CCSTATE, offsetof(CCallState, stack)
  |  addli TMP2, sp, 16
  |  add TMP3, TMP1, CARG2
  |  beqz CARG2, >2
  |1:
  |   ld TMP0, TMP1
  |  addli TMP1, TMP1, 4
  |  cmpltu AT, TMP1, TMP3
  |   st TMP2, TMP0
  |  addli TMP2, TMP2, 4
  |  bnez AT, <1
  |2:
  |  addlo CFUNCADDR, CCSTATE->func
  |  ld CFUNCADDR, CFUNCADDR
  |  addlo CARG2, CCSTATE->gpr[1]
  |  ld CARG2, CARG2
  |  addlo CARG3, CCSTATE->gpr[2]
  |  ld CARG3, CARG3
  |  addlo CARG4, CCSTATE->gpr[3]
  |  ld CARG4, CARG4
  |  //ldc1 FARG1, CCSTATE->fpr[0]
  |  //ldc1 FARG2, CCSTATE->fpr[1]
  |  addlo AT, CCSTATE:CARG1->gpr[0]		// Do this last, since CCSTATE is CARG1.
  |  ld CARG1, AT
  |  jalr CFUNCADDR
  |  addi CCSTATE:TMP1, r16, -12
  |  ld CCSTATE:TMP1, CCSTATE:TMP1
  |  addi TMP2, r16, -8
  |  ld TMP2, TMP2
  |  addi lr, r16, -4
  |  ld lr,lr
  |  addlo AT, CCSTATE:TMP1->gpr[0]
  |  st AT, CRET1
  |  addlo AT, CCSTATE:TMP1->gpr[1]
  |  st AT, CRET2
  |  //sdc1 FRET1, CCSTATE:TMP1->fpr[0]
  |  //sdc1 FRET2, CCSTATE:TMP1->fpr[1]
  |  move sp, r16
  |  move r16, TMP2
  |  jr lr
  |.endif
  |// Note: vm_ffi_call must be the last function in this object file!
  |
  |//-----------------------------------------------------------------------
}

/* Generate the code for a single instruction. */
static void build_ins(BuildCtx *ctx, BCOp op, int defop)
{
  int vk = 0;
  |=>defop:

  switch (op) {

  /* -- Comparison ops ---------------------------------------------------- */

  /* Remember: all ops branch for a true comparison, fall through otherwise. */

  case BC_ISLT: case BC_ISGE: case BC_ISLE: case BC_ISGT:
    |.if DUALNUM
    |  // RA = src1*8, RD = src2*8, JMP with RD = target
    |  B_X
    |    B_add_x0 CARG3, BASE, RD
    |    B_add_x1 CARG2, BASE, RA
    |  B_X
    |    B_addi_x0 TMP2, PC, OFS_RD
    |    B_ld_x1 AT2, CARG2
    |  B_X
    |    B_moveli_x0 TMP3, (-(BCBIAS_J*4 >> 16) & 65535)
    |    B_ld_x1 AT3, CARG3
    |  B_X
    |    B_addi_x0 PC, PC, 4
    |    B_shl16insli_x1 TMP3, TMP3, 0
    |  B_Y1
    |    B_shrsi_y0 TMP0, AT2, 32
    |    B_shrsi_y1 TMP1, AT3, 32
    |    B_ld2u_y2 TMP2, TMP2
    |  B_X
    |    B_bfexts_x0 AT5, AT2, 0, 31
    |    B_cmpne_x1 AT, TMP0, TISNUM
    |  B_X
    |    B_bfexts_x0 AT6, AT3, 0, 31
    |    B_cmpne_x1 AT1, TMP1, TISNUM
    |  decode_RD4b TMP2
    |  B_X
    |    B_add_x0 TMP2, TMP2, TMP3
    |    B_bnez_x1 AT, >2
    |  bnez AT1, >3
    if (op == BC_ISLT || op == BC_ISGE) {
      |  cmplts AT, AT5, AT6
    } else {
      |  cmples AT, AT5, AT6
    }
    if (op == BC_ISLT || op == BC_ISLE) {
      |  cmoveqz TMP2, AT, zero
    } else {
      |  cmovnez TMP2, AT, zero
    }
    |  add PC, PC, TMP2
    |1:
    |  ins_next
    |2:  // RA is not an integer.
    |  cmpltu AT, TISNUM, TMP0
    |  B_X
    |    B_cmpltu_x0 AT, TISNUM, TMP1
    |    B_bnez_x1 AT, ->vmeta_comp
    |  B_X
    |    B_cmpltu_x0 AT, TMP1, TISNUM
    |    B_bnez_x1 AT, ->vmeta_comp
    |  bnez AT, >4
    |  fixsidf_inline AT6, AT, AT1, AT4
    |  B_X
    |    B_move_x0 AT3, AT6
    |    B_b_x1 >4
    |3:  // RA is an integer, RD is not an integer.
    |  cmpltu AT, TISNUM, TMP1
    |  bnez AT, ->vmeta_comp
    |  fixsidf_inline AT5, AT, AT1, AT4
    |  move AT2, AT5
    |4:
    |  fdouble_add_flags AT, AT2, AT3
    if (op == BC_ISLT || op == BC_ISGE) {
      |  bfextu AT, AT, 26, 26
    } else {
      |  bfextu AT, AT, 27, 27
    }
    if (op == BC_ISLT || op == BC_ISLE) {
      |  cmoveqz TMP2, AT, zero
    } else {
      |  cmovnez TMP2, AT, zero
    }
    |  add PC, PC, TMP2
    |  ins_next
    |.else
    |  // RA = src1*8, RD = src2*8, JMP with RD = target
    |  B_X
    |    B_add_x0 CARG2, BASE, RA
    |    B_add_x1 CARG3, BASE, RD
    |  B_X
    |    B_addi_x0 TMP0, CARG2, HI
    |    B_ld_x1 AT2, CARG2
    |  B_X
    |    B_addi_x0 TMP1, CARG3, HI
    |    B_ld4s_x1 TMP0, TMP0
    |  B_X
    |    B_moveli_x0 AT, (short)((LJ_TISNUM >> 16) & 0xFFFF)
    |    B_ld4s_x1 TMP1, TMP1
    |  B_X
    |    B_shl16insli_x0 AT, AT, (short)(LJ_TISNUM & 0xFFFF)
    |    B_ld_x1 AT3, CARG3
    |  B_X
    |    B_cmpltu_x0 TMP0, TMP0, AT
    |    B_cmpltu_x1 TMP1, TMP1, AT
    |  B_X
    |    B_addi_x0 TMP2, PC, OFS_RD
    |    B_moveli_x1 TMP3, (-(BCBIAS_J*4 >> 16) & 65535)
    |  B_X
    |    B_and_x0 TMP0, TMP0, TMP1
    |    B_ld2u_x1 TMP2, TMP2
    |  B_X
    |    B_addi_x0 PC, PC, 4
    |    B_shl16insli_x1 TMP3, TMP3, 0
    |  B_X
    |    B_shli_x0 TMP2, TMP2, 2 
    |    B_beqz_x1 TMP0, ->vmeta_comp
    |  B_X
    |    B_fdouble_add_flags_x0 AT, AT2, AT3
    |    B_add_x1 TMP2, TMP2, TMP3
    if (op == BC_ISLT || op == BC_ISGE) {
      |  bfextu AT, AT, 26, 26
    } else {
      |  bfextu AT, AT, 27, 27
    }
    if (op == BC_ISLT || op == BC_ISLE) {
      |  cmoveqz TMP2, AT, zero
    } else {
      |  cmovnez TMP2, AT, zero
    }
    |  add PC, PC, TMP2
    |1:
    |  ins_next
    |.endif
    break;

  case BC_ISEQV: case BC_ISNEV:
    vk = op == BC_ISEQV;
    |.if DUALNUM
    |  // RA = src1*8, RD = src2*8, JMP with RD = target
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_addi_x1 PC, PC, 4
    |  B_X
    |    B_add_x0 RD, BASE, RD
    |    B_ld_x1 CARG2, RA
    |  B_X
    |    B_addi_x0 TMP2, PC, -2 //-4+OFS_RD
    |    B_ld_x1 CARG3, RD
    |  B_X
    |    B_moveli_x0 TMP3, (-(BCBIAS_J*4 >> 16) & 65535)
    |    B_ld2u_x1 TMP2, TMP2
    |  B_X
    |    B_shrsi_x0 TMP0, CARG2, 32
    |    B_shl16insli_x1 TMP3, TMP3, 0
    |  B_X
    |    B_bfexts_x0 CARG2, CARG2, 0, 31
    |    B_shrsi_x1 TMP1, CARG3, 32
    |  bfexts CARG3, CARG3, 0, 31
    |  B_X
    |    B_cmpleu_x0 AT1, TMP0, TISNUM
    |    B_cmpleu_x1 AT2, TMP1, TISNUM
    |  B_X
    |    B_cmpne_x0 AT3, TMP0, TISNUM
    |    B_cmpne_x1 AT4, TMP1, TISNUM
    |  B_X
    |    //decode_RD4b TMP2
    |    B_shli_x0 TMP2, TMP2, 2
    |    B_and_x1 AT, AT1, AT2
    |  add TMP2, TMP2, TMP3
    if (vk) {
      |  bnez AT, ->BC_ISEQN_Z
    } else {
      |  bnez AT, ->BC_ISNEN_Z
    }
    |5:  // Either or both types are not numbers.
    |.if FFI
    |  //addi TMP3, zero, LJ_TCDATA
    |  cmpeqi AT1, TMP0, LJ_TCDATA
    |  bnez AT1, ->vmeta_equal_cd
    |.endif
    |  cmpltui AT, TMP0, LJ_TISPRI		// Not a primitive?
    |.if FFI
    |  cmpeqi AT1, TMP1, LJ_TCDATA
    |  bnez AT1, ->vmeta_equal_cd
    |.endif
    |  B_X
    |    B_xor_x0 TMP3, CARG2, CARG3			// Same tv?
    |    B_xor_x1 TMP1, TMP1, TMP0			// Same type?
    |  B_X
    |    B_cmoveqz_x0 TMP3, AT, zero			// Ignore tv if primitive.
    |    B_cmpltui_x1 CARG1, TMP0, LJ_TISTABUD+1		// Table or userdata?
    |  B_X
    |    B_cmovnez_x0 CARG1, TMP1, zero			// Tab/ud and same type?
    |    B_or_x1 AT, TMP1, TMP3			// Same type && (pri||same tv).
    |  cmoveqz CARG1, AT, zero
    if (vk) {
      |  cmovnez TMP2, AT, zero
    } else {
      |  cmoveqz TMP2, AT, zero
    }
    |  bnez CARG1, >2	// Done if not tab/ud or not same type or same tv.
    |1:
    |  add PC, PC, TMP2
    |  ins_next
    |2:
    |  // Different tables or userdatas. Need to check __eq metamethod.
    |  // Field metatable must be at same offset for GCtab and GCudata!
    |  addlo TAB:TMP1, TAB:CARG2->metatable
    |  ld4u TAB:TMP1, TAB:TMP1
    |  B_X
    |    B_addlo_x0 TMP1, TAB:TMP1->nomm
    |    B_beqz_x1 TAB:TMP1, <1		// No metatable?
    |  ld1u TMP1, TMP1
    |  andi TMP1, TMP1, 1<<MM_eq
    |  B_X
    |    B_addi_x0 CARG4, zero, 1-vk			// ne = 0 or 1.
    |    B_bnez_x1 TMP1, <1			// Or 'no __eq' flag set?
    |  b ->vmeta_equal			// Handle __eq metamethod.
    |.else
    |  // RA = src1*8, RD = src2*8, JMP with RD = target
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_addli_x1 PC, PC, 4
    |  B_X
    |    B_addi_x0 TMP0, RA, HI
    |    B_ld_x1 AT2, RA
    |  B_X
    |    B_add_x0 RD, BASE, RD
    |    B_ld4s_x1 TMP0, TMP0
    |  B_X
    |    B_addi_x0 TMP2, PC, -4+OFS_RD
    |    B_moveli_x1 TMP3, (-(BCBIAS_J*4 >> 16) & 65535)
    |  B_X
    |    B_addi_x0 TMP1, RD, HI
    |    B_ld2u_x1 TMP2, TMP2
    |  B_X
    |    B_shl16insli_x0 TMP3, TMP3, 0
    |    B_ld4s_x1 TMP1, TMP1
    |  B_X
    |    B_moveli_x0 AT, (short)((LJ_TISNUM >> 16) & 0xFFFF)
    |    B_ld_x1 AT3, RD
    |  shl16insli AT, AT, (short)(LJ_TISNUM & 0xFFFF)
    |  B_X
    |    B_cmpltu_x0 AT1, TMP0, AT
    |    B_cmpltu_x1 CARG1, TMP1, AT
    |  B_X
    |    //decode_RD4b
    |    B_shli_x0 TMP2, TMP2, 2
    |    B_and_x1 AT, AT1, CARG1
    |  B_X
    |    B_add_x0 TMP2, TMP2, TMP3
    |    B_beqz_x1 AT, >5
    |  fdouble_add_flags AT, AT2, AT3
    |  bfextu AT, AT, 30, 30
    if (vk) {
      |  cmoveqz TMP2, AT, zero
    } else {
      |  cmovnez TMP2, AT, zero
    }
    |1:
    |  add PC, PC, TMP2
    |  ins_next
    |5:  // Either or both types are not numbers.
    |  addi CARG2, RA, LO
    |  B_X
    |    B_addi_x0 CARG3, RD, LO
    |    B_ld4s_x1 CARG2, CARG2
    |  ld4s CARG3, CARG3
    |.if FFI
    |  addi TMP3, zero, LJ_TCDATA
    |  cmpeq AT1, TMP0, TMP3
    |  bnez AT1, ->vmeta_equal_cd
    |.endif
    |  cmpltui AT, TMP0, LJ_TISPRI		// Not a primitive?
    |.if FFI
    |  cmpeq AT1, TMP1, TMP3
    |  bnez AT1, ->vmeta_equal_cd
    |.endif
    |  B_X
    |    B_xor_x0 TMP3, CARG2, CARG3			// Same tv?
    |    B_xor_x1 TMP1, TMP1, TMP0			// Same type?
    |  B_X
    |    B_cmoveqz_x0 TMP3, AT, zero			// Ignore tv if primitive.
    |    B_cmpltui_x1 CARG1, TMP0, LJ_TISTABUD+1		// Table or userdata?
    |  B_X
    |    B_cmovnez_x0 CARG1, TMP1, zero			// Tab/ud and same type?
    |    B_or_x1 AT, TMP1, TMP3			// Same type && (pri||same tv).
    |  cmoveqz CARG1, AT, zero
    if (vk) {
      |  B_X
      |    B_cmovnez_x0 TMP2, AT, zero
      |    B_beqz_x1 CARG1, <1	// Done if not tab/ud or not same type or same tv.
    } else {
      |  B_X
      |    B_cmoveqz_x0 TMP2, AT, zero
      |    B_beqz_x1 CARG1, <1	// Done if not tab/ud or not same type or same tv.
    }
    |  // Different tables or userdatas. Need to check __eq metamethod.
    |  // Field metatable must be at same offset for GCtab and GCudata!
    |  addlo TAB:TMP1, TAB:CARG2->metatable
    |  ld4u TAB:TMP1, TAB:TMP1
    |  B_X
    |    B_addlo_x0 AT1, TAB:TMP1->nomm
    |    B_beqz_x1 TAB:TMP1, <1		// No metatable?
    |  ld1u TMP1, AT1
    |  andi AT1, TMP1, 1<<MM_eq
    |  B_X
    |    B_addi_x0 CARG4, zero, 1-vk			// ne = 0 or 1.
    |    B_bnez_x1 AT1, <1			// Or 'no __eq' flag set?
    |  b ->vmeta_equal			// Handle __eq metamethod.
    |.endif
    break;

  case BC_ISEQS: case BC_ISNES:
    vk = op == BC_ISEQS;
    |  // RA = src*8, RD = str_const*8 (~), JMP with RD = target
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_addli_x1 PC, PC, 4
    |  B_X
    |    B_shrui_x0 RD, RD, 1
    |    B_ld_x1 STR:TMP3, RA
    |  B_X
    |    B_sub_x0 RD, KBASE, RD
    |    B_addi_x1 TMP2, PC, -4+OFS_RD
    |  B_X
    |    B_bfexts_x0 STR:TMP3, STR:TMP3, 0, 31
    |    B_shrsi_x1 TMP0, STR:TMP3, 32
    |.if FFI
    |  B_X
    |    B_addi_x0 AT, zero, LJ_TCDATA
    |    B_ld2u_x1 TMP2, TMP2
    |  cmpeq AT, TMP0, AT
    |  B_X
    |    B_addi_x0 STR:TMP1, RD, -4
    |    B_bnez_x1 AT, ->vmeta_equal_cd
    |.else
    |  B_X
    |    B_addi_x0 STR:TMP1, RD, -4
    |    B_ld2u_x1 TMP2, TMP2
    |.endif
    |  B_X
    |    B_addli_x0 TMP0, TMP0, -LJ_TSTR
    |    B_ld4u_x1 STR:TMP1, STR:TMP1
    |  B_X
    |    //decode_RD4b TMP2
    |    B_shli_x0 TMP2, TMP2, 2
    |    B_xor_x1 TMP1, STR:TMP1, STR:TMP3
    |  B_X
    |    B_or_x0 TMP0, TMP0, TMP1
    |    B_moveli_x1 TMP3, (-(BCBIAS_J*4 >> 16) & 65535)
    |  shl16insli TMP3, TMP3, 0
    |  add TMP2, TMP2, TMP3
    if (vk) {
      |  cmovnez TMP2, TMP0, zero
    } else {
      |  cmoveqz TMP2, TMP0, zero
    }
    |  add PC, PC, TMP2
    |  ins_next
    break;

  case BC_ISEQN: case BC_ISNEN:
    vk = op == BC_ISEQN;
    |.if DUALNUM
    |  // RA = src*8, RD = num_const*8, JMP with RD = target
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_addi_x1 PC, PC, 4
    |  B_X
    |    B_add_x0 RD, KBASE, RD
    |    B_ld_x1 CARG2, RA
    |  B_X
    |    B_addi_x0 TMP2, PC, -2//-4+OFS_RD
    |    B_ld_x1 CARG3, RD
    |  B_X
    |    B_moveli_x0 TMP3, (-(BCBIAS_J*4 >> 16) & 65535)
    |    B_ld2u_x1 TMP2, TMP2
    |  B_X
    |    B_shl16insli_x0 TMP3, TMP3, 0
    |    B_shrsi_x1 TMP0, CARG2, 32
    |  B_X
    |    B_bfexts_x0 CARG2, CARG2, 0, 31
    |    B_shrsi_x1 TMP1, CARG3, 32
    |  bfexts CARG3, CARG3, 0, 31
    |  B_X
    |    B_cmpne_x0 AT3, TMP0, TISNUM
    |    B_cmpne_x1 AT4, TMP1, TISNUM
    |  decode_RD4b TMP2
    |  add TMP2, TMP2, TMP3
    if (vk) {
      |->BC_ISEQN_Z:
    } else {
      |->BC_ISNEN_Z:
    }
    |  bnez AT3, >7
    |  B_X
    |    B_cmpeq_x0 AT, CARG2, CARG3
    |    B_bnez_x1 AT4, >8
    if (vk) {
      |4:
      |  cmoveqz TMP2, AT, zero
      |  add PC, PC, TMP2
      |.if not FFI
      |1:
      |.endif
    } else {
      |4:
      |  cmovnez TMP2, AT, zero
      |.if not FFI
      |1:
      |.endif
      |  add PC, PC, TMP2
    }
    |  ins_next
    |.if FFI
    |5:
    |  //addi AT, zero, LJ_TCDATA
    |  cmpeqi AT, TMP0, LJ_TCDATA
    |  bnez AT, ->vmeta_equal_cd
    |  b <1
    |.endif
    |.if DUALNUM
    |7:
    |  cmpltu AT, TMP0, TISNUM
    |  beqz AT, <5
    |  B_X
    |    B_cmpltu_x0 AT, TMP1, TISNUM
    |    B_ld_x1 CARG2, RA
    |  bnez AT, >2
    |  fixsidf_inline CARG3, AT, AT1, AT2
    |  b >3
    |8:
    |  fixsidf_inline CARG2, AT, AT1, AT2
    |2:
    |  ld CARG3, RD
    |3:
    |  fdouble_add_flags AT, CARG2, CARG3
    |  bfextu AT, AT, 30, 30
    |  b <4
    |.endif
    |.else // DUALNUM
    |  // RA = src*8, RD = num_const*8, JMP with RD = target
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_addli_x1 PC, PC, 4
    |  B_X
    |    B_addi_x0 TMP0, RA, HI
    |    B_moveli_x1 TMP3, (-(BCBIAS_J*4 >> 16) & 65535)
    |  B_X
    |    B_shl16insli_x0 TMP3, TMP3, 0
    |    B_ld4s_x1 TMP0, TMP0
    |  B_X
    |    B_moveli_x0 AT, (short)((LJ_TISNUM >> 16) & 0xFFFF)
    |    B_ld_x1 AT2, RA
    |  B_X
    |    B_add_x0 RD, KBASE, RD
    |    B_addi_x1 TMP2, PC, -4+OFS_RD
    |  B_X
    |    B_shl16insli_x0 AT, AT, (short)(LJ_TISNUM & 0xFFFF)
    |    B_ld2u_x1 TMP2, TMP2
    |  B_Y2
    |    B_cmpltu_y0 AT, TMP0, AT
    |    //decode_RD4b TMP2
    |    B_shli_y1 TMP2, TMP2, 2
    |    B_ld_y2 AT3, RD
    |.if FFI
    |  B_X
    |    B_add_x0 TMP2, TMP2, TMP3
    |    B_beqz_x1 AT, >5
    |.else
    |  B_X
    |    B_add_x0 TMP2, TMP2, TMP3
    |    B_beqz_x1 AT, >1
    |.endif
    |  fdouble_add_flags AT, AT2, AT3
    |  bfextu AT, AT, 30, 30
    if (vk) {
      |  cmoveqz TMP2, AT, zero
      |  add PC, PC, TMP2
      |1:
    } else {
      |  cmovnez TMP2, AT, zero
      |1:
      |  add PC, PC, TMP2
    }
    |  ins_next
    |.if FFI
    |5:
    |  cmpeqi AT, TMP0, -11 // LJ_TCDATA
    |  bnez AT, ->vmeta_equal_cd
    |  b <1
    |.endif
    |.endif
    break;

  case BC_ISEQP: case BC_ISNEP:
    vk = op == BC_ISEQP;
    |  // RA = src*8, RD = primitive_type*8 (~), JMP with RD = target
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_shrui_x1 TMP1, RD, 3
    |  B_X
    |    B_moveli_x0 TMP3, (-(BCBIAS_J*4 >> 16) & 65535)
    |    B_ld_x1 TMP0, RA
    |  B_X
    |    B_addi_x0 PC, PC, 4
    |    B_addi_x1 TMP2, PC, OFS_RD
    |  B_X
    |    B_nor_x0 TMP1, TMP1, zero
    |    B_ld2u_x1 TMP2, TMP2
    |  B_X
    |    B_shrsi_x0 TMP0, TMP0, 32
    |    B_shl16insli_x1 TMP3, TMP3, 0
    |.if FFI
    |  cmpeqi AT, TMP0, -11 // LJ_TCDATA
    |  bnez AT, ->vmeta_equal_cd
    |.endif
    |  B_X
    |    B_xor_x0 TMP0, TMP0, TMP1
    |    //decode_RD4b TMP2
    |    B_shli_x1 TMP2, TMP2, 2
    |  add TMP2, TMP2, TMP3
    if (vk) {
      |  cmovnez, TMP2, TMP0, zero
    } else {
      |  cmoveqz, TMP2, TMP0, zero
    }
    |  add PC, PC, TMP2
    |  ins_next
    break;

  /* -- Unary test and copy ops ------------------------------------------- */

  case BC_ISTC: case BC_ISFC: case BC_IST: case BC_ISF:
    |  // RA = dst*8 or unused, RD = src*8, JMP with RD = target
    |  B_X
    |    B_add_x0 RD, BASE, RD
    |    B_addi_x1 TMP2, PC, OFS_RD
    |  B_X
    |    B_addi_x0 TMP0, RD, HI
    |    B_ld2u_x1 TMP2, TMP2
    |  B_X
    |    B_addi_x0 PC, PC, 4
    |    B_ld4s_x1 TMP0, TMP0
    if (op == BC_IST || op == BC_ISF) {
      |  B_X
      |    B_cmpltui_x0 TMP0, TMP0, LJ_TISTRUECOND
      |    //decode_RD4b TMP2
      |    B_shli_x1 TMP2, TMP2, 2
      |  moveli TMP3, (-(BCBIAS_J*4 >> 16) & 65535)
      |  shl16insli TMP3, TMP3, 0
      |  add TMP2, TMP2, TMP3
      if (op == BC_IST) {
	|  cmoveqz TMP2, TMP0, zero
      } else {
	|  cmovnez TMP2, TMP0, zero
      }
      |  add PC, PC, TMP2
    } else {
      |  B_X
      |    B_cmpltui_x0 TMP0, TMP0, LJ_TISTRUECOND
      |    B_ld_x1 AT2, RD
      |  add RA, BASE, RA
      if (op == BC_ISTC) {
	|  beqz TMP0, >1
      } else {
	|  bnez TMP0, >1
      }
      |  //decode_RD4b TMP2
      |  B_X
      |    B_shli_x0 TMP2, TMP2, 2
      |    B_moveli_x1 TMP3, (-(BCBIAS_J*4 >> 16) & 65535)
      |  shl16insli TMP3, TMP3, 0
      |  B_X
      |    B_add_x0 TMP2, TMP2, TMP3
      |    B_st_x1 RA, AT2
      |  add PC, PC, TMP2
      |1:
    }
    |  ins_next
    break;

  /* -- Unary ops --------------------------------------------------------- */

  case BC_MOV:
    |  // RA = dst*8, RD = src*8
    |  B_X
    |    B_add_x0 RD, BASE, RD
    |    B_add_x1 RA, BASE, RA
    |  ld AT2, RD
    |  ins_next1
    |  st RA, AT2
    |  ins_next2
    break;
  case BC_NOT:
    |  // RA = dst*8, RD = src*8
    |  B_X
    |    B_add_x0 RD, BASE, RD
    |    B_add_x1 RA, BASE, RA
    |  B_X
    |    B_addi_x0 TMP0, RD, HI
    |    B_addi_x1 TMP1, zero, LJ_TFALSE
    |  B_X
    |    B_addi_x0 AT, RA, HI
    |    B_ld4s_x1 TMP0, TMP0
    |  cmpltui TMP0, TMP0, LJ_TISTRUECOND
    |  B_X
    |    B_addli_x0 TMP1, TMP0, LJ_TTRUE
    |    //ins_next1
    |    B_ld4u_add_x1 INS, PC, 4
    |  st4 AT, TMP1
    |  ins_next2
    break;
  case BC_UNM:
    |.if DUALNUM
    |  // RA = dst*8, RD = src*8
    |  B_X
    |    B_add_x0 CARG3, BASE, RD
    |    B_add_x1 RA, BASE, RA
    |  ld AT2, CARG3
    |  B_X
    |    B_bfexts_x0 AT2, AT2, 0, 31
    |    B_shrsi_x1 TMP0, AT2, 32
    |  B_X
    |    B_cmpltu_x0 AT, TMP0, TISNUM
    |    B_movei_x1 AT1, -1
    |  cmpne AT3, TMP0, TISNUM
    |  bnez AT3, >1
    |  subx AT2, zero, AT2
    |  v4int_l AT2, TISNUM, AT2
    |  ins_next1
    |  st RA, AT2
    |  ins_next2
    |1:
    |  shli AT1, AT1, 63
    |  B_X
    |    B_xor_x0 AT2, AT2, AT1
    |    B_beqz_x1 AT, ->vmeta_unm
    |  ins_next1
    |  st RA, AT2
    |  ins_next2
    |.else
    |  // RA = dst*8, RD = src*8
    |  B_X
    |    B_add_x0 CARG3, BASE, RD
    |    B_add_x1 RA, BASE, RA
    |  B_X
    |    B_addi_x0 TMP0, CARG3, HI
    |    B_ld_x1 AT2, CARG3
    |  B_X
    |    B_moveli_x0 AT, (short)((LJ_TISNUM >> 16) & 0xFFFF)
    |    B_ld4s_x1 TMP0, TMP0
    |  shl16insli AT, AT, (short)(LJ_TISNUM & 0xFFFF)
    |  B_X
    |    B_cmpltu_x0 AT, TMP0, AT
    |    B_movei_x1 AT1, -1
    |  shli AT1, AT1, 63
    |  B_X
    |    B_xor_x0 AT2, AT2, AT1
    |    B_beqz_x1 AT, ->vmeta_unm
    |  ins_next1
    |  st RA, AT2
    |  ins_next2
    |.endif
    break;
  case BC_LEN:
    |.if DUALNUM
    |  // RA = dst*8, RD = src*8
    |  B_X
    |    B_add_x0 CARG2, BASE, RD
    |    B_add_x1 RA, BASE, RA
    |  B_X
    |    B_addi_x0 AT1, zero, LJ_TSTR
    |    B_ld_x1 CARG1, CARG2
    |  B_X
    |    B_bfexts_x0 CARG1, CARG1, 0, 31
    |    B_shrsi_x1 TMP0, CARG1, 32
    |  B_X
    |    B_addi_x0 AT, zero, LJ_TTAB
    |    B_cmpne_x1 AT1, TMP0, AT1
    |  B_X
    |    B_addlo_x0 AT2, STR:CARG1->len
    |    B_bnez_x1 AT1, >2
    |  ld4u CRET1, AT2
    |1:
    |  //ins_next1
    |  B_X
    |    B_v4int_l_x0 CRET1, TISNUM, CRET1
    |    B_ld4u_add_x1 INS, PC, 4
    |  st RA, CRET1
    |  ins_next2
    |2:
    |  cmpne AT, TMP0, AT
    |  bnez AT, ->vmeta_len
#if LJ_52
    |  addlo TAB:TMP2, TAB:CARG1->metatable
    |  ld4u TAB:TMP2, TAB:TMP2
    |  bnez TAB:TMP2, >9
    |3:
#endif
    |->BC_LEN_Z:
    |  load_got lj_tab_len
    |  call_intern lj_tab_len		// (GCtab *t)
    |  // Returns uint32_t (but less than 2^31).
    |  b <1
#if LJ_52
    |9:
    |  addlo TMP0, TAB:TMP2->nomm
    |  ld1u TMP0, TMP0
    |  andi TMP0, TMP0, 1<<MM_len
    |  bnez TMP0, <3			// 'no __len' flag set: done.
    |  b ->vmeta_len
#endif
    |.else
    |  // RA = dst*8, RD = src*8
    |  B_X
    |    B_add_x0 CARG2, BASE, RD
    |    B_add_x1 RA, BASE, RA
    |  B_X
    |    B_addi_x0 TMP0, CARG2, HI
    |    B_ld4s_x1 CARG1, CARG2
    |  B_X
    |    B_addi_x0 AT1, zero, LJ_TSTR
    |    B_ld4s_x1 TMP0, TMP0
    |  B_X
    |    B_addi_x0 AT, zero, LJ_TTAB
    |    B_cmpne_x1 AT1, TMP0, AT1
    |  B_X
    |    B_addlo_x0 AT2, STR:CARG1->len
    |    B_bnez_x1 AT1, >2
    |  ld4u CRET1, AT2
    |1:
    |  B_X
    |    B_cmpltsi_x0 AT, CRET1, 0
    |    B_sub_x1 AT1, zero, CRET1
    |  B_X
    |    B_cmovnez_x0 CRET1, AT, AT1
    |    B_moveli_x1 AT2, 539
    |  B_X
    |    B_shli_x0 AT2, AT2, 8
    |    B_shli_x1 AT1, CRET1, 4
    |  bfins AT2, AT, 20, 20
    |  fdouble_pack1 CRET1, AT1, AT2
    |  B_X
    |    B_fdouble_pack2_x0 CRET1, AT1, zero
    |    //ins_next1
    |    B_ld4u_add_x1 INS, PC, 4
    |  st RA, CRET1
    |  ins_next2
    |2:
    |  cmpne AT, TMP0, AT
    |  bnez AT, ->vmeta_len
#if LJ_52
    |  addlo TAB:TMP2, TAB:CARG1->metatable
    |  ld4u TAB:TMP2, TAB:TMP2
    |  bnez TAB:TMP2, >9
    |3:
#endif
    |->BC_LEN_Z:
    |  load_got lj_tab_len
    |  call_intern lj_tab_len		// (GCtab *t)
    |  // Returns uint32_t (but less than 2^31).
    |  b <1
#if LJ_52
    |9:
    |  addlo TMP0, TAB:TMP2->nomm
    |  ld1u TMP0, TMP0
    |  andi TMP0, TMP0, 1<<MM_len
    |  bnez TMP0, <3			// 'no __len' flag set: done.
    |  b ->vmeta_len
#endif
    |.endif
    break;

  /* -- Binary ops -------------------------------------------------------- */

    |.macro ins_arithpre
    ||vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    |  decode_RB8a RB, INS
    |  //decode_RB8b RB
    |  bfextu RB, RB, 3, 10
    |  B_X
    |    //decode_RDtoRC8 RC, RD
    |    B_bfextu_x0 RC, RD, 3, 10
    |    B_shli_x1 RB, RB, 3
    |  shli RC, RC, 3
    |  // RA = dst*8, RB = src1*8, RC = src2*8 | num_const*8
    ||switch (vk) {
    ||case 0:
    |  B_X
    |    B_add_x0 CARG3, BASE, RB
    |    B_add_x1 CARG4, KBASE, RC
    |  B_X
    |    B_addi_x0 TMP1, CARG3, HI
    |    B_ld_x1 AT2, CARG3
    |  B_X
    |    B_moveli_x0 AT, (short)((LJ_TISNUM >> 16) & 0xFFFF)
    |    B_ld4s_x1 TMP1, TMP1
    |  B_X
    |    B_shl16insli_x0 AT, AT, (short)(LJ_TISNUM & 0xFFFF)
    |    B_ld_x1 AT3, CARG4
    |  cmpltu AT, TMP1, AT
    ||  break;
    ||case 1:
    |  B_X
    |    B_add_x0 CARG4, BASE, RB
    |    B_add_x1 CARG3, KBASE, RC
    |  B_X
    |    B_addi_x0 TMP1, CARG4, HI
    |    B_ld_x1 AT3, CARG4
    |  B_X
    |    B_moveli_x0 AT, (short)((LJ_TISNUM >> 16) & 0xFFFF)
    |    B_ld4s_x1 TMP1, TMP1
    |  B_X
    |    B_shl16insli_x0 AT, AT, (short)(LJ_TISNUM & 0xFFFF)
    |    B_ld_x1 AT2, CARG3
    |  cmpltu AT, TMP1, AT
    ||  break;
    ||default:
    |  B_X
    |    B_add_x0 CARG3, BASE, RB
    |    B_add_x1 CARG4, BASE, RC
    |  addi TMP1, CARG3, HI
    |  B_X
    |    B_addi_x0 TMP2, CARG4, HI
    |    B_ld4s_x1 TMP1, TMP1
    |  B_X
    |    B_moveli_x0 AT1, (short)((LJ_TISNUM >> 16) & 0xFFFF)
    |    B_ld4s_x1 TMP2, TMP2
    |  B_X
    |    B_shl16insli_x0 AT1, AT1, (short)(LJ_TISNUM & 0xFFFF)
    |    B_ld_x1 AT2, CARG3
    |  B_X
    |    B_cmpltu_x0 AT, TMP1, AT1
    |    B_ld_x1 AT3, CARG4
    |  cmpltu TMP0, TMP2, AT1
    |  and AT, AT, TMP0
    ||  break;
    ||}
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_beqz_x1 AT, ->vmeta_arith
    |.endmacro
    |
    |.macro ins_arith, ins
    |.if DUALNUM
    ||vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    |  decode_RB8a RB, INS
    |  //decode_RB8b RB
    |  bfextu RB, RB, 3, 10
    |  B_X
    |    //decode_RDtoRC8 RC, RD
    |    B_bfextu_x0 RC, RD, 3, 10
    |    B_shli_x1 RB, RB, 3
    |  // RA = dst*8, RB = src1*8, RC = src2*8 | num_const*8
    ||switch (vk) {
    ||case 0:
    |  B_X
    |    B_add_x0 CARG3, BASE, RB
    |    B_shli_x1 RC, RC, 3
    |  B_X
    |    B_add_x0 CARG4, KBASE, RC
    |    B_ld_x1 AT2, CARG3
    |  B_X
    |    B_shrsi_x0 TMP1, AT2, 32
    |    B_ld_x1 AT3, CARG4
    |  B_X
    |    B_cmpne_x0 AT, TMP1, TISNUM
    |    B_shrsi_x1 TMP2, AT3, 32
    |  cmpne AT1, TMP2, TISNUM
    |  B_X
    |    B_or_x0 AT, AT, AT1
    |    B_cmpltu_x1 AT4, TMP1, TISNUM
    |  cmpltu AT5, TMP2, TISNUM
    |  and AT4, AT4, AT5
    ||  break;
    ||case 1:
    |  B_X
    |    B_add_x0 CARG4, BASE, RB
    |    B_shli_x1 RC, RC, 3
    |  B_X
    |    B_add_x0 CARG3, KBASE, RC
    |    B_ld_x1 AT3, CARG4
    |  B_X
    |    B_shrsi_x0 TMP1, AT3, 32
    |    B_ld_x1 AT2, CARG3
    |  B_X
    |    B_cmpne_x0 AT, TMP1, TISNUM
    |    B_shrsi_x1 TMP2, AT2, 32
    |  cmpne AT1, TMP2, TISNUM
    |  B_X
    |    B_or_x0 AT, AT, AT1
    |    B_cmpltu_x1 AT4, TMP1, TISNUM
    |  cmpltu AT5, TMP2, TISNUM
    |  and AT4, AT4, AT5
    ||  break;
    ||default:
    |  B_X
    |    B_add_x0 CARG3, BASE, RB
    |    B_shli_x1 RC, RC, 3
    |  B_X
    |    B_add_x0 CARG4, BASE, RC
    |    B_ld_x1 AT2, CARG3
    |  B_X
    |    B_shrsi_x0 TMP1, AT2, 32
    |    B_ld_x1 AT3, CARG4
    |  B_X
    |    B_cmpne_x0 AT, TMP1, TISNUM
    |    B_shrsi_x1 TMP2, AT3, 32
    |  cmpne AT1, TMP2, TISNUM
    |  B_X
    |    B_or_x0 AT, AT, AT1
    |    B_cmpltu_x1 AT4, TMP1, TISNUM
    |  cmpltu AT5, TMP2, TISNUM
    |  and AT4, AT4, AT5
    ||  break;
    ||}
    |.if "ins" == "div"
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_b_x1 >1
    |.else
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_bnez_x1 AT, >1
    |.endif
    |.if "ins" == "add"
    |  addx CRET1, AT2, AT3
    |  B_X
    |    B_xor_x0 AT4, CRET1, AT2
    |    B_xor_x1 AT5, CRET1, AT3
    |  and AT5, AT4, AT5
    |  bfextu AT5, AT5, 31, 31
    |.elif "ins" == "sub"
    |  subx CRET1, AT2, AT3
    |  B_X
    |    B_xor_x0 AT4, CRET1, AT2
    |    B_xor_x1 AT5, AT2, AT3
    |  and AT5, AT4, AT5
    |  bfextu AT5, AT5, 31, 31
    |.elif "ins" == "mul"
    |  B_X
    |    B_mulx_x0 CRET1, AT2, AT3
    |    B_move_x1 AT5, zero
    |.else
    |  B_X
    |    B_bfexts_x0 CARG1, AT2, 0, 31
    |    B_addli_x1 CFUNCADDR, DISPATCH, DISPATCH_GOT(__modsi3)
    |  ld CFUNCADDR, CFUNCADDR
    |  B_X
    |    B_bfexts_x0 CARG2, AT3, 0, 31
    |    B_jalr_x1 CFUNCADDR
    |  move AT5, zero
    |.endif
    |  B_X
    |    B_v4int_l_x0 AT2, TISNUM, CRET1
    |    B_bnez_x1 AT5, ->vmeta_arith
    |  ins_next1
    |  st RA, AT2
    |  ins_next2
    |1:
    |  beqz AT4, ->vmeta_arith
    |.if "ins" == "add"
    |  fdouble_add_flags AT, AT2, AT3
    |  fdouble_unpack_min AT1, AT2, AT3
    |  fdouble_unpack_max AT3, AT2, AT3
    |  fdouble_addsub AT3, AT1, AT
    |  fdouble_pack1 AT2, AT3, AT
    |  fdouble_pack2 AT2, AT3, zero
    |.elif "ins" == "sub"
    |  fdouble_sub_flags AT, AT2, AT3
    |  fdouble_unpack_min AT1, AT2, AT3
    |  fdouble_unpack_max AT3, AT2, AT3
    |  fdouble_addsub AT3, AT1, AT
    |  fdouble_pack1 AT2, AT3, AT
    |  fdouble_pack2 AT2, AT3, zero
    |.elif "ins" == "mul"
    |  fdouble_unpack_max AT, AT2, zero
    |  fdouble_unpack_max AT1, AT3, zero
    |  fdouble_mul_flags AT2, AT2, AT3
    |  mul_hu_lu AT3, AT, AT1
    |  mul_lu_lu AT4, AT, AT1
    |  mula_hu_lu AT3, AT1, AT
    |  B_X
    |    B_mul_hu_hu_x0 AT, AT, AT1
    |    B_shli_x1 AT5, AT3, 32
    |  B_X
    |    B_shrui_x0 AT3, AT3, 32
    |    B_add_x1 AT4, AT4, AT5
    |  B_X
    |    B_add_x0 AT3, AT, AT3
    |    B_cmpltu_x1 AT5, AT4, AT5
    |  add AT3, AT3, AT5
    |  fdouble_pack1 AT2, AT3, AT2
    |  fdouble_pack2 AT2, AT3, AT4
    |.elif "ins" == "div"
    |  B_X
    |    B_move_x0 CARG1, AT2
    |    B_move_x1 CARG2, AT3
    |  load_got __divdf3
    |  call_extern
    |  move AT2, CRET1
    |.else
    |  B_X
    |    B_move_x0 CARG1, AT2
    |    B_move_x1 CARG2, AT3
    |  load_got fmod
    |  call_extern
    |  move AT2, CRET1
    |.endif
    |  ins_next1
    |  st RA, AT2
    |  ins_next2
    |.else // DUALNUM
    |  ins_arithpre
    |.if "ins" == "add"
    |  fdouble_add_flags AT, AT2, AT3
    |  fdouble_unpack_min AT1, AT2, AT3
    |  fdouble_unpack_max AT3, AT2, AT3
    |  fdouble_addsub AT3, AT1, AT
    |  fdouble_pack1 AT2, AT3, AT
    |  fdouble_pack2 AT2, AT3, zero
    |.elif "ins" == "sub"
    |  fdouble_sub_flags AT, AT2, AT3
    |  fdouble_unpack_min AT1, AT2, AT3
    |  fdouble_unpack_max AT3, AT2, AT3
    |  fdouble_addsub AT3, AT1, AT
    |  fdouble_pack1 AT2, AT3, AT
    |  fdouble_pack2 AT2, AT3, zero
    |.elif "ins" == "mul"
    |  fdouble_unpack_max AT, AT2, zero
    |  fdouble_unpack_max AT1, AT3, zero
    |  fdouble_mul_flags AT2, AT2, AT3
    |  mul_hu_lu AT3, AT, AT1
    |  mul_lu_lu AT4, AT, AT1
    |  mula_hu_lu AT3, AT1, AT
    |  B_X
    |    B_mul_hu_hu_x0 AT, AT, AT1
    |    B_shli_x1 AT5, AT3, 32
    |  B_X
    |    B_shrui_x0 AT3, AT3, 32
    |    B_add_x1 AT4, AT4, AT5
    |  B_X
    |    B_add_x0 AT3, AT, AT3
    |    B_cmpltu_x1 AT5, AT4, AT5
    |  add AT3, AT3, AT5
    |  fdouble_pack1 AT2, AT3, AT2
    |  fdouble_pack2 AT2, AT3, AT4
    |.elif "ins" == "div"
    |  B_X
    |    B_move_x0 CARG1, AT2
    |    B_move_x1 CARG2, AT3
    |  load_got __divdf3
    |  call_extern
    |  move AT2, CRET1
    |.else
    |  B_X
    |    B_move_x0 CARG1, AT2
    |    B_move_x1 CARG2, AT3
    |  load_got fmod
    |  call_extern
    |  move AT2, CRET1
    |.endif
    |  ins_next1
    |  st RA, AT2
    |  ins_next2
    |.endif
    |.endmacro

  case BC_ADDVN: case BC_ADDNV: case BC_ADDVV:
    |  ins_arith add
    break;
  case BC_SUBVN: case BC_SUBNV: case BC_SUBVV:
    |  ins_arith sub
    break;
  case BC_MULVN: case BC_MULNV: case BC_MULVV:
    |  ins_arith mul
    break;
  case BC_DIVVN: case BC_DIVNV: case BC_DIVVV:
    |  ins_arith div
    break;
  case BC_MODVN: case BC_MODNV: case BC_MODVV:
    |  ins_arith mod
    break;
  case BC_POW:
    |  decode_RB8a RB, INS
    |  //decode_RB8b RB
    |  bfextu RB, RB, 3, 10
    |  B_X
    |    //decode_RDtoRC8 RC, RD
    |    B_bfextu_x0 RC, RD, 3, 10
    |    B_shli_x1 RB, RB, 3
    |  B_X
    |    B_shli_x0 RC, RC, 3
    |    B_add_x1 CARG3, BASE, RB
    |  B_X
    |    B_add_x0 CARG4, BASE, RC
    |    B_addi_x1 TMP1, CARG3, HI
    |  B_X
    |    B_addi_x0 TMP2, CARG4, HI
    |    B_ld4s_x1 TMP1, TMP1
    |  ld4s TMP2, TMP2
    |  B_X
    |    B_moveli_x0 AT, (short)((LJ_TISNUM >> 16) & 0xFFFF)
    |    B_ld_x1 CARG1, CARG3
    |  B_X
    |    B_shl16insli_x0 AT, AT, (short)(LJ_TISNUM & 0xFFFF)
    |    B_ld_x1 CARG2, CARG4
    |  B_X
    |    B_cmpltu_x0 AT1, TMP1, AT
    |    B_cmpltu_x1 TMP0, TMP2, AT
    |  B_X
    |    B_and_x0 AT, AT1, TMP0
    |    //load_got pow
    |    B_addli_x1 CFUNCADDR, DISPATCH, DISPATCH_GOT(pow)
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_ld_x1 CFUNCADDR, CFUNCADDR
    |  beqz AT, ->vmeta_arith
    |  call_extern
    |  ins_next1
    |  st RA, CRET1
    |  ins_next2
    break;

  case BC_CAT:
    |  // RA = dst*8, RB = src_start*8, RC = src_end*8
    |  decode_RB8a RB, INS
    |  //decode_RB8b RB
    |  bfextu RB, RB, 3, 10
    |  B_X
    |    //decode_RDtoRC8 RC, RD
    |    B_bfextu_x0 RC, RD, 3, 10
    |    B_shli_x1 RB, RB, 3
    |  shli RC, RC, 3
    |  B_X
    |    B_sub_x0 CARG3, RC, RB
    |    B_addlo_x1 AT, L->base
    |  B_X
    |    B_add_x0 CARG2, BASE, RC
    |    B_st_x1 AT, BASE
    |  move MULTRES, RB
    |->BC_CAT_Z:
    |  //load_got lj_meta_cat
    |  B_X
    |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_meta_cat)
    |    B_shrui_x1 CARG3, CARG3, 3
    |  B_X
    |    B_addi_x0 AT, sp, SAVE_PC
    |    B_ld_x1 CFUNCADDR, CFUNCADDR
    |  B_X
    |    B_move_x0 CARG1, L
    |    B_st_x1 AT, PC
    |  B_X
    |    B_addlo_x0 CROSSTMP1, L:LREG->base
    |    B_jalr_x1 CFUNCADDR		// (lua_State *L, TValue *top, int left)
    |  // Returns NULL (finished) or TValue * (metamethod).
    |  ld BASE, CROSSTMP1
    |  bnez CRET1, ->vmeta_binop
    |  add RB, BASE, MULTRES
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_ld_x1 AT2, RB
    |  ins_next1
    |  st RA, AT2			// Copy result from RB to RA.
    |  ins_next2
    break;

  /* -- Constant ops ------------------------------------------------------ */

  case BC_KSTR:
    |  // RA = dst*8, RD = str_const*8 (~)
    |  shrui TMP1, RD, 1
    |  B_X
    |    B_sub_x0 TMP1, KBASE, TMP1
    |    //ins_next1
    |    B_ld4u_add_x1 INS, PC, 4
    |  addi TMP0, TMP1, -4
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_ld4u_x1 TMP0, TMP0
    |  B_Y3
    |    B_addi_y0 TMP2, zero, -5 // LJ_TSTR
    |    B_addi_y1 AT, RA, HI
    |    B_st4_y2 RA, TMP0
    |  st4 AT, TMP2
    |  ins_next2
    break;
  case BC_KCDATA:
    |.if FFI
    |  // RA = dst*8, RD = cdata_const*8 (~)
    |  shrui TMP1, RD, 1
    |  B_X
    |    B_sub_x0 TMP1, KBASE, TMP1
    |    //ins_next1
    |    B_ld4u_add_x1 INS, PC, 4
    |  addi TMP0, TMP1, -4
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_ld4u_x1 TMP0, TMP0
    |  B_Y3
    |    B_addi_y0 TMP2, zero, -11 // LJ_TCDATA
    |    B_addi_y1 AT, RA, HI
    |    B_st4_y2 RA, TMP0
    |  st4 AT, TMP2
    |  ins_next2
    |.endif
    break;
  case BC_KSHORT:
    |.if DUALNUM
    |  // RA = dst*8, RD = int16_literal*8
    |  B_X
    |    B_bfexts_x0 RD, INS, 16, 31
    |    B_add_x1 RA, BASE, RA
    |  B_X
    |    B_v4int_l_x0 RD, TISNUM, RD
    |    //ins_next1
    |    B_ld4u_add_x1 INS, PC, 4
    |  st RA, RD
    |  ins_next2
    |.else
    |  // RA = dst*8, RD = int16_literal*8
    |  bfexts RD, INS, 16, 31
    |  B_X
    |    B_cmpltsi_x0 AT, RD, 0
    |    B_sub_x1 AT1, zero, RD
    |  B_X
    |    B_cmovnez_x0 RD, AT, AT1
    |    B_moveli_x1 AT2, 539
    |  B_X
    |    B_shli_x0 AT2, AT2, 8
    |    B_shli_x1 AT1, RD, 4
    |  bfins AT2, AT, 20, 20
    |  fdouble_pack1 RD, AT1, AT2
    |  B_X
    |    B_fdouble_pack2_x0 RD, AT1, zero
    |    B_add_x1 RA, BASE, RA
    |  ins_next1
    |  st RA, RD
    |  ins_next2
    |.endif
    break;
  case BC_KNUM:
    |  // RA = dst*8, RD = num_const*8
    |  B_X
    |    B_add_x0 RD, KBASE, RD
    |    B_add_x1 RA, BASE, RA
    |  ld AT, RD
    |  ins_next1
    |  st RA, AT
    |  ins_next2
    break;
  case BC_KPRI:
    |  // RA = dst*8, RD = primitive_type*8 (~)
    |  B_X
    |    B_shrui_x0 TMP1, RD, 3
    |    B_add_x1 RA, BASE, RA
    |  B_X
    |    B_nor_x0 TMP0, TMP1, zero
    |    //ins_next1
    |    B_ld4u_add_x1 INS, PC, 4
    |  addi AT, RA, HI
    |  st4 AT, TMP0
    |  ins_next2
    break;
  case BC_KNIL:
    |  // RA = base*8, RD = end*8
    |  add RA, BASE, RA
    |  addi AT, RA, HI
    |  B_X
    |    B_addi_x0 RA, RA, 8
    |    B_st4_x1 AT, TISNIL
    |  add RD, BASE, RD
    |1:
    |  addi AT1, RA, HI
    |  B_X
    |    B_cmplts_x0 AT, RA, RD
    |    B_st4_x1 AT1, TISNIL
    |  B_X
    |    B_addi_x0 RA, RA, 8
    |    B_bnez_x1 AT, <1
    |  ins_next_
    break;

  /* -- Upvalue and function ops ------------------------------------------ */

  case BC_UGET:
    |  // RA = dst*8, RD = uvnum*8
    |  addi LFUNC:RB, BASE, FRAME_FUNC
    |  B_X
    |    B_shrui_x0 RD, RD, 1
    |    B_ld4s_x1 LFUNC:RB, LFUNC:RB
    |  add RD, RD, LFUNC:RB
    |  B_X
    |    B_addlo_x0 UPVAL:RB, LFUNC:RD->uvptr
    |    // ins_next1
    |    B_ld4u_add_x1 INS, PC, 4
    |  B_X
    |    B_bfextu_x0 TMP1, INS, 0, 7
    |    B_ld4u_x1 UPVAL:RB, UPVAL:RB
    |  B_X
    |    B_shli_x0 TMP1, TMP1, 3
    |    B_addlo_x1 AT1, UPVAL:RB->v
    |  B_Y2
    |    B_add_y0 TMP0, DISPATCH, TMP1
    |    B_shrui_y1 RD, INS, 16
    |    B_ld4u_y2 AT1, AT1
    |  B_X
    |    B_add_x0 AT3, BASE, RA
    |    B_ld_x1 AT2, AT1
    |  B_X
    |    B_shrui_x0, RA, INS, 5
    |    B_ld_x1, AT, TMP0
    |  B_X
    |    B_bfextu_x0, RA, RA, 3, 10
    |    B_shli_x1, RD, RD, 3
    |  st AT3, AT2
    |  B_X
    |    B_shli_x0, RA, RA, 3
    |    B_jr_x1, AT
    break;
  case BC_USETV:
    |  // RA = uvnum*8, RD = src*8
    |  addi LFUNC:RB, BASE, FRAME_FUNC
    |  B_X
    |    B_shrui_x0 RA, RA, 1
    |    B_ld4s_x1 LFUNC:RB, LFUNC:RB
    |  B_X
    |    B_add_x0 RD, BASE, RD
    |    B_add_x1 RA, RA, LFUNC:RB
    |  B_X
    |    B_addlo_x0 UPVAL:RB, LFUNC:RA->uvptr
    |    B_ld_x1 AT2, RD
    |  ld4u UPVAL:RB, UPVAL:RB
    |  B_X
    |    B_addlo_x0 TMP0, UPVAL:RB->closed
    |    B_addlo_x1 TMP3, UPVAL:RB->marked
    |  B_X
    |    B_addlo_x0 CARG2, UPVAL:RB->v
    |    B_ld1u_x1 TMP3, TMP3
    |  B_X
    |    B_shrsi_x0 TMP2, AT2, 32
    |    B_ld1u_x1 TMP0, TMP0
    |  B_X
    |    B_andi_x0 TMP3, TMP3, LJ_GC_BLACK	// isblack(uv)
    |    B_ld4u_x1 CARG2, CARG2
    |  B_X
    |    B_or_x0 TMP3, TMP3, TMP0
    |    B_st_x1 CARG2, AT2
    |  cmpeqi AT, TMP3, LJ_GC_BLACK|1
    |  bnez AT, >2			// Upvalue is closed and black?
    |1:
    |  ins_next
    |
    |2:  // Check if new value is collectable.
    |  B_X
    |    B_addi_x0 AT, zero, LJ_TISGCV
    |    B_ld4s_x1 TMP1, RD
    |  B_X
    |    B_sub_x0 AT2, TMP2, AT
    |    B_sub_x1 AT3, TISNUM, AT
    |  cmpleu AT, AT2, AT3
    |  B_X
    |    B_addlo_x0 TMP3, GCOBJ:TMP1->gch.marked
    |    B_bnez_x1 AT, <1			// tvisgcv(v)
    |  B_X
    |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_gc_barrieruv)
    |    B_ld1u_x1 TMP3, TMP3
    |  B_X
    |    B_andi_x0 TMP3, TMP3, LJ_GC_WHITES	// iswhite(v)
    |    //load_got lj_gc_barrieruv
    |    B_ld_x1 CFUNCADDR, CFUNCADDR
    |  beqz TMP3, <1
    |  // Crossed a write barrier. Move the barrier forward.
    |  B_X
    |    B_addli_x0 CARG1, DISPATCH, GG_DISP2G
    |    B_jalr_x1 CFUNCADDR
    |  b <1
    break;
  case BC_USETS:
    |  // RA = uvnum*8, RD = str_const*8 (~)
    |  addi LFUNC:RB, BASE, FRAME_FUNC
    |  B_X
    |    B_shrui_x0 RA, RA, 1
    |    B_ld4s_x1 LFUNC:RB, LFUNC:RB
    |  B_X
    |    B_shrui_x0 TMP1, RD, 1
    |    B_add_x1 RA, RA, LFUNC:RB
    |  B_X
    |    B_sub_x0 TMP1, KBASE, TMP1
    |    B_addlo_x1 UPVAL:RB, LFUNC:RA->uvptr
    |  B_X
    |    B_addi_x0 STR:TMP1, TMP1, -4
    |    B_ld4u_x1 UPVAL:RB, UPVAL:RB
    |  B_X
    |    B_addlo_x0 TMP2, UPVAL:RB->marked
    |    B_ld4u_x1 STR:TMP1, STR:TMP1
    |  B_X
    |    B_addlo_x0 CARG2, UPVAL:RB->v
    |    B_ld1u_x1 TMP2, TMP2
    |  B_X
    |    B_addlo_x0 TMP3, STR:TMP1->marked
    |    B_ld4u_x1 CARG2, CARG2
    |  B_X
    |    B_andi_x0 AT, TMP2, LJ_GC_BLACK	// isblack(uv)
    |    B_ld1u_x1 TMP3, TMP3
    |  addlo TMP2, UPVAL:RB->closed
    |  B_X
    |    B_addi_x0 TMP0, zero, LJ_TSTR
    |    B_ld1u_x1 TMP2, TMP2
    |  B_X
    |    B_addi_x0 AT1, CARG2, HI
    |    B_st4_x1 CARG2, STR:TMP1
    |  st4 AT1, TMP0
    |  bnez AT, >2
    |1:
    |  ins_next
    |
    |2:  // Check if string is white and ensure upvalue is closed.
    |  B_X
    |    B_andi_x0 AT, TMP3, LJ_GC_WHITES	// iswhite(str)
    |    B_beqz_x1 TMP2, <1
    |  load_got lj_gc_barrieruv
    |  B_X
    |    B_addli_x0 CARG1, DISPATCH, GG_DISP2G
    |    B_beqz_x1 AT, <1
    |  // Crossed a write barrier. Move the barrier forward.
    |  call_intern lj_gc_barrieruv	// (global_State *g, TValue *tv)
    |  b <1
    break;
  case BC_USETN:
    |  // RA = uvnum*8, RD = num_const*8
    |  addi LFUNC:RB, BASE, FRAME_FUNC
    |  B_X
    |    B_shrui_x0 RA, RA, 1
    |    B_ld4s_x1 LFUNC:RB, LFUNC:RB
    |  B_X
    |    B_add_x0 RD, KBASE, RD
    |    B_add_x1 RA, RA, LFUNC:RB
    |  B_X
    |    B_addlo_x0 UPVAL:RB, LFUNC:RA->uvptr
    |    B_ld_x1 AT2, RD
    |  ld4u UPVAL:RB, UPVAL:RB
    |  B_X
    |    B_addlo_x0 TMP1, UPVAL:RB->v
    |    //ins_next1
    |    B_ld4u_add_x1 INS, PC, 4
    |  ld4u TMP1, TMP1
    |  st TMP1, AT2
    |  ins_next2
    break;
  case BC_USETP:
    |  // RA = uvnum*8, RD = primitive_type*8 (~)
    |  addi LFUNC:RB, BASE, FRAME_FUNC
    |  B_X
    |    B_shrui_x0 RA, RA, 1
    |    B_ld4s_x1 LFUNC:RB, LFUNC:RB
    |  B_X
    |    B_shrui_x0 TMP0, RD, 3
    |    B_add_x1 RA, RA, LFUNC:RB
    |  B_X
    |    B_nor_x0 TMP0, TMP0, zero
    |    B_addlo_x1 UPVAL:RB, LFUNC:RA->uvptr
    |  ld4u UPVAL:RB, UPVAL:RB
    |  B_X
    |    B_addlo_x0 TMP1, UPVAL:RB->v
    |    //ins_next1
    |    B_ld4u_add_x1 INS, PC, 4
    |  ld4u TMP1, TMP1
    |  addi AT, TMP1, HI
    |  st4 AT, TMP0
    |  ins_next2
    break;

  case BC_UCLO:
    |  // RA = level*8, RD = target
    |  B_X
    |    B_addlo_x0 TMP2, L->openupval
    |    B_addli_x1 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_func_closeuv)
    |  ld4u TMP2, TMP2
    |  branch_RD			// Do this first since RD is not saved.
    |  //load_got lj_func_closeuv
    |  B_X
    |    B_addlo_x0 AT, L->base
    |    B_ld_x1 CFUNCADDR, CFUNCADDR
    |  B_X
    |    B_move_x0 CARG1, L
    |    B_st_x1 AT, BASE
    |  B_X
    |    B_add_x0 CARG2, BASE, RA
    |    B_beqz_x1 TMP2, >1
    |  call_intern lj_func_closeuv	// (lua_State *L, TValue *level)
    |  addlo BASE, L->base
    |  ld BASE, BASE
    |1:
    |  ins_next
    break;

  case BC_FNEW:
    |  // RA = dst*8, RD = proto_const*8 (~) (holding function prototype)
    |  B_X
    |    B_shrui_x0 TMP1, RD, 1
    |    //load_got lj_func_newL_gc
    |    B_addli_x1 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_func_newL_gc)
    |  B_X
    |    B_sub_x0 TMP1, KBASE, TMP1
    |    B_ld_x1 CFUNCADDR, CFUNCADDR
    |  addi CARG3, BASE, FRAME_FUNC
    |  B_X
    |    B_addi_x0 CARG2, TMP1, -4
    |    B_ld4s_x1 CARG3, CARG3
    |  B_X
    |    B_addlo_x0 AT, L:LREG->base
    |    B_ld4s_x1 CARG2, CARG2
    |  B_X
    |    B_addi_x0 AT1, sp, SAVE_PC
    |    B_st_x1 AT, BASE
    |  B_X
    |    B_move_x0 CARG1, L
    |    B_st_x1 AT1, PC
    |  // (lua_State *L, GCproto *pt, GCfuncL *parent)
    |  call_intern lj_func_newL_gc
    |  // Returns GCfuncL *.
    |  addlo BASE, L->base
    |  B_X
    |    B_addi_x0 TMP0, zero, LJ_TFUNC
    |    B_ld_x1 BASE, BASE
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    //ins_next1
    |    B_ld4u_add_x1 INS, PC, 4
    |  addi AT, RA, HI
    |  B_X
    |    B_addi_x0 AT1, RA, LO
    |    B_st4_x1 AT, TMP0
    |  st4 AT1, LFUNC:CRET1
    |  ins_next2
    break;

  /* -- Table ops --------------------------------------------------------- */

  case BC_TNEW:
  case BC_TDUP:
    |  // RA = dst*8, RD = (hbits|asize)*8 | tab_const*8 (~)
    |  addli TMP0, DISPATCH, DISPATCH_GL(gc.total)
    |  B_X
    |    B_addli_x0 TMP1, DISPATCH, DISPATCH_GL(gc.threshold)
    |    B_ld4u_x1 TMP0, TMP0
    |  B_X
    |    B_addlo_x0 AT, L:LREG->base
    |    B_ld4u_x1 TMP1, TMP1
    |  B_X
    |    B_addi_x0 AT1, sp, SAVE_PC
    |    B_st_x1 AT, BASE
    |  B_X
    |    B_cmpltu_x0 AT, TMP0, TMP1
    |    B_st_x1 AT1, PC
    |  beqz AT, >5
    |1:
    if (op == BC_TNEW) {
      |  //load_got lj_tab_new
      |  B_X
      |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_tab_new)
      |    B_shrui_x1 CARG2, RD, 3
      |  B_X
      |    B_addli_x0 AT, zero, 0x7ff
      |    B_ld_x1 CFUNCADDR, CFUNCADDR
      |  B_X
      |    B_and_x0 CARG2, CARG2, AT
      |    B_addli_x1 TMP0, zero, 0x801
      |  B_X
      |    B_addli_x0 AT, CARG2, -0x7ff
      |    B_shrui_x1 CARG3, RD, 14
      |  B_X
      |    B_cmoveqz_x0 CARG2, AT, TMP0
      |    // (lua_State *L, int32_t asize, uint32_t hbits)
      |    B_move_x1 CARG1, L
      |  call_intern lj_tab_new
      |  // Returns Table *.
    } else {
      |  //load_got lj_tab_dup
      |  B_X
      |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_tab_dup)
      |    B_shrui_x1 TMP1, RD, 1
      |  B_X
      |    B_sub_x0 TMP1, KBASE, TMP1
      |    B_ld_x1 CFUNCADDR, CFUNCADDR
      |  B_X
      |    B_move_x0 CARG1, L
      |    B_addi_x1 CARG2, TMP1, -4
      |  ld4u CARG2, CARG2
      |  call_intern lj_tab_dup		// (lua_State *L, Table *kt)
      |  // Returns Table *.
    }
    |  B_X
    |    B_addlo_x0 BASE, L->base
    |    //ins_next1
    |    B_ld4u_add_x1 INS, PC, 4
    |  ld BASE, BASE
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_addi_x1 TMP0, zero, LJ_TTAB
    |  B_X
    |    B_addi_x0 AT1, RA, HI
    |    B_st4_x1 RA, TAB:CRET1
    |  st4 AT1, TMP0
    |  ins_next2
    |5:
    |  B_X
    |    //load_got lj_gc_step_fixtop
    |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_gc_step_fixtop)
    |    B_move_x1 MULTRES, RD
    |  B_X
    |    B_move_x0 CARG1, L
    |    B_ld_x1 CFUNCADDR, CFUNCADDR
    |  call_intern lj_gc_step_fixtop	// (lua_State *L)
    |  move RD, MULTRES
    |  b <1
    break;

  case BC_GGET:
    |  // RA = dst*8, RD = str_const*8 (~)
  case BC_GSET:
    |  // RA = src*8, RD = str_const*8 (~)
    |  addi LFUNC:TMP2, BASE, FRAME_FUNC
    |  B_X
    |    B_shrui_x0 TMP1, RD, 1
    |    B_ld4s_x1 LFUNC:TMP2, LFUNC:TMP2
    |  B_X
    |    B_sub_x0 TMP1, KBASE, TMP1
    |    B_addlo_x1 TAB:RB, LFUNC:TMP2->env
    |  B_X
    |    B_addi_x0 STR:RC, TMP1, -4
    |    B_ld4u_x1 TAB:RB, TAB:RB
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_ld4u_x1 STR:RC, STR:RC
    if (op == BC_GGET) {
      |  b ->BC_TGETS_Z
    } else {
      |  b ->BC_TSETS_Z
    }
    break;

  case BC_TGETV:
    |.if DUALNUM
    |  // RA = dst*8, RB = table*8, RC = key*8
    |  //decode_RB8a RB, INS
    |  //shrui RB, INS, 21
    |  //decode_RB8b RB
    |  bfextu RB, INS, 24, 31
    |  B_X
    |    //decode_RDtoRC8 RC, RD
    |    B_bfextu_x0 RC, RD, 3, 10
    |    B_shli_x1 RB, RB, 3
    |  B_X
    |    B_shli_x0 RC, RC, 3
    |    B_add_x1 CARG2, BASE, RB
    |  B_X
    |    B_add_x0 CARG3, BASE, RC
    |    B_ld_x1 TAB:RB, CARG2
    |  ld RC, CARG3
    |  B_X
    |    B_addi_x0 AT, zero, LJ_TTAB
    |    B_add_x1 RA, BASE, RA
    |  B_X
    |    B_bfexts_x0 TAB:RB, TAB:RB, 0, 31
    |    B_shrsi_x1 TMP1, TAB:RB, 32
    |  B_X
    |    B_addlo_x0 TAB:TMP3, TAB:RB->metatable
    |    B_cmpne_x1 AT, TMP1, AT
    |  shrsi TMP2, RC, 32
    |  B_X
    |    B_bfexts_x0 RC, RC, 0, 31
    |    B_bnez_x1 AT, ->vmeta_tgetv
    |  B_Y2
    |    B_addi_y0 AT1, zero, -5 //LJ_TSTR
    |    B_cmpne_y1 AT, TMP2, TISNUM
    |    B_ld4u_y2 TAB:TMP3, TAB:TMP3
    |  B_X
    |    B_addlo_x0 TMP0, TAB:RB->asize
    |    B_bnez_x1 AT, >5
    |
    |  // Convert number key to integer, check for integerness and range.
    |  B_X
    |    B_addlo_x0 TMP1, TAB:RB->array
    |    B_ld4u_x1 TMP0, TMP0
    |  B_Y2
    |    B_shli_y0 TMP2, RC, 3
    |    B_cmpltu_y1 AT, RC, TMP0
    |    B_ld4u_y2 TMP1, TMP1
    |  B_X
    |    B_add_x0 TMP2, TMP1, TMP2
    |    B_beqz_x1 AT, ->vmeta_tgetv		// Integer key and in array part?
    |  B_X
    |    B_cmpeq_x0 AT, TMP0, TISNIL
    |    B_ld_x1 AT2, TMP2
    |  B_X
    |    B_shrsi_x0 TMP0, AT2, 32
    |    B_bnez_x1 AT, >2
    |1:
    |  ins_next1
    |  st RA, AT2
    |  ins_next2
    |
    |2:  // Check for __index if table value is nil.
    |  B_X
    |    B_addlo_x0 TMP0, TAB:TMP3->nomm
    |    B_beqz_x1 TAB:TMP3, <1		// No metatable: done.
    |  ld1u TMP0, TMP0
    |  andi TMP0, TMP0, 1<<MM_index
    |  bnez TMP0, <1			// 'no __index' flag set: done.
    |  b ->vmeta_tgetv
    |
    |5:
    |  cmpne AT, TMP2, AT1
    |  bnez AT, ->vmeta_tgetv
    |  b ->BC_TGETS_Z			// String key?
    |.else
    |  // RA = dst*8, RB = table*8, RC = key*8
    |  //decode_RB8a RB, INS
    |  //shrui RB, INS, 21
    |  //decode_RB8b RB
    |  bfextu RB, INS, 24, 31
    |  B_X
    |    //decode_RDtoRC8 RC, RD
    |    B_bfextu_x0 RC, RD, 3, 10
    |    B_shli_x1 RB, RB, 3
    |  B_X
    |    B_shli_x0 RC, RC, 3
    |    B_add_x1 CARG2, BASE, RB
    |  B_X
    |    B_add_x0 CARG3, BASE, RC
    |    B_addi_x1 TMP1, CARG2, HI
    |  B_X
    |    B_addi_x0 TMP2, CARG3, HI
    |    B_ld4s_x1 TMP1, TMP1
    |  B_X
    |    B_addi_x0 TAB:RB, CARG2, LO
    |    B_ld4s_x1 TMP2, TMP2
    |  B_X
    |    B_addi_x0 AT, zero, LJ_TTAB
    |    B_ld4s_x1 TAB:RB, TAB:RB
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_ld_x1 AT2, CARG3
    |  B_X
    |    B_cmpne_x0 AT, TMP1, AT
    |    B_moveli_x1 AT1, (short)((LJ_TISNUM >> 16) & 0xFFFF)
    |  B_X
    |    B_shl16insli_x0 AT1, AT1, (short)(LJ_TISNUM & 0xFFFF)
    |    B_bnez_x1 AT, ->vmeta_tgetv
    |  B_X
    |    B_cmpltu_x0 AT, TMP2, AT1
    |    B_addi_x1 AT1, zero, LJ_TSTR
    |  B_X
    |    B_move_x0 CRET1, AT2
    |    B_beqz_x1 AT, >5
    |
    |  // Convert number key to integer, check for integerness and range.
    |  fixdfsi_inline CRET1, AT3, AT4, AT5, AT6
    |  B_X
    |    B_move_x0 TMP3, CRET1
    |    B_addlo_x1 TMP0, TAB:RB->asize
    |  B_X
    |    B_cmpltsi_x0 AT, CRET1, 0
    |    B_ld4u_x1 TMP0, TMP0
    |  B_X
    |    B_sub_x0 AT1, zero, CRET1
    |    B_moveli_x1 AT3, 539
    |  B_X
    |    B_cmovnez_x0 CRET1, AT, AT1
    |    B_shli_x1 AT3, AT3, 8
    |  B_X
    |    B_bfins_x0 AT3, AT, 20, 20
    |    B_shli_x1 AT1, CRET1, 4
    |  fdouble_pack1 CRET1, AT1, AT3
    |  B_X
    |    B_fdouble_pack2_x0 CRET1, AT1, zero
    |    B_addlo_x1 TMP1, TAB:RB->array
    |  B_X
    |    //cmpeq AT1, CRET1, AT2
    |    B_fdouble_add_flags_x0 AT1, CRET1, AT2
    |    B_ld4u_x1 TMP1, TMP1
    |  B_X
    |    B_bfextu_x0 AT1, AT1, 30, 30
    |    B_cmpltu_x1 AT, TMP3, TMP0
    |  B_X
    |    B_cmoveqz_x0 AT, AT1, zero
    |    B_shli_x1 TMP3, TMP3, 3
    |  B_X
    |    B_add_x0 TMP3, TMP1, TMP3
    |    B_beqz_x1 AT, ->vmeta_tgetv		// Integer key and in array part?
    |  addi TMP0, TMP3, HI
    |  ld4s TMP0, TMP0
    |  B_X
    |    B_cmpeq_x0 AT, TMP0, TISNIL
    |    B_ld_x1 AT2, TMP3
    |  bnez AT, >2
    |1:
    |  ins_next1
    |   st RA, AT2
    |  ins_next2
    |
    |2:  // Check for __index if table value is nil.
    |  addlo TAB:TMP2, TAB:RB->metatable
    |  ld4u TAB:TMP2, TAB:TMP2
    |  beqz TAB:TMP2, <1		// No metatable: done.
    |  addlo TMP0, TAB:TMP2->nomm
    |  ld1u TMP0, TMP0
    |  andi TMP0, TMP0, 1<<MM_index
    |  bnez TMP0, <1			// 'no __index' flag set: done.
    |  b ->vmeta_tgetv
    |
    |5:
    |  //addi STR:RC, CARG3, LO
    |  B_X
    |    B_cmpne_x0 AT, TMP2, AT1
    |    B_ld4s_x1 STR:RC, CARG3
    |  bnez AT, ->vmeta_tgetv
    |  b ->BC_TGETS_Z			// String key?
    |.endif
    break;
  case BC_TGETS:
    |  // RA = dst*8, RB = table*8, RC = str_const*4 (~)
    |  decode_RB8a RB, INS
    |  decode_RB8b RB
    |  B_X
    |    B_add_x0 CARG2, BASE, RB
    |    //decode_RC4a RC, INS
    |    B_shrui_x1 RC, INS, 14
    |  B_X
    |    //decode_RC4b RC
    |    B_bfextu_x0 RC, RC, 2, 9
    |    B_ld_x1 TAB:RB, CARG2
    |  B_X
    |    B_shli_x0 RC, RC, 2
    |    B_addi_x1 AT, zero, LJ_TTAB
    |  sub CARG3, KBASE, RC
    |  addi STR:RC, CARG3, -4
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_ld4s_x1 STR:RC, STR:RC
    |  B_X
    |    B_bfexts_x0 TAB:RB, TAB:RB, 0, 31
    |    B_shrsi_x1 TMP0, TAB:RB, 32
    |  cmpne AT, TMP0, AT
    |  bnez AT, ->vmeta_tgets1
    |->BC_TGETS_Z:
    |  // TAB:RB = GCtab *, STR:RC = GCstr *, RA = dst*8
    |  addlo TMP0, TAB:RB->hmask
    |  B_X
    |    B_addlo_x0 TMP1, STR:RC->hash
    |    B_ld4u_x1 TMP0, TMP0
    |  B_X
    |    B_addlo_x0 NODE:TMP2, TAB:RB->node
    |    B_ld4u_x1 TMP1, TMP1
    |  B_X
    |    B_and_x0 TMP1, TMP1, TMP0		// idx = str->hash & tab->hmask
    |    B_ld4u_x1 NODE:TMP2, NODE:TMP2
    |  B_X
    |    B_shli_x0 TMP0, TMP1, 5
    |    B_shli_x1 TMP1, TMP1, 3
    |  sub TMP1, TMP0, TMP1
    |  add NODE:TMP2, NODE:TMP2, TMP1	// node = tab->node + (idx*32-idx*8)
    |1:
    |  addi CARG1, NODE:TMP2, offsetof(Node, key)+HI
    |  B_X
    |    B_addi_x0 TMP0, NODE:TMP2, offsetof(Node, key)+LO
    |    B_ld4s_x1 CARG1, CARG1
    |  B_X
    |    B_addlo_x0 NODE:TMP1, NODE:TMP2->next
    |    B_ld4s_x1 TMP0, TMP0
    |  B_X
    |    B_addi_x0 CARG2, NODE:TMP2, offsetof(Node, val)+HI
    |    B_ld4s_x1 NODE:TMP1, NODE:TMP1
    |  B_X
    |    B_addli_x0 CARG1, CARG1, 5
    |    B_ld4s_x1 CARG2, CARG2
    |  xor TMP0, TMP0, STR:RC
    |  B_X
    |    B_or_x0 AT, CARG1, TMP0
    |    B_addlo_x1 TAB:TMP3, TAB:RB->metatable
    |  ld4u TAB:TMP3, TAB:TMP3
    |  B_X
    |    B_addi_x0 AT1, NODE:TMP2, offsetof(Node, val)+LO
    |    B_bnez_x1 AT, >4
    |  B_X
    |    B_cmpeq_x0 AT, CARG2, TISNIL
    |    B_ld4s_x1 CARG1, AT1
    |  bnez AT, >5		// Key found, but nil value?
    |3:
    |  ins_next1
    |  B_X
    |    B_addi_x0 AT, RA, HI
    |    B_st4_x1 RA, CARG1
    |  st4 AT, CARG2
    |  ins_next2
    |
    |4:  // Follow hash chain.
    |  B_X
    |    B_move_x0 NODE:TMP2, NODE:TMP1
    |    B_bnez_x1 NODE:TMP1, <1
    |  // End of hash chain: key not found, nil result.
    |
    |5:  // Check for __index if table value is nil.
    |  B_X
    |    B_addi_x0 CARG2, zero, LJ_TNIL
    |    B_beqz_x1 TAB:TMP3, <3		// No metatable: done.
    |  addlo TMP0, TAB:TMP3->nomm
    |  ld1u TMP0, TMP0
    |  andi TMP0, TMP0, 1<<MM_index
    |  bnez TMP0, <3			// 'no __index' flag set: done.
    |  b ->vmeta_tgets
    break;
  case BC_TGETB:
    |  // RA = dst*8, RB = table*8, RC = index*8
    |  decode_RB8a RB, INS
    |  decode_RB8b RB
    |  B_X
    |    //decode_RDtoRC8 RC, RD
    |    B_bfextu_x0 RC, RD, 3, 10
    |    B_add_x1 CARG2, BASE, RB
    |  B_X
    |    B_shli_x0 RC, RC, 3
    |    B_ld_x1 TAB:RB, CARG2
    |  B_X
    |    B_addi_x0 AT, zero, LJ_TTAB
    |    B_add_x1 RA, BASE, RA
    |  B_X
    |    B_bfexts_x0 RB, RB, 0, 31
    |    B_shrsi_x1 CARG1, RB, 32
    |  B_X
    |    B_shrui_x0 TMP0, RC, 3
    |    B_cmpne_x1 AT, CARG1, AT
    |  B_X
    |    B_addlo_x0 AT1, TAB:RB->asize
    |    B_bnez_x1 AT, ->vmeta_tgetb
    |  B_X
    |    B_addlo_x0 TMP2, TAB:RB->array
    |    B_ld4u_x1 TMP1, AT1
    |  B_X
    |    B_cmpltu_x0 AT, TMP0, TMP1
    |    B_ld4u_x1 TMP2, TMP2
    |  B_X
    |    B_add_x0 RC, TMP2, RC
    |    B_beqz_x1 AT, ->vmeta_tgetb
    |  ld AT2, RC
    |  shrsi TMP1, AT2, 32
    |  cmpeq AT, TMP1, TISNIL
    |  bnez AT, >5
    |1:
    |  ins_next1
    |  st RA, AT2
    |  ins_next2
    |
    |5:  // Check for __index if table value is nil.
    |  addlo TAB:TMP2, TAB:RB->metatable
    |  ld4u TAB:TMP2, TAB:TMP2
    |  B_X
    |    B_addlo_x0 AT, TAB:TMP2->nomm
    |    B_beqz_x1 TAB:TMP2, <1		// No metatable: done.
    |  ld1u TMP1, AT
    |  andi TMP1, TMP1, 1<<MM_index
    |  bnez TMP1, <1			// 'no __index' flag set: done.
    |  b ->vmeta_tgetb			// Caveat: preserve TMP0!
    break;

  case BC_TSETV:
    |.if DUALNUM
    |  // RA = src*8, RB = table*8, RC = key*8
    |  decode_RB8a RB, INS
    |  //decode_RB8b RB
    |  bfextu RB, RB, 3, 10
    |  B_X
    |    B_bfextu_x0 RC, RD, 3, 10
    |    B_shli_x1 RB, RB, 3
    |  B_X
    |    B_add_x0 CARG2, BASE, RB
    |    B_shli_x1 RC, RC, 3
    |  B_X
    |    B_add_x0 CARG3, BASE, RC
    |    B_ld_x1 TAB:RB, CARG2
    |  B_X
    |    B_shrsi_x0 TMP1, TAB:RB, 32
    |    B_ld_x1 RC, CARG3
    |  B_X
    |    B_bfexts_x0 TAB:RB, TAB:RB, 0, 31
    |    B_shrsi_x1 TMP2, RC, 32
    |  B_X
    |    B_bfexts_x0 RC, RC, 0, 31
    |    B_addi_x1 AT, zero, LJ_TTAB
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_cmpne_x1 AT, TMP1, AT
    |  bnez AT, ->vmeta_tsetv
    |  B_X
    |    B_cmpne_x0 AT1, TMP2, TISNUM
    |    B_addi_x1 AT, zero, LJ_TSTR
    |  B_X
    |    B_addlo_x0 TMP0, TAB:RB->asize
    |    B_bnez_x1 AT1, >5
    |
    |  // Convert number key to integer, check for integerness and range.
    |  B_X
    |    B_addlo_x0 TMP1, TAB:RB->array
    |    B_ld4u_x1 TMP0, TMP0
    |  B_X
    |    B_addlo_x0 TAB:TMP2, TAB:RB->metatable
    |    B_ld4u_x1 TMP1, TMP1
    |  B_X
    |    B_cmpltu_x0 AT, RC, TMP0
    |    B_shli_x1 TMP3, RC, 3
    |  B_X
    |    B_add_x0 TMP1, TMP1, TMP3
    |    B_beqz_x1 AT, ->vmeta_tsetv		// Integer key and in array part?
    |  B_X
    |    B_addi_x0 TMP0, TMP1, HI
    |    B_ld4u_x1 TAB:TMP2, TAB:TMP2
    |  B_X
    |    B_addlo_x0 TMP3, TAB:RB->marked
    |    B_ld4s_x1 TMP0, TMP0
    |  ld1u TMP3, TMP3
    |  B_X
    |    B_cmpeq_x0 AT, TMP0, TISNIL
    |    B_ld_x1 AT2, RA
    |  bnez AT, >3
    |1:
    |  B_X
    |    B_andi_x0 AT, TMP3, LJ_GC_BLACK	// isblack(table)
    |    B_st_x1 TMP1, AT2
    |   bnez AT, >7
    |2:
    |  ins_next
    |
    |3:  // Check for __newindex if previous value is nil.
    |  B_X
    |    B_addlo_x0 TMP2, TAB:TMP2->nomm
    |    B_beqz_x1 TAB:TMP2, <1		// No metatable: done.
    |  ld1u TMP2, TMP2
    |  andi TMP2, TMP2, 1<<MM_newindex
    |  bnez TMP2, <1			// 'no __newindex' flag set: done.
    |  b ->vmeta_tsetv
    |
    |5:
    |  cmpne AT, TMP2, AT
    |  bnez AT, ->vmeta_tsetv
    |  b ->BC_TSETS_Z			// String key?
    |
    |7:  // Possible table write barrier for the value. Skip valiswhite check.
    |  barrierback TAB:RB, TMP3, TMP0, <2
    |.else // DUALNUM
    |  // RA = src*8, RB = table*8, RC = key*8
    |  decode_RB8a RB, INS
    |  decode_RB8b RB
    |  //decode_RDtoRC8 RC, RD
    |  bfextu RC, RD, 3, 10
    |  B_X
    |    B_shli_x0 RC, RC, 3
    |    B_add_x1 CARG2, BASE, RB
    |  B_X
    |    B_add_x0 CARG3, BASE, RC
    |    B_addi_x1 TMP1, CARG2, HI
    |  B_X
    |    B_addi_x0 TMP2, CARG3, HI
    |    B_ld4s_x1 TMP1, TMP1
    |  ld4s TMP2, TMP2
    |  B_X
    |    B_addi_x0 AT, zero, LJ_TTAB
    |    B_ld4s_x1 TAB:RB, CARG2
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_ld_x1 AT2, CARG3
    |  B_X
    |    B_cmpne_x0 AT, TMP1, AT
    |    B_moveli_x1 AT1, (short)((LJ_TISNUM >> 16) & 0xFFFF)
    |  B_X
    |    B_shl16insli_x0 AT1, AT1, (short)(LJ_TISNUM & 0xFFFF)
    |    B_bnez_x1 AT, ->vmeta_tsetv
    |  B_X
    |    B_cmpltu_x0 AT1, TMP2, AT1
    |    B_addi_x1 AT, zero, LJ_TSTR
    |  beqz AT1, >5
    |
    |  // Convert number key to integer, check for integerness and range.
    |  move CARG1, AT2
    |  fixdfsi_inline CARG1, AT3, AT4, AT5, AT6
    |  B_X
    |    B_move_x0 TMP3, CRET1
    |    B_addlo_x1 TMP0, TAB:RB->asize
    |  B_X
    |    B_cmpltsi_x0 AT, CRET1, 0
    |    B_ld4u_x1 TMP0, TMP0
    |  B_X
    |    B_sub_x0 AT1, zero, CRET1
    |    B_moveli_x1 AT3, 539
    |  B_X
    |    B_cmovnez_x0 CRET1, AT, AT1
    |    B_shli_x1 AT3, AT3, 8
    |  B_X
    |    B_bfins_x0 AT3, AT, 20, 20
    |    B_shli_x1 AT1, CRET1, 4
    |  fdouble_pack1 CRET1, AT1, AT3
    |  B_X
    |    B_fdouble_pack2_x0 CRET1, AT1, zero
    |    B_addlo_x1 TMP1, TAB:RB->array
    |  B_X
    |    //cmpeq AT1, CRET1, AT2
    |    B_fdouble_add_flags_x0 AT1, CRET1, AT2
    |    B_ld4u_x1 TMP1, TMP1
    |  B_X
    |    B_bfextu_x0 AT1, AT1, 30, 30
    |    B_cmpltu_x1 AT, TMP2, TMP0
    |  B_X
    |    B_cmoveqz_x0 AT, AT1, zero
    |    B_shli_x1 TMP3, TMP3, 3
    |  B_X
    |    B_add_x0 TMP1, TMP1, TMP3
    |    B_beqz_x1 AT, ->vmeta_tsetv		// Integer key and in array part?
    |  addlo TMP3, TAB:RB->marked
    |  B_X
    |    B_addi_x0 TMP0, TMP1, HI
    |    B_ld1u_x1 TMP3, TMP3
    |  ld4s TMP0, TMP0
    |  B_X
    |    B_cmpeq_x0 AT, TMP0, TISNIL
    |    B_ld_x1 AT2, RA
    |  bnez AT, >3
    |1:
    |  B_X
    |    B_andi_x0 AT, TMP3, LJ_GC_BLACK	// isblack(table)
    |    B_st_x1 TMP1, AT2
    |   bnez AT, >7
    |2:
    |  ins_next
    |
    |3:  // Check for __newindex if previous value is nil.
    |  addlo TAB:TMP2, TAB:RB->metatable
    |  ld4u TAB:TMP2, TAB:TMP2
    |  beqz TAB:TMP2, <1		// No metatable: done.
    |  addlo TMP2, TAB:TMP2->nomm
    |  ld1u TMP2, TMP2
    |  andi TMP2, TMP2, 1<<MM_newindex
    |  bnez TMP2, <1			// 'no __newindex' flag set: done.
    |  b ->vmeta_tsetv
    |
    |5:
    |  addi STR:RC, CARG3, LO
    |  B_X
    |    B_cmpne_x0 AT, TMP2, AT
    |    B_ld4s_x1 STR:RC, STR:RC
    |  bnez AT, ->vmeta_tsetv
    |  b ->BC_TSETS_Z			// String key?
    |
    |7:  // Possible table write barrier for the value. Skip valiswhite check.
    |  barrierback TAB:RB, TMP3, TMP0, <2
    |.endif
    break;
  case BC_TSETS:
    |  // RA = src*8, RB = table*8, RC = str_const*8 (~)
    |  decode_RB8a RB, INS
    |  decode_RB8b RB
    |  B_X
    |    B_add_x0 CARG2, BASE, RB
    |    //decode_RC4a RC, INS
    |    B_shrui_x1 RC, INS, 14
    |  B_X
    |    //decode_RC4b RC
    |    B_bfextu_x0 RC, RC, 2, 9
    |    B_ld_x1 TAB:RB, CARG2
    |  B_X
    |    B_shli_x0 RC, RC, 2
    |    B_addi_x1 AT, zero, LJ_TTAB
    |  sub CARG3, KBASE, RC
    |  B_X
    |    B_addi_x0 STR:RC, CARG3, -4		// KBASE-4-str_const*4
    |    B_add_x1 RA, BASE, RA
    |  B_X
    |    B_shrsi_x0 TMP0, RB, 32
    |    B_ld4s_x1 STR:RC, STR:RC
    |  bfexts RB, RB, 0, 31
    |  cmpne AT, TMP0, AT
    |  bnez AT, ->vmeta_tsets1
    |->BC_TSETS_Z:
    |  // TAB:RB = GCtab *, STR:RC = GCstr *, RA = BASE+src*8
    |  addlo TMP0, TAB:RB->hmask
    |  B_X
    |    B_addlo_x0 TMP1, STR:RC->hash
    |    B_ld4u_x1 TMP0, TMP0
    |  B_X
    |    B_addlo_x0 NODE:TMP2, TAB:RB->node
    |    B_ld4u_x1 TMP1, TMP1
    |  B_X
    |    B_addlo_x0 AT, TAB:RB->nomm		// Clear metamethod cache.
    |    B_ld4u_x1 NODE:TMP2, NODE:TMP2
    |  B_X
    |    B_and_x0 TMP1, TMP1, TMP0		// idx = str->hash & tab->hmask
    |    B_st1_x1 AT, zero
    |  B_X
    |    B_shli_x0 TMP0, TMP1, 5
    |    B_shli_x1 TMP1, TMP1, 3
    |  sub TMP1, TMP0, TMP1
    |  B_X
    |    B_add_x0 NODE:TMP2, NODE:TMP2, TMP1	// node = tab->node + (idx*32-idx*8)
    |    B_ld_x1 AT2, RA
    |1:
    |  B_X
    |    B_addi_x0 CARG1, NODE:TMP2, offsetof(Node, key)+HI
    |    B_addlo_x1 NODE:TMP1, NODE:TMP2->next
    |  B_X
    |    B_addi_x0 TMP0, NODE:TMP2, offsetof(Node, key)+LO
    |    B_ld4s_x1 CARG1, CARG1
    |  B_X
    |    B_addi_x0 AT, zero, LJ_TSTR
    |    B_ld4s_x1 TMP0, TMP0
    |  B_X
    |    B_addli_x0 CARG2, NODE:TMP2, offsetof(Node, val)+HI
    |    B_ld4s_x1 NODE:TMP1, NODE:TMP1
    |  B_X
    |    B_cmpne_x0 AT1, CARG1, AT
    |    B_ld4s_x1 CARG2, CARG2
    |  B_X
    |    B_addlo_x0 TMP3, TAB:RB->marked
    |    B_bnez_x1 AT1, >5
    |  B_X
    |    B_cmpne_x0 AT1, TMP0, STR:RC
    |    B_ld1u_x1 TMP3, TMP3
    |  B_X
    |    B_addlo_x0 TAB:TMP0, TAB:RB->metatable
    |    B_bnez_x1 AT1, >5
    |  B_X
    |    B_cmpeq_x0 AT1, CARG2, TISNIL
    |    B_ld4u_x1 TAB:TMP0, TAB:TMP0
    |  bnez AT1, >4		// Key found, but nil value?
    |2:
    |  B_X
    |    B_andi_x0 AT, TMP3, LJ_GC_BLACK	// isblack(table)
    |    B_addlo_x1 AT1, NODE:TMP2->val
    |  st AT1, AT2
    |  bnez AT, >7
    |3:
    |  ins_next
    |
    |4:  // Check for __newindex if previous value is nil.
    |  B_X
    |    B_addlo_x0 AT, TAB:TMP0->nomm
    |    B_beqz_x1 TAB:TMP0, <2		// No metatable: done.
    |  ld1u TMP0, AT
    |  andi TMP0, TMP0, 1<<MM_newindex
    |  bnez TMP0, <2			// 'no __newindex' flag set: done.
    |  b ->vmeta_tsets
    |
    |5:  // Follow hash chain.
    |  B_X
    |    B_move_x0 NODE:TMP2, NODE:TMP1
    |    B_bnez_x1 NODE:TMP1, <1
    |  // End of hash chain: key not found, add a new one
    |
    |  // But check for __newindex first.
    |  addlo TAB:TMP2, TAB:RB->metatable
    |  B_X
    |    B_addli_x0 CARG3, DISPATCH, DISPATCH_GL(tmptv)
    |    B_ld4u_x1 TAB:TMP2, TAB:TMP2
    |  B_X
    |    B_addlo_x0 TMP0, TAB:TMP2->nomm
    |    B_beqz_x1 TAB:TMP2, >6		// No metatable: continue.
    |  ld1u TMP0, TMP0
    |  B_X
    |    B_andi_x0 TMP0, TMP0, 1<<MM_newindex
    |    B_addi_x1 AT, zero, LJ_TSTR
    |  beqz TMP0, ->vmeta_tsets		// 'no __newindex' flag NOT set: check.
    |6:
    |  //load_got lj_tab_newkey
    |  addli CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_tab_newkey)
    |  B_X
    |    B_addi_x0 AT1, CARG3, LO
    |    B_ld_x1 CFUNCADDR, CFUNCADDR
    |  B_X
    |    B_addi_x0 AT3, CARG3, HI
    |    B_st4_x1 AT1, STR:RC
    |  B_X
    |    B_addlo_x0 AT, L->base
    |    B_st4_x1 AT3, AT
    |  B_X
    |    B_move_x0 CARG2, TAB:RB
    |    B_st_x1 AT, BASE
    |  B_X
    |    B_addi_x0 AT, sp, SAVE_PC
    |    B_move_x1 CARG1, L
    |  B_X
    |    B_move_x0 CROSSTMP1, AT2
    |    B_st_x1 AT, PC
    |  call_intern lj_tab_newkey	// (lua_State *L, GCtab *t, TValue *k
    |  B_X
    |    B_move_x0 AT2, CROSSTMP1
    |    // Returns TValue *.
    |    B_addlo_x1 BASE, L->base
    |  ld BASE, BASE
    |  st CRET1, AT2
    |  b <3				// No 2nd write barrier needed.
    |
    |7:  // Possible table write barrier for the value. Skip valiswhite check.
    |  barrierback TAB:RB, TMP3, TMP0, <3
    break;
  case BC_TSETB:
    |  // RA = src*8, RB = table*8, RC = index*8
    |  decode_RB8a RB, INS
    |  decode_RB8b RB
    |  B_X
    |    //decode_RDtoRC8 RC, RD
    |    B_bfextu_x0 RC, RD, 3, 10
    |    B_add_x1 CARG2, BASE, RB
    |  B_X
    |    B_addi_x0 AT, zero, LJ_TTAB
    |    B_ld_x1 TAB:RB, CARG2
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_shli_x1 RC, RC, 3
    |  B_X
    |    B_bfexts_x0 RB, RB, 0, 31
    |    B_shrsi_x1 CARG1, RB, 32
    |  B_X
    |    B_shrui_x0 TMP0, RC, 3
    |    B_cmpne_x1 AT, CARG1, AT
    |  B_X
    |    B_addlo_x0 AT, TAB:RB->asize
    |    B_bnez_x1 AT, ->vmeta_tsetb
    |  B_X
    |    B_addlo_x0 TMP2, TAB:RB->array
    |    B_ld4u_x1 TMP1, AT
    |  B_X
    |    B_cmpltu_x0 AT, TMP0, TMP1
    |    B_ld4u_x1 TMP2, TMP2
    |  B_X
    |    B_add_x0 RC, TMP2, RC
    |    B_beqz_x1 AT, ->vmeta_tsetb
    |  B_X
    |    B_addi_x0 TMP1, RC, HI
    |    B_ld_x1 AT2, RA
    |  B_X
    |    B_addlo_x0 TMP3, TAB:RB->marked
    |    B_ld4s_x1 TMP1, TMP1
    |  B_X
    |    B_cmpeq_x0 AT, TMP1, TISNIL
    |    B_ld1u_x1 TMP3, TMP3
    |  bnez AT, >5
    |1:
    |  B_X
    |    B_andi_x0 AT, TMP3, LJ_GC_BLACK	// isblack(table)
    |    B_st_x1 RC, AT2
    |  bnez AT, >7
    |2:
    |  ins_next
    |
    |5:  // Check for __newindex if previous value is nil.
    |  addlo TAB:TMP2, TAB:RB->metatable
    |  ld4u TAB:TMP2, TAB:TMP2
    |  B_X
    |    B_addlo_x0 AT, TAB:TMP2->nomm
    |    B_beqz_x1 TAB:TMP2, <1		// No metatable: done.
    |  ld1u TMP1, AT
    |  andi TMP1, TMP1, 1<<MM_newindex
    |  bnez TMP1, <1			// 'no __newindex' flag set: done.
    |  b ->vmeta_tsetb			// Caveat: preserve TMP0!
    |
    |7:  // Possible table write barrier for the value. Skip valiswhite check.
    |  barrierback TAB:RB, TMP3, TMP0, <2
    break;

  case BC_TSETM:
    |  // RA = base*8 (table at base-1), RD = num_const*8 (start index)
    |  add RA, BASE, RA
    |1:
    |  B_X
    |    B_add_x0 TMP3, KBASE, RD
    |    B_addi_x1 TAB:CARG2, RA, -8+LO
    |  B_X
    |    B_addli_x0 TMP0, MULTRES, -8
    |    B_ld4s_x1 TAB:CARG2, TAB:CARG2
    |  B_X
    |    B_shrui_x0 CARG3, TMP0, 3
    |    B_ld4s_x1 TMP3, TMP3
    |  beqz TMP0, >4			// Nothing to copy?
    |  B_X
    |    B_add_x0 CARG3, CARG3, TMP3
    |    B_addlo_x1 TMP2, TAB:CARG2->asize
    |  B_X
    |    B_shli_x0 TMP1, TMP3, 3
    |    B_ld4u_x1 TMP2, TMP2
    |  addlo TMP3, TAB:CARG2->marked
    |  B_X
    |    B_addlo_x0 CARG1, TAB:CARG2->array
    |    B_ld1u_x1 TMP3, TMP3
    |  B_X
    |    B_cmpltu_x0 AT, TMP2, CARG3
    |    B_ld4u_x1 CARG1, CARG1
    |  B_X
    |    B_add_x0 TMP2, RA, TMP0
    |    B_bnez_x1 AT, >5
    |  B_X
    |    B_add_x0 TMP1, TMP1, CARG1
    |    B_andi_x1 TMP0, TMP3, LJ_GC_BLACK	// isblack(table)
    |3:  // Copy result slots to table.
    |  ld_add AT2, RA, 8
    |  B_X
    |    B_cmpltu_x0 AT, RA, TMP2
    |    B_st_x1 TMP1, AT2
    |  B_X
    |    B_addli_x0 TMP1, TMP1, 8
    |    B_bnez_x1 AT, <3
    |  bnez TMP0, >7
    |4:
    |  ins_next
    |
    |5:  // Need to resize array part.
    |  //load_got lj_tab_reasize
    |  addli CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_tab_reasize)
    |  B_X
    |    B_addlo_x0 AT, L->base
    |    B_ld_x1 CFUNCADDR, CFUNCADDR
    |  B_X
    |    B_addi_x0 AT1, sp, SAVE_PC
    |    B_st_x1 AT, BASE
    |  B_X
    |    B_move_x0 BASE, RD
    |    B_st_x1 AT1, PC
    |  B_X
    |    B_move_x0 CARG1, L
    |    //call_intern lj_tab_reasize	// (lua_State *L, GCtab *t, int nasize)
    |    B_jalr_x1 CFUNCADDR
    |  B_X
    |    // Must not reallocate the stack.
    |    B_move_x0 RD, BASE
    |    B_addlo_x1 BASE, L:LREG->base	// Reload BASE for lack of a saved register.
    |  ld BASE, BASE	// Reload BASE for lack of a saved register.
    |  b <1
    |
    |7:  // Possible table write barrier for any value. Skip valiswhite check.
    |  barrierback TAB:CARG2, TMP3, TMP0, <4
    break;

  /* -- Calls and vararg handling ----------------------------------------- */

  case BC_CALLM:
    |  // RA = base*8, (RB = (nresults+1)*8,) RC = extra_nargs*8
    |  decode_RDtoRC8 NARGS8:RC, RD
    |  B_X
    |    B_add_x0 NARGS8:RC, NARGS8:RC, MULTRES
    |    B_b_x1 ->BC_CALL_Z
    break;
  case BC_CALL:
    |  // RA = base*8, (RB = (nresults+1)*8,) RC = (nargs+1)*8
    |  decode_RDtoRC8 NARGS8:RC, RD
    |->BC_CALL_Z:
    |  B_X
    |    B_move_x0 TMP2, BASE
    |    B_add_x1 BASE, BASE, RA
    |  B_X
    |    B_addi_x0 AT, zero, LJ_TFUNC
    |    B_ld_add_x1 LFUNC:RB, BASE, 8
    |  B_X
    |    B_bfexts_x0 RB, RB, 0, 31
    |    B_shrsi_x1 TMP0, RB, 32
    |  B_X
    |    B_addli_x0 NARGS8:RC, NARGS8:RC, -8
    |    B_cmpne_x1 AT, TMP0, AT
    |  bnez AT, ->vmeta_call
    |  ins_call
    break;

  case BC_CALLMT:
    |  // RA = base*8, (RB = 0,) RC = extra_nargs*8
    |  add NARGS8:RD, NARGS8:RD, MULTRES	// BC_CALLT gets RC from RD.
    |  // Fall through. Assumes BC_CALLT follows.
    break;
  case BC_CALLT:
    |  // RA = base*8, (RB = 0,) RC = (nargs+1)*8
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_addi_x1 AT, zero, LJ_TFUNC
    |  B_X
    |    B_addi_x0 TMP1, BASE, FRAME_PC
    |    B_ld_add_x1 LFUNC:RB, RA, 8
    |  B_X
    |    B_move_x0 NARGS8:RC, RD
    |    B_ld4s_x1 TMP1, TMP1
    |  B_X
    |    B_bfexts_x0 RB, RB, 0, 31
    |    B_shrsi_x1 TMP0, RB, 32
    |  B_X
    |    B_addli_x0 NARGS8:RC, NARGS8:RC, -8
    |    B_cmpne_x1 AT, TMP0, AT
    |  bnez AT, ->vmeta_callt
    |->BC_CALLT_Z:
    |  B_X
    |    B_andi_x0 TMP0, TMP1, FRAME_TYPE	// Caveat: preserve TMP0 until the 'or'.
    |    B_addlo_x1 TMP3, LFUNC:RB->ffid
    |  B_X
    |    B_xori_x0 TMP2, TMP1, FRAME_VARG
    |    B_ld1u_x1 TMP3, TMP3
    |  bnez TMP0, >7
    |1:
    |  addi AT1, BASE, FRAME_FUNC
    |  B_X
    |    B_cmpltui_x0 AT, TMP3, 2		// (> FF_C) Calling a fast function?
    |    B_st4_x1 AT1, LFUNC:RB
    |  B_X
    |    B_move_x0 TMP2, BASE
    |    B_move_x1 TMP3, NARGS8:RC
    |  beqz NARGS8:RC, >3
    |2:
    |  B_X
    |    B_addli_x0 TMP3, TMP3, -8
    |    B_ld_add_x1 AT2, RA, 8
    |  st_add TMP2, AT2, 8
    |  bnez TMP3, <2
    |3:
    |  or TMP0, TMP0, AT
    |  beqz TMP0, >5
    |4:
    |  ins_callt
    |
    |5:  // Tailcall to a fast function with a Lua frame below.
    |  addi INS, TMP1, -4
    |  ld4u INS, INS
    |  decode_RA8a RA, INS
    |  decode_RA8b RA
    |  sub TMP1, BASE, RA
    |  addi LFUNC:TMP1, TMP1, -8+FRAME_FUNC
    |  ld4s LFUNC:TMP1, LFUNC:TMP1
    |  addlo TMP1, LFUNC:TMP1->pc
    |  ld4u TMP1, TMP1
    |  addi AT, TMP1, PC2PROTO(k)
    |  ld4u KBASE, AT
    |  b <4
    |
    |7:  // Tailcall from a vararg function.
    |  B_X
    |    B_andi_x0 AT, TMP2, FRAME_TYPEP
    |    B_sub_x1 TMP2, BASE, TMP2		// Relocate BASE down.
    |  bnez AT, <1			// Vararg frame below?
    |  B_X
    |    B_move_x0 BASE, TMP2
    |    B_addi_x1 TMP1, TMP2, FRAME_PC
    |  ld4s TMP1, TMP1
    |  B_X
    |    B_andi_x0 TMP0, TMP1, FRAME_TYPE
    |    B_b_x1 <1
    break;

  case BC_ITERC:
    |  // RA = base*8, (RB = (nresults+1)*8, RC = (nargs+1)*8 ((2+1)*8))
    |  B_X
    |    B_move_x0 TMP2, BASE
    |    B_add_x1 BASE, BASE, RA
    |  B_X
    |    B_addi_x0 AT1, zero, LJ_TFUNC
    |    B_addi_x1 LFUNC:RB, BASE, -24
    |  B_X
    |    B_addi_x0 AT2, BASE, -8
    |    B_ld_x1 LFUNC:RB, LFUNC:RB
    |  B_X
    |    B_addi_x0 AT3, BASE, -16
    |    B_ld_x1 AT2, AT2
    |  B_X
    |    B_addi_x0 AT, BASE, HI
    |    B_ld_x1 AT3, AT3
    |  B_X
    |    B_bfexts_x0 RB, RB, 0, 31
    |    B_shrsi_x1 TMP1, RB, 32
    |  st4 AT, TMP1
    |  B_X
    |    B_addi_x0 AT, BASE, 16
    |    B_st4_x1 BASE, LFUNC:RB
    |  B_X
    |    B_addi_x0 AT2, BASE, 8
    |    B_st_x1 AT, AT2
    |  B_X
    |    B_addli_x0 BASE, BASE, 8
    |    B_st_x1 AT2, AT3
    |  B_X
    |    B_addi_x0 NARGS8:RC, zero, 16		// Iterators get 2 arguments.
    |    B_cmpne_x1 AT, TMP1, AT1
    |  bnez AT, ->vmeta_call
    |  ins_call
    break;

  case BC_ITERN:
    |.if DUALNUM
    |  // RA = base*8, (RB = (nresults+1)*8, RC = (nargs+1)*8 (2+1)*8)
    |.if JIT
    |  // NYI: add hotloop, record BC_ITERN.
    |.endif
    |  add RA, BASE, RA
    |  addi TAB:RB, RA, -16+LO
    |  B_X
    |    B_addi_x0 RC, RA, -8+LO
    |    B_ld4s_x1 TAB:RB, TAB:RB
    |  B_X
    |    B_addlo_x0 TMP0, TAB:RB->asize
    |    B_ld4s_x1 RC, RC
    |  B_X
    |    B_addlo_x0 TMP1, TAB:RB->array
    |    B_ld4u_x1 TMP0, TMP0
    |  B_X
    |    B_addli_x0 PC, PC, 4
    |    B_ld4u_x1 TMP1, TMP1
    |1:  // Traverse array part.
    |  B_X
    |    B_cmpltu_x0 AT, RC, TMP0
    |    B_shli_x1 TMP3, RC, 3
    |  B_X
    |    B_add_x0 TMP3, TMP1, TMP3
    |    B_beqz_x1 AT, >5			// Index points after array part?
    |  addi TMP2, TMP3, HI
    |  B_X
    |    B_move_x0 AT3, RC
    |    B_ld_x1 AT2, TMP3
    |  B_X
    |    B_addi_x0 RD, PC, -4+OFS_RD
    |    B_ld4s_x1 TMP2, TMP2
    |  B_X
    |    B_addli_x0 RC, RC, 1
    |    B_ld2u_x1 RD, RD
    |  cmpeq AT, TMP2, TISNIL
    |  bnez AT, <1		// Skip holes in array part.
    |  B_X
    |    B_addi_x0 AT, RA, 4
    |    B_st4_x1 RA, AT3
    |  B_X
    |    B_moveli_x0 TMP3, (-(BCBIAS_J*4 >> 16) & 65535)
    |    B_st4_x1 AT, TISNUM
    |  B_X
    |    B_shl16insli_x0 TMP3, TMP3, 0
    |    B_addi_x1 AT, RA, 8
    |  B_X
    |    //decode_RD4b RD
    |    B_shli_x0 RD, RD, 2
    |    B_st_x1 AT, AT2
    |  B_X
    |    B_add_x0 RD, RD, TMP3
    |    B_addi_x1 AT, RA, -8+LO
    |  B_X
    |    B_add_x0 PC, PC, RD
    |    B_st4_x1 AT, RC
    |3:
    |  ins_next
    |
    |5:  // Traverse hash part.
    |  addlo TMP1, TAB:RB->hmask
    |  B_X
    |    B_sub_x0 RC, RC, TMP0
    |    B_ld4u_x1 TMP1, TMP1
    |  addlo TMP2, TAB:RB->node
    |  ld4u TMP2, TMP2
    |6:
    |  B_X
    |    B_cmpltu_x0 AT, TMP1, RC // End of iteration? Branch to ITERL+1.
    |    B_shli_x1 TMP3, RC, 5
    |  B_X
    |    B_shli_x0 RB, RC, 3
    |    B_bnez_x1 AT, <3
    |  sub TMP3, TMP3, RB
    |  add NODE:TMP3, TMP3, TMP2
    |  addi RB, NODE:TMP3, HI
    |  ld4s RB, RB
    |  B_X
    |    B_addi_x0 RD, PC, -4+OFS_RD
    |    B_ld_x1 AT2, NODE:TMP3
    |  B_X
    |    B_addli_x0 RC, RC, 1
    |    B_ld2u_x1 RD, RD
    |  cmpeq AT, RB, TISNIL
    |  B_X
    |    B_addlo_x0 AT3, NODE:TMP3->key
    |    B_bnez_x1 AT, <6		// Skip holes in hash part.
    |  B_X
    |    B_moveli_x0 TMP3, (-(BCBIAS_J*4 >> 16) & 65535)
    |    B_ld_x1 AT3, AT3
    |  B_X
    |    B_shl16insli_x0 TMP3, TMP3, 0
    |    B_addi_x1 AT, RA, 8
    |  B_X
    |    B_add_x0 RC, RC, TMP0
    |    B_st_x1 AT, AT2
    |  decode_RD4b RD
    |  B_X
    |    B_add_x0 RD, RD, TMP3
    |    B_st_x1 RA, AT3
    |  B_X
    |    B_add_x0 PC, PC, RD
    |    B_addi_x1 AT, RA, -8+LO
    |  st4 AT, RC
    |  b <3
    |.else // DUALNUM
    |  // RA = base*8, (RB = (nresults+1)*8, RC = (nargs+1)*8 (2+1)*8)
    |.if JIT
    |  // NYI: add hotloop, record BC_ITERN.
    |.endif
    |  add RA, BASE, RA
    |  addi TAB:RB, RA, -16+LO
    |  B_X
    |    B_addi_x0 RC, RA, -8+LO
    |    B_ld4s_x1 TAB:RB, TAB:RB
    |  B_X
    |    B_addlo_x0 TMP0, TAB:RB->asize
    |    B_ld4s_x1 RC, RC
    |  B_X
    |    B_addlo_x0 TMP1, TAB:RB->array
    |    B_ld4u_x1 TMP0, TMP0
    |  B_X
    |    B_addli_x0 PC, PC, 4
    |    B_ld4u_x1 TMP1, TMP1
    |1:  // Traverse array part.
    |  B_X
    |    B_cmpltu_x0 AT, RC, TMP0
    |    B_shli_x1 TMP3, RC, 3
    |  B_X
    |    B_add_x0 TMP3, TMP1, TMP3
    |    B_beqz_x1 AT, >5			// Index points after array part?
    |  addi TMP2, TMP3, HI
    |  B_X
    |    B_move_x0 AT3, RC
    |    B_ld_x1 AT2, TMP3
    |  B_X
    |    B_addi_x0 RD, PC, -4+OFS_RD
    |    B_ld4s_x1 TMP2, TMP2
    |  B_X
    |    B_addli_x0 RC, RC, 1
    |    B_ld2u_x1 RD, RD
    |  cmpeq AT, TMP2, TISNIL
    |  B_X
    |    B_cmpltsi_x0 AT5, AT3, 0
    |    B_bnez_x1 AT, <1		// Skip holes in array part.
    |  B_X
    |    B_sub_x0 AT1, zero, AT3
    |    B_moveli_x1 AT4, 539
    |  B_X
    |    B_cmovnez_x0 AT3, AT5, AT1
    |    B_shli_x1 AT4, AT4, 8
    |  B_X
    |    B_bfins_x0 AT4, AT5, 20, 20
    |    B_shli_x1 AT1, AT3, 4
    |  fdouble_pack1 AT3, AT1, AT4
    |  B_X
    |    B_fdouble_pack2_x0 AT3, AT1, zero
    |    B_moveli_x1 TMP3, (-(BCBIAS_J*4 >> 16) & 65535)
    |  B_X
    |    B_shl16insli_x0 TMP3, TMP3, 0
    |    B_addi_x1 AT, RA, 8
    |  B_X
    |    //decode_RD4b RD
    |    B_shli_x0 RD, RD, 2
    |    B_st_x1 AT, AT2
    |  B_X
    |    B_add_x0 RD, RD, TMP3
    |    B_addi_x1 AT, RA, -8+LO
    |  B_X
    |    B_add_x0 PC, PC, RD
    |    B_st4_x1 AT, RC
    |  st RA, AT3
    |3:
    |  ins_next
    |
    |5:  // Traverse hash part.
    |  addlo TMP1, TAB:RB->hmask
    |  B_X
    |    B_sub_x0 RC, RC, TMP0
    |    B_ld4u_x1 TMP1, TMP1
    |  addlo TMP2, TAB:RB->node
    |  ld4u TMP2, TMP2
    |6:
    |  B_X
    |    B_cmpltu_x0 AT, TMP1, RC // End of iteration? Branch to ITERL+1.
    |    B_shli_x1 TMP3, RC, 5
    |  B_X
    |    B_shli_x0 RB, RC, 3
    |    B_bnez_x1 AT, <3
    |  sub TMP3, TMP3, RB
    |  add NODE:TMP3, TMP3, TMP2
    |  addi RB, NODE:TMP3, HI
    |  ld4s RB, RB
    |  B_X
    |    B_addi_x0 RD, PC, -4+OFS_RD
    |    B_ld_x1 AT2, NODE:TMP3
    |  B_X
    |    B_addli_x0 RC, RC, 1
    |    B_ld2u_x1 RD, RD
    |  cmpeq AT, RB, TISNIL
    |  B_X
    |    B_addlo_x0 AT3, NODE:TMP3->key
    |    B_bnez_x1 AT, <6		// Skip holes in hash part.
    |  B_X
    |    B_moveli_x0 TMP3, (-(BCBIAS_J*4 >> 16) & 65535)
    |    B_ld_x1 AT3, AT3
    |  B_X
    |    B_shl16insli_x0 TMP3, TMP3, 0
    |    B_addi_x1 AT, RA, 8
    |  B_X
    |    B_add_x0 RC, RC, TMP0
    |    B_st_x1 AT, AT2
    |  decode_RD4b RD
    |  B_X
    |    B_add_x0 RD, RD, TMP3
    |    B_st_x1 RA, AT3
    |  B_X
    |    B_add_x0 PC, PC, RD
    |    B_addi_x1 AT, RA, -8+LO
    |  st4 AT, RC
    |  b <3
    |.endif
    break;

  case BC_ISNEXT:
    |  // RA = base*8, RD = target (points to ITERN)
    |  add RA, BASE, RA
    |  B_X
    |    B_addi_x0 CFUNC:TMP1, RA, -24
    |    B_addi_x1 TMP2, RA, -16+HI
    |  B_X
    |    B_addi_x0 TMP3, RA, -8+HI
    |    B_ld_x1 TMP1, TMP1
    |  B_X
    |    B_addi_x0 AT, zero, LJ_TFUNC
    |    B_ld4s_x1 TMP2, TMP2
    |  ld4s TMP3, TMP3
    |  B_X
    |    B_bfexts_x0 TMP1, TMP1, 0, 31
    |    B_shrsi_x1 TMP0, TMP1, 32
    |  B_X
    |    B_addli_x0 TMP2, TMP2, 12 //-LJ_TTAB
    |    B_cmpne_x1 AT, TMP0, AT
    |  B_X
    |    B_addlo_x0 TMP1, CFUNC:TMP1->ffid
    |    B_bnez_x1 AT, >5
    |  B_X
    |    B_addli_x0 TMP3, TMP3, -LJ_TNIL
    |    B_ld1u_x1 TMP1, TMP1
    |  B_X
    |    B_shrui_x0 TMP0, RD, 1
    |    B_or_x1 TMP2, TMP2, TMP3
    |  B_X
    |    B_addli_x0 TMP1, TMP1, -FF_next_N
    |    B_add_x1 TMP0, PC, TMP0
    |  B_X
    |    B_or_x0 TMP1, TMP1, TMP2
    |    B_moveli_x1 TMP2, (-(BCBIAS_J*4 >> 16) & 65535)
    |  B_X
    |    B_shl16insli_x0 TMP2, TMP2, 0
    |    B_bnez_x1 TMP1, >5
    |  B_X
    |    B_add_x0 PC, TMP0, TMP2
    |    B_moveli_x1 TMP1, -2
    |  B_X
    |    B_shl16insli_x0 TMP1, TMP1, 0x7fff
    |    B_addi_x1 AT, RA, -8+LO
    |  B_X
    |    B_addi_x0 AT1, RA, -8+HI
    |    B_st4_x1 AT, zero
    |  st4 AT1, TMP1
    |1:
    |  ins_next
    |5:  // Despecialize bytecode if any of the checks fail.
    |  B_X
    |    B_addi_x0 TMP3, zero, BC_JMP
    |    B_addi_x1 TMP1, zero, BC_ITERC
    |  addi AT, PC, -4 + OFS_OP
    |  B_X
    |    B_add_x0 PC, TMP0, TMP2
    |    B_st1_x1 AT, TMP3
    |  //addi AT, PC, OFS_OP
    |  st1 PC, TMP1
    |  b <1
    break;

  case BC_VARG:
    |  // RA = base*8, RB = (nresults+1)*8, RC = numparams*8
    |  addi TMP0, BASE, FRAME_PC
    |  B_X
    |    //decode_RDtoRC8 RC, RD
    |    B_bfextu_x0 RC, RD, 3, 10
    |    B_ld4s_x1 TMP0, TMP0
    |  B_X
    |    B_shli_x0 RC, RC, 3
    |    //decode_RB8a RB, INS
    |    B_shrui_x1 RB, INS, 21
    |  B_X
    |    //decode_RB8b RB
    |    B_bfextu_x0 RB, RB, 3, 10
    |    B_add_x1 RC, BASE, RC
    |  B_X
    |    B_shli_x0 RB, RB, 3
    |    B_add_x1 RA, BASE, RA
    |  B_X
    |    B_addli_x0 RC, RC, FRAME_VARG
    |    B_add_x1 TMP2, RA, RB
    |  B_X
    |    B_addli_x0 TMP3, BASE, -8		// TMP3 = vtop
    |    B_sub_x1 RC, RC, TMP0		// RC = vbase
    |  B_X
    |    // Note: RC may now be even _above_ BASE if nargs was < numparams.
    |    B_sub_x0 TMP1, TMP3, RC
    |    B_beqz_x1 RB, >5			// Copy all varargs?
    |  addli TMP2, TMP2, -16
    |1:  // Copy vararg slots to destination slots.
    |  addi CARG1, RC, HI
    |  B_X
    |    B_cmpltu_x0 AT, RC, TMP3
    |    B_ld4s_x1 CARG1, CARG1
    |  B_X
    |    B_cmoveqz_x0 CARG1, AT, TISNIL
    |    B_ld4s_add_x1 CARG2, RC, 8
    |  B_X
    |    B_addi_x0 AT, RA, HI
    |    B_st4_x1 RA, CARG2
    |  B_X
    |    B_cmpltu_x0 AT1, RA, TMP2
    |    B_st4_x1 AT, CARG1
    |  B_X
    |    B_addli_x0 RA, RA, 8
    |    B_bnez_x1 AT1, <1
    |3:
    |  ins_next
    |
    |5:  // Copy all varargs.
    |  addlo TMP0, L->maxstack
    |  B_X
    |    B_addi_x0 MULTRES, zero, 8			// MULTRES = (0+1)*8
    |    B_ld4u_x1 TMP0, TMP0
    |  B_X
    |    B_add_x0 TMP2, RA, TMP1
    |    B_blez_x1 TMP1, <3			// No vararg slots?
    |  B_X
    |    B_cmpltu_x0 AT, TMP0, TMP2
    |    B_addli_x1 MULTRES, TMP1, 8
    |  bnez AT, >7
    |6:
    |  ld_add AT2, RC, 8
    |  B_X
    |    B_cmpltu_x0 AT, RC, TMP3
    |    B_st_add_x1 RA, AT2, 8
    |  bnez AT, <6			// More vararg slots?
    |  b <3
    |
    |7:  // Grow stack for varargs.
    |  //load_got lj_state_growstack
    |  B_X
    |    B_addli_x0 CFUNCADDR, DISPATCH, DISPATCH_GOT(lj_state_growstack)
    |    B_addlo_x1 AT1, L->base
    |  B_X
    |    B_addlo_x0 AT, L->top
    |    B_ld_x1 CFUNCADDR, CFUNCADDR
    |  B_X
    |    B_sub_x0 RA, RA, BASE
    |    B_st_x1 AT, RA
    |  B_X
    |    B_sub_x0 BASE, RC, BASE		// Need delta, because BASE may change.
    |    B_st_x1 AT1, BASE
    |  addi AT, sp, SAVE_PC
    |  B_X
    |    B_shrui_x0 CARG2, TMP1, 3
    |    B_st_x1 AT, PC
    |  B_X
    |    B_move_x0 CARG1, L
    |    //call_intern lj_state_growstack	// (lua_State *L, int n)
    |    B_jalr_x1 CFUNCADDR
    |  B_X
    |    B_move_x0 RC, BASE
    |    B_addlo_x1 BASE, L->base
    |  ld BASE, BASE
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_add_x1 RC, BASE, RC
    |  B_X
    |    B_addli_x0 TMP3, BASE, -8
    |    B_b_x1 <6
    break;

  /* -- Returns ----------------------------------------------------------- */

  case BC_RETM:
    |  // RA = results*8, RD = extra_nresults*8
    |  add RD, RD, MULTRES		// MULTRES >= 8, so RD >= 8.
    |  // Fall through. Assumes BC_RET follows.
    break;

  case BC_RET:
    |  // RA = results*8, RD = (nresults+1)*8
    |  B_X
    |    B_addi_x0 PC, BASE, FRAME_PC
    |    B_move_x1 MULTRES, RD
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_ld4s_x1 PC, PC
    |1:
    |  B_X
    |    B_andi_x0 TMP0, PC, FRAME_TYPE
    |    B_xori_x1 TMP1, PC, FRAME_VARG
    |  bnez TMP0, ->BC_RETV_Z
    |
    |->BC_RET_Z:
    |  // BASE = base, RA = resultptr, RD = (nresults+1)*8, PC = return
    |  addi INS, PC, -4
    |  B_X
    |    B_addi_x0 TMP2, BASE, -8
    |    B_ld4u_x1 INS, INS
    |  B_X
    |    B_addi_x0 RC, RD, -8
    |    //decode_RA8a TMP0, INS
    |    B_shrui_x1 TMP0, INS, 5
    |  B_X
    |    //decode_RA8b TMP0
    |    B_bfextu_x0 TMP0, TMP0, 3, 10
    |    //decode_RB8a RB, INS
    |    B_shrui_x1 RB, INS, 21
    |  B_X
    |    //decode_RB8b RB
    |    B_bfextu_x0 RB, RB, 3, 10
    |    B_shli_x1 TMP0, TMP0, 3
    |  B_X
    |    B_shli_x0 RB, RB, 3
    |    B_sub_x1 BASE, TMP2, TMP0
    |  B_X
    |    B_add_x0 TMP3, TMP2, RB
    |    B_beqz_x1 RC, >3
    |2:
    |  B_X
    |    B_addli_x0 RC, RC, -8
    |    B_ld_add_x1 AT2, RA, 8
    |  st_add TMP2, AT2, 8
    |  bnez RC, <2
    |3:
    |  addli TMP3, TMP3, -8
    |5:
    |  B_X
    |    B_cmpltu_x0 AT, TMP2, TMP3
    |    B_addi_x1 LFUNC:TMP1, BASE, FRAME_FUNC
    |  ld4s LFUNC:TMP1, LFUNC:TMP1
    |  bnez AT, >6
    |  B_X
    |    B_addlo_x0 TMP1, LFUNC:TMP1->pc
    |    //ins_next1
    |    B_ld4u_add_x1 INS, PC, 4
    |  ld4u TMP1, TMP1
    |  addi KBASE, TMP1, PC2PROTO(k)
    |  ld4u KBASE, KBASE
    |  ins_next2
    |
    |6:  // Fill up results with nil.
    |  addi AT, TMP2, HI
    |  B_X
    |    B_addli_x0 TMP2, TMP2, 8
    |    B_st4_x1 AT, TISNIL
    |  b <5
    |
    |->BC_RETV_Z:  // Non-standard return case.
    |  andi TMP2, TMP1, FRAME_TYPEP
    |  bnez TMP2, ->vm_return
    |  // Return from vararg function: relocate BASE down.
    |  sub BASE, BASE, TMP1
    |  addi PC, BASE, FRAME_PC
    |  ld4s PC, PC
    |  b <1
    break;

  case BC_RET0: case BC_RET1:
    |  // RA = results*8, RD = (nresults+1)*8
    |  addi PC, BASE, FRAME_PC
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_ld4s_x1 PC, PC
    |  B_X
    |    B_move_x0 MULTRES, RD
    |    B_andi_x1 TMP0, PC, FRAME_TYPE
    |  B_X
    |    B_xori_x0 TMP1, PC, FRAME_VARG
    |    B_bnez_x1 TMP0, ->BC_RETV_Z
    |  addi INS, PC, -4
    |  B_X
    |    B_addli_x0 TMP2, BASE, -8
    |    B_ld4u_x1 INS, INS
    if (op == BC_RET1) {
      |  ld AT2, RA
    }
    |  B_X
    |    //decode_RB8a RB, INS
    |    B_shrui_x0 RB, INS, 21
    |    //decode_RA8a RA, INS
    |    B_shrui_x1 RA, INS, 5
    |  //decode_RB8b RB
    |  bfextu RB, RB, 3, 10
    |  B_X
    |    //decode_RA8b RA
    |    B_bfextu_x0 RA, RA, 3, 10
    |    B_shli_x1 RB, RB, 3
    |  shli RA, RA, 3
    if (op == BC_RET1) {
      |  st TMP2, AT2
    }
    |   sub BASE, TMP2, RA
    |5:
    |  B_X
    |    B_cmpltu_x0 AT, RD, RB
    |    B_addi_x1 LFUNC:TMP1, BASE, FRAME_FUNC
    |  ld4s LFUNC:TMP1, LFUNC:TMP1
    |  bnez AT, >6
    |  B_X
    |    B_addlo_x0 TMP1, LFUNC:TMP1->pc
    |    //ins_next1
    |    B_ld4u_add_x1 INS, PC, 4
    |  ld4u TMP1, TMP1
    |  addi KBASE, TMP1, PC2PROTO(k)
    |  ld4u KBASE, KBASE
    |  ins_next2
    |
    |6:  // Fill up results with nil.
    |  B_X
    |    B_addli_x0 TMP2, TMP2, 8
    |    B_addli_x1 RD, RD, 8
    if (op == BC_RET1) {
      |  addi AT, TMP2, HI
      |  st4 AT, TISNIL
    } else {
      |  addi AT, TMP2, -8+HI
      |  st4 AT, TISNIL
    }
    |  b <5
    break;

  /* -- Loops and branches ------------------------------------------------ */

  case BC_FORL:
    |.if JIT
    |  hotloop
    |.endif
    |  // Fall through. Assumes BC_IFORL follows.
    break;

  case BC_JFORI:
  case BC_JFORL:
#if !LJ_HASJIT
    break;
#endif
  case BC_FORI:
  case BC_IFORL:
    |  // RA = base*8, RD = target (after end of loop or start of loop)
    vk = (op == BC_IFORL || op == BC_JFORL);
    |.if DUALNUM
    |  // Integer loop.
    |  B_X
    |    B_add_x0 RA, BASE, RA
    |    B_add_x1 AT6, BASE, RA
    if (vk) {
      |  ld_add AT2, AT6, 8 //FORL_IDX
      |  ld_add AT3, AT6, 8 //FORL_STOP
      |  B_X
      |    B_shrsi_x0 TMP1, AT2, 32
      |    B_ld_add_x1 AT4, AT6, 8 //FORL_STEP
      |  B_X
      |    B_bfexts_x0 CARG1, AT2, 0, 31
      |    B_cmpne_x1 AT, TMP1, TISNUM
      |  B_X
      |    B_bfexts_x0 CARG3, AT4, 0, 31
      |    B_bnez_x1 AT, >9
      |  B_X
      |    B_add_x0 CARG1, CARG1, CARG3
      |    B_cmplts_x1 AT, CARG3, zero
      |4:
      |  B_X
      |    B_bfexts_x0 CARG2, AT3, 0, 31
      |    B_st4_x1 RA, CARG1
    } else {
      |  //FORL_IDX*8
      |  ld_add AT2, AT6, 8 //FORL_IDX
      |  ld_add AT3, AT6, 8 //FORL_STOP
      |  ld_add AT4, AT6, 8 //FORL_STEP
      |  B_X
      |    B_bfexts_x0 CARG1, AT2, 0, 31
      |    B_shrsi_x1 TMP1, AT2, 32
      |  B_X
      |    B_cmpne_x0 AT, TMP1, TISNUM
      |    B_shrsi_x1 TMP2, AT3, 32
      |  B_X
      |    B_bfexts_x0 CARG2, AT3, 0, 31
      |    B_shrsi_x1 TMP3, AT4, 32
      |  B_X
      |    B_bfexts_x0 CARG3, AT4, 0, 31
      |    B_cmpne_x1 AT1, TMP3, TISNUM
      |  B_X
      |    B_or_x0 AT, AT, AT1
      |    B_cmpne_x1 AT5, TMP2, TISNUM
      |  or AT1, AT, AT5
      |  B_X
      |    B_cmplts_x0 AT, CARG3, zero
      |    B_bnez_x1 AT1, >9
    }
    |  bnez AT, >5
    |  cmples AT, CARG1, CARG2
    |1:
    |  addi AT1, RA, FORL_EXT*8 + 4
    |  st4 AT1, TISNUM
    if (op != BC_JFORL) {
      |  shrui RD, RD, 1
    }
    |  addi AT1, RA, FORL_EXT*8
    |  st4 AT1, CARG1
    if (op != BC_JFORL) {
      |  add RD, PC, RD
    }
    if (op == BC_FORI) {
      |  B_X
      |    B_moveli_x0 TMP0, (-(BCBIAS_J*4 >> 16) & 65535)
      |    B_bnez_x1 AT, >2
      |  shl16insli TMP0, TMP0, 0
      |  add PC, RD, TMP0
    } else if (op == BC_JFORI) {
      |  moveli TMP0, (-(BCBIAS_J*4 >> 16) & 65535)
      |  shl16insli TMP0, TMP0, 0
      |  add PC, RD, TMP0
      |  addi RD, PC, -4+OFS_RD
      |  ld2u RD, RD
      |  B_X
      |    //decode_RD8b RD
      |    B_shli_x0 RD, RD, 3
      |    B_bnez_x1 AT, =>BC_JLOOP
    } else if (op == BC_IFORL) {
      |  B_X
      |    B_moveli_x0 TMP0, (-(BCBIAS_J*4 >> 16) & 65535)
      |    B_beqz_x1 AT, >2
      |  shl16insli TMP0, TMP0, 0
      |  add PC, RD, TMP0
    } else {
      |  bnez AT, =>BC_JLOOP
    }
    |2:
    |  ins_next
    |5:  // Invert check for negative step.
    |  B_X
    |    B_cmples_x0 AT, CARG2, CARG1
    |    B_b_x1 <1
    |.endif
    |  add RA, BASE, RA
    if (vk) {
      |9:
      |  B_X
      |    B_fdouble_add_flags_x0 AT, AT2, AT4
      |    B_shrsi_x1 TMP3, AT4, 32
      |  fdouble_unpack_min AT1, AT2, AT4
      |  fdouble_unpack_max AT4, AT2, AT4
      |  fdouble_addsub AT4, AT1, AT
      |  fdouble_pack1 AT2, AT4, AT
      |  B_X
      |    B_fdouble_pack2_x0 AT2, AT4, zero
      |    B_addi_x1 AT, RA, FORL_IDX*8
      |  st AT, AT2
    } else {
      |9:
      |  B_X
      |    B_shrsi_x0 TMP1, AT2, 32
      |    B_shrsi_x1 TMP2, AT3, 32
      |  B_X
      |    B_cmpltu_x0 TMP1, TMP1, TISNUM
      |    B_shrsi_x1 TMP3, AT4, 32
      |  B_X
      |    B_cmpltu_x0 TMP0, TMP3, TISNUM
      |    B_cmpltu_x1 TMP2, TMP2, TISNUM
      |  and TMP1, TMP1, TMP0
      |  and TMP1, TMP1, TMP2
      |  beqz TMP1, ->vmeta_for
    }
    if (op != BC_JFORL) {
      |  B_X
      |    B_shrui_x0 RD, RD, 1
      |    B_moveli_x1 TMP0, (-(BCBIAS_J*4 >> 16) & 65535)
      |  shl16insli TMP0, TMP0, 0
    }
    |  fdouble_add_flags AT, AT2, AT3
    |  B_X
    |    B_fdouble_add_flags_x0 AT1, AT3, AT2
    |    B_addi_x1 AT4, RA, FORL_EXT*8
    |  st AT4, AT2
    if (op == BC_JFORI) {
      |  B_X
      |    B_addi_x0 TMP1, zero, 1
      |    B_addi_x1 TMP2, zero, 1
      |  B_X
      |    B_add_x0 TMP0, RD, TMP0
      |    B_cmplts_x1 TMP3, TMP3, zero
      |  bfextu AT4, AT, 27, 27
      |  B_X
      |    B_cmoveqz_x0 TMP1, AT4, zero 
      |    B_add_x1 PC, PC, TMP0
      |  bfextu AT4, AT1, 27, 27
      |  B_X
      |    B_cmoveqz_x0 TMP2, AT4, zero
      |    B_addi_x1 RD, PC, -4+OFS_RD
      |  B_X
      |    B_cmovnez_x0 TMP1, TMP3, TMP2
      |    B_ld2u_x1 RD, RD
      |  B_X
      |    //decode_RD8b RD
      |    B_shli_x0 RD, RD, 3
      |    B_bnez_x1 TMP1, =>BC_JLOOP
    } else if (op == BC_JFORL) {
      |  B_X
      |    B_addi_x0 TMP1, zero, 1
      |    B_addi_x1 TMP2, zero, 1
      |  B_X
      |    B_bfextu_x0 AT4, AT, 27, 27
      |    B_cmplts_x1 TMP3, TMP3, zero
      |  cmoveqz TMP1, AT4, zero
      |  bfextu AT4, AT1, 27, 27
      |  cmoveqz TMP2, AT4, zero
      |  cmovnez TMP1, TMP3, TMP2
      |  bnez TMP1, =>BC_JLOOP
    } else {
      |  B_X
      |    B_add_x0 TMP1, RD, TMP0
      |    B_cmplts_x1 TMP3, TMP3, zero
      if (op == BC_FORI) {
        |  B_X
        |    B_bfextu_x0 AT4, AT, 27, 27
        |    B_move_x1 TMP2, TMP1
	|  cmovnez TMP1, AT4, zero
        |  bfextu AT4, AT1, 27, 27
	|  cmovnez TMP2, AT4, zero
      } else {
        |  B_X
        |    B_bfextu_x0 AT4, AT, 27, 27
        |    B_move_x1 TMP2, TMP1
	|  cmoveqz TMP1, AT4, zero
        |  bfextu AT4, AT1, 27, 27
	|  cmoveqz TMP2, AT4, zero
      }
      |  cmovnez TMP1, TMP3, TMP2
      |  add PC, PC, TMP1
    }
    |  ins_next
    break;

  case BC_ITERL:
    |.if JIT
    |  hotloop
    |.endif
    |  // Fall through. Assumes BC_IITERL follows.
    break;

  case BC_JITERL:
#if !LJ_HASJIT
    break;
#endif
  case BC_IITERL:
    |  // RA = base*8, RD = target
    |  add RA, BASE, RA
    |  ld TMP2, RA
    |  shrsi TMP1, TMP2, 32
    |  B_X
    |    B_bfexts_x0 TMP2, TMP2, 0, 31
    |    B_cmpeq_x1 AT, TMP1, TISNIL
    |  bnez AT, >1		// Stop if iterator returned nil.
    if (op == BC_JITERL) {
      |  addi AT, RA, -8+HI
      |  B_X
      |    B_addi_x0 AT1, RA, -8+LO
      |    B_st4_x1 AT, TMP1
      |  st4 AT1, TMP2
      |  b =>BC_JLOOP
    } else {
      |  branch_RD			// Otherwise save control var + branch.
      |  addi AT, RA, -8+HI
      |  B_X
      |    B_addi_x0 AT1, RA, -8+LO
      |    B_st4_x1 AT, TMP1
      |  st4 AT1, TMP2
    }
    |1:
    |  ins_next
    break;

  case BC_LOOP:
    |  // RA = base*8, RD = target (loop extent)
    |  // Note: RA/RD is only used by trace recorder to determine scope/extent
    |  // This opcode does NOT jump, it's only purpose is to detect a hot loop.
    |.if JIT
    |  hotloop
    |.endif
    |  // Fall through. Assumes BC_ILOOP follows.
    break;

  case BC_ILOOP:
    |  // RA = base*8, RD = target (loop extent)
    |  ins_next
    break;

  case BC_JLOOP:
    |.if JIT
    |  // RA = base*8 (ignored), RD = traceno*8
    |  addli TMP1, DISPATCH, DISPATCH_J(trace)
    |  B_X
    |    B_shrui_x0 RD, RD, 1
    |    B_ld_x1 TMP1, TMP1
    |  add TMP1, TMP1, RD
    |  B_X
    |    B_addli_x0 AT1, DISPATCH, DISPATCH_GL(vmstate)
    |    B_ld_x1 TRACE:TMP2, TMP1
    |  B_X
    |    B_addli_x0 AT, DISPATCH, DISPATCH_GL(jit_base)
    |    B_st4_x1 AT1, zero
    |  B_X
    |    B_addli_x0 AT1, DISPATCH, DISPATCH_GL(jit_L)
    |    B_st4_x1 AT, BASE
    |  B_X
    |    B_addlo_x0 TMP2, TRACE:TMP2->mcode
    |    B_st4_x1 AT1, L
    |  ld TMP2, TMP2
    |  B_X
    |    B_addli_x0 JGL, DISPATCH, GG_DISP2G+32768
    |    B_jr_x1 TMP2
    |.endif
    break;

  case BC_JMP:
    |  // RA = base*8 (only used by trace recorder), RD = target
    |  branch_RD
    |  ins_next
    break;

  /* -- Function headers -------------------------------------------------- */

  case BC_FUNCF:
    |.if JIT
    |  hotcall
    |.endif
  case BC_FUNCV:  /* NYI: compiled vararg functions. */
    |  // Fall through. Assumes BC_IFUNCF/BC_IFUNCV follow.
    break;

  case BC_JFUNCF:
#if !LJ_HASJIT
    break;
#endif
  case BC_IFUNCF:
    |  // BASE = new base, RA = BASE+framesize*8, RB = LFUNC, RC = nargs*8
    |  addlo TMP2, L->maxstack
    |  B_X
    |    B_addi_x0 TMP1, PC, -4+PC2PROTO(numparams)
    |    B_ld4u_x1 TMP2, TMP2
    |  B_X
    |    B_addi_x0 KBASE, PC, -4+PC2PROTO(k)
    |    B_ld1u_x1 TMP1, TMP1
    |  B_X
    |    B_cmpltu_x0 AT, TMP2, RA
    |    B_ld4u_x1 KBASE, KBASE
    |  B_X
    |    B_shli_x0 TMP1, TMP1, 3
    |    B_bnez_x1 AT, ->vm_growstack_l
    if (op != BC_JFUNCF) {
      |  ins_next1
    }
    |2:
    |  B_X
    |    B_cmpltu_x0 AT1, NARGS8:RC, TMP1		// Check for missing parameters.
    |    B_add_x1 AT, BASE, NARGS8:RC
    |  bnez AT1, >3
    if (op == BC_JFUNCF) {
      |  decode_RD8a RD, INS
      |  //decode_RD8b RD
      |  B_X
      |    B_shli_x0 RD, RD, 3
      |    B_b_x1 =>BC_JLOOP
    } else {
      |  ins_next2
    }
    |
    |3:  // Clear missing parameters.
    |  addi AT1, AT, HI
    |  B_X
    |    B_addli_x0 NARGS8:RC, NARGS8:RC, 8
    |    B_st4_x1 AT1, TISNIL
    |  b <2
    break;

  case BC_JFUNCV:
#if !LJ_HASJIT
    break;
#endif
    |  NYI  // NYI: compiled vararg functions
    break;  /* NYI: compiled vararg functions. */

  case BC_IFUNCV:
    |  // BASE = new base, RA = BASE+framesize*8, RB = LFUNC, RC = nargs*8
    |  B_X
    |    B_add_x0 TMP1, BASE, RC
    |    B_addlo_x1 TMP2, L->maxstack
    |  B_X
    |    B_add_x0 TMP0, RA, RC
    |    B_ld4u_x1 TMP2, TMP2
    |  B_X
    |    B_addli_x0 TMP3, RC, 8+FRAME_VARG
    |    B_st4_x1 TMP1, LFUNC:RB
    |  B_X
    |    B_cmpltu_x0 AT1, TMP0, TMP2
    |    B_addi_x1 KBASE, PC, -4+PC2PROTO(k)
    |  B_X
    |    B_addi_x0 AT, TMP1, HI
    |    B_ld4u_x1 KBASE, KBASE
    |  st4 AT, TMP3
    |  B_X
    |    B_addi_x0 AT, PC, -4+PC2PROTO(numparams)
    |    B_beqz_x1 AT1, ->vm_growstack_l
    |  B_X
    |    B_move_x0 RA, BASE
    |    B_ld1u_x1 TMP2, AT
    |  B_X
    |    //ins_next1
    |    B_move_x0 RC, TMP1
    |    B_ld4u_add_x1 INS, PC, 4
    |  B_X
    |    B_addli_x0 BASE, TMP1, 8
    |    B_beqz_x1 TMP2, >3
    |1:
    |  B_X
    |    B_cmpltu_x0 AT, RA, RC			// Less args than parameters?
    |    B_ld_x1 TMP3, RA
    |  B_X
    |    B_bfexts_x0 TMP3, TMP3, 0, 31
    |    B_shrsi_x1 TMP0, TMP3, 32
    |  B_X
    |    B_cmoveqz_x0 TMP0, AT, TISNIL
    |    B_move_x1 CARG1, TMP0
    |  B_X
    |    B_cmovnez_x0 CARG1, AT, TISNIL
    |    B_addi_x1 AT, TMP1, 8+LO
    |  B_X
    |    B_addli_x0 TMP2, TMP2, -1
    |    B_st4_x1 AT, TMP3
    |  addi AT, TMP1, 8+HI
    |  B_X
    |    B_addli_x0 TMP1, TMP1, 8
    |    B_st4_x1 AT, TMP0
    |  addi AT, RA, HI
    |  B_X
    |    B_addli_x0 RA, RA, 8
    |    B_st4_x1 AT, CARG1
    |  bnez TMP2, <1
    |3:
    |  ins_next2
    break;

  case BC_FUNCC:
  case BC_FUNCCW:
    |  // BASE = new base, RA = BASE+framesize*8, RB = CFUNC, RC = nargs*8
    if (op == BC_FUNCC) {
      |  addlo CFUNCADDR, CFUNC:RB->f
      |  B_X
      |    B_add_x0 TMP1, RA, NARGS8:RC
      |    B_ld_x1 CFUNCADDR, CFUNCADDR
    } else {
      |  addli CFUNCADDR, DISPATCH, DISPATCH_GL(wrapf)
      |  B_X
      |    B_add_x0 TMP1, RA, NARGS8:RC
      |    B_ld_x1 CFUNCADDR, CFUNCADDR
    }
    |  B_X
    |    B_addlo_x0 TMP2, L->maxstack
    |    B_add_x1 RC, BASE, NARGS8:RC
    |  B_X
    |    B_addlo_x0 AT2, L->base
    |    B_ld4u_x1 TMP2, TMP2
    |  B_X
    |    B_cmpltu_x0 AT, TMP2, TMP1
    |    B_st_x1 AT2, BASE
    |  addlo AT1, L->top
    |  B_X
    |    //li_vmstate C
    |    B_moveli_x0 TMP0, ~LJ_VMST_C
    |    B_st_x1 AT1, RC
    if (op == BC_FUNCCW) {
      |  addlo CARG2, CFUNC:RB->f
      |  ld CARG2, CARG2
    }
    |  B_X
    |    B_move_x0 CARG1, L
    |    B_bnez_x1 AT, ->vm_growstack_c	// Need to grow stack.
    |  st_vmstate
    |  jalr CFUNCADDR			// (lua_State *L [, lua_CFunction f])
    |  // Returns nresults.
    |  addlo BASE, L->base
    |  B_X
    |    B_shli_x0 RD, CRET1, 3
    |    B_ld_x1 BASE, BASE
    |  B_X
    |    B_addlo_x0 TMP1, L->top
    |    B_addi_x1 PC, BASE, FRAME_PC
    |  B_X
    |    //li_vmstate INTERP
    |    B_moveli_x0 TMP0, ~LJ_VMST_INTERP
    |    B_ld_x1 TMP1, TMP1
    |  B_X
    |    B_sub_x0 RA, TMP1, RD		// RA = L->top - nresults*8
    |    B_ld4s_x1 PC, PC
    |  st_vmstate
    |  b ->vm_returnc
    break;

  /* ---------------------------------------------------------------------- */

  default:
    fprintf(stderr, "Error: undefined opcode BC_%s\n", bc_names[op]);
    exit(2);
    break;
  }
}

static int build_backend(BuildCtx *ctx)
{
  int op;

  dasm_growpc(Dst, BC__MAX);

  build_subroutines(ctx);

  |.code_op
  for (op = 0; op < BC__MAX; op++)
    build_ins(ctx, (BCOp)op, op);

  return BC__MAX;
}

/* Emit pseudo frame-info for all assembler functions. */
static void emit_asm_debug(BuildCtx *ctx)
{
  int fcofs = ctx->bc_ofs[BC_FUNCCW];
  switch (ctx->mode) {
  case BUILD_elfasm:
    fprintf(ctx->fp, "\t.section .eh_frame,\"aw\",@progbits\n");
    fprintf(ctx->fp,
	"\t.globl lj_err_unwind_dwarf\n"
	".Lframe1:\n"
	"\t.4byte .LECIE1-.LSCIE1\n"
	".LSCIE1:\n"
	"\t.4byte 0\n"
	"\t.byte 0x1\n"
	"\t.string \"zPR\"\n"
	"\t.uleb128 0x1\n"
	"\t.sleb128 -8\n"
	"\t.byte 0x37\n"
	"\t.uleb128 10\n"			/* augmentation length */
	"\t.byte 0\n"
	"\t.8byte lj_err_unwind_dwarf\n"
	"\t.byte 0x1c\n"
	"\t.byte 0xc\n\t.uleb128 0x36\n\t.uleb128 0\n"
	"\t.align 8\n"
	".LECIE1:\n\n");
    fprintf(ctx->fp,
	".LSFDE2:\n"
	"\t.4byte .LEFDE2-.LASFDE2\n"
	".LASFDE2:\n"
	"\t.4byte .LASFDE2-.Lframe1\n"
	"\t.8byte .Lbegin\n"
	"\t.8byte %d\n"
	"\t.uleb128 0\n"			/* augmentation length */
	"\t.byte 0xe\n\t.uleb128 %d\n"
	"\t.byte 0xb7\n\t.sleb128 13\n"   /* lr */
	"\t.byte 0xb4\n\t.sleb128 12\n",  /* fp */
	fcofs, CFRAME_SIZE);
    fprintf(ctx->fp,
	"\t.align 8\n"
	".LEFDE2:\n\n");
#if LJ_HASFFI
    fprintf(ctx->fp,
	".Lframe2:\n"
	"\t.4byte .LECIE2-.LSCIE2\n"
	".LSCIE2:\n"
	"\t.4byte 0\n"
	"\t.byte 0x1\n"
	"\t.string \"zR\"\n"
	"\t.uleb128 0x1\n"
	"\t.sleb128 -4\n"
	"\t.byte 31\n"
	"\t.uleb128 1\n"			/* augmentation length */
	"\t.byte 0\n"
	"\t.byte 0xc\n\t.uleb128 29\n\t.uleb128 0\n"
	"\t.align 2\n"
	".LECIE2:\n\n");
    fprintf(ctx->fp,
	".LSFDE3:\n"
	"\t.4byte .LEFDE3-.LASFDE3\n"
	".LASFDE3:\n"
	"\t.4byte .LASFDE3-.Lframe2\n"
	"\t.8byte lj_vm_ffi_call\n"
	"\t.8byte %d\n"
	"\t.uleb128 0\n"			/* augmentation length */
	"\t.byte 0xb7\n\t.sleb128 13\n"   /* lr */
	"\t.byte 0xb4\n\t.sleb128 12\n"   /* fp */
	"\t.byte 0xd\n\t.uleb128 0x10\n"
	"\t.align 8\n"
	".LEFDE3:\n\n", (int)ctx->codesz - fcofs);
#endif
    break;
  default:
    break;
  }
}

